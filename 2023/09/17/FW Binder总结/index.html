<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Roboto-Black:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Android,系统源码," />










<meta name="description" content="跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于 Linux的动态内核可加载模块（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译， 但是不能独立运行。它在运行时被链接到">
<meta property="og:type" content="article">
<meta property="og:title" content="Binder总结">
<meta property="og:url" content="http://yoursite.com/2023/09/17/FW%20Binder%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="WZKingdom-个人博客">
<meta property="og:description" content="跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于 Linux的动态内核可加载模块（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译， 但是不能独立运行。它在运行时被链接到">
<meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/WEB05a2be2615b8aafb64509e6b80d27c9c?method=download&shareKey=ae7691508872565960006bd052486f4f">
<meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/WEB952bd9647a30851bd833b99e2e0597b6?method=download&shareKey=78cc7149cb6cf7706498543e988d821b">
<meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/WEBe8b639edcfbc0ca9f2ce30e8c7ae5dff?method=download&shareKey=ac21ff3e14c9010a0b4976ceea2e6d25">
<meta property="article:published_time" content="2023-09-17T15:26:43.000Z">
<meta property="article:modified_time" content="2024-10-28T13:52:45.213Z">
<meta property="article:author" content="WZKingdom">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="系统源码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note.youdao.com/yws/api/personal/file/WEB05a2be2615b8aafb64509e6b80d27c9c?method=download&shareKey=ae7691508872565960006bd052486f4f">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2023/09/17/FW Binder总结/"/>





  <title>Binder总结 | WZKingdom-个人博客</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
		<a href="https://github.com/WKingdom" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">WZKingdom-个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">那些疯狂到以为自己能够改变世界的人，才能真正改变世界。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    


  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/09/17/FW%20Binder%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WZKingdom">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WZKingdom-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Binder总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-09-17T23:26:43+08:00">
                2023-09-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">系统源码</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9.4k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于 Linux的动态内核可加载模块（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译， 但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。</p>
<p> 在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 Binder驱 动（Binder Dirver）。</p>
<p> 那么在 Android 系统中用户进程之间是如何通过这个内核模块（Binder 驱动）来实现通信的呢？难道是和前面说的 传统 IPC 机制一样，先将数据从发送方进程拷贝到内核缓存区，然后再将数据从内核缓存区拷贝到接收方进程，通过 两次拷贝来实现吗？显然不是。</p>
<p> 这就涉及到Linux 下的另一个概念：<strong>内存映射</strong>。 </p>
<p>Binder IPC 机制中涉及到的内存映射通过 <strong>mmap()</strong> 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。</p>
<p>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</p>
<p> <strong>Binder IPC 正是基于内存映射（mmap）来实现的，但是 mmap() 通常是用在有物理介质的文件系统上的。</strong> </p>
<p>比如进程中的用户区域是不能直接和物理设备打交道的，如果想要把磁盘上的数据读取到进程的用户区域，需要两次 拷贝（磁盘–&gt;内核空间–&gt;用户空间）；通常在这种场景下 mmap() 就能发挥作用，通过在物理介质和用户空间之间 建立映射，减少数据的拷贝次数，用内存读写取代I/O读写，提高文件读取效率。 </p>
<p>而 Binder 并不存在物理介质，因此 Binder 驱动使用 mmap() 并不是为了在物理介质和用户空间之间建立映射，而是在内核空间创建数据接收的缓存空间。</p>
<p> 一次完整的 Binder IPC 通信过程通常是这样：</p>
<ol>
<li>首先 Binder 驱动在内核空间创建一个数据接收缓存区</li>
<li>接着在内核空间开辟一块内核缓存区，建立内核缓存区和内核中数据接收缓存区之间的映射关系，以及内核中数据接收缓存区和接收进程用户空间地址的映射关系；发送方进程通过系统调用 </li>
<li>copyfromuser() 将数据 copy 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB05a2be2615b8aafb64509e6b80d27c9c?method=download&shareKey=ae7691508872565960006bd052486f4f" alt=""></p>
<p><strong>性能</strong><br>首先说说性能上的优势。Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。<br><strong>稳定性</strong><br>再说说稳定性，Binder 基于 C/S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。<br><strong>安全性</strong> </p>
<p>另一方面就是安全性。Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于Android 平台而言极其重要。作为用户当然不希望我们下载的 APP 偷偷读取我的通信录，上传我的隐私数据，后台偷跑流量、消耗手机电量。传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。首先传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。<br>基于上述原因，Android 需要建立一套新的 IPC 机制来满足系统对稳定性、传输性能和安全性方面的要求，这就是Binder。</p>
<h4 id="Binder何时初始化"><a href="#Binder何时初始化" class="headerlink" title="Binder何时初始化"></a>Binder何时初始化</h4><p>Binder初始化一般是指binder驱动的初始化，在使用binder的过程中，从来没有执行过new Binder的方式来实现Binder初始化，原因很简单：binder初始化有它自身独立的特点。</p>
<p>每一个应用进程启动的时候，都是通过zygote fork产生的，所以，当fork产生进程后app进程的代码就开始执行，开始运行的地方如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, </span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">long</span>[] disabledCompatChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">		RuntimeInit.redirectLogStreams();</span><br><span class="line">        RuntimeInit.commonInit();<span class="comment">//初始化运行环境 </span></span><br><span class="line">        ZygoteInit.nativeZygoteInit();<span class="comment">//启动Binder ，方法在 androidRuntime.cpp中注册</span></span><br><span class="line">        <span class="comment">// 通过反射创建程序入口函数的 Method 对象，并返回 Runnable 对象</span></span><br><span class="line">        <span class="comment">//ActivityThread.main();</span></span><br><span class="line">        <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv,</span><br><span class="line">                classLoader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，会执行ZygoteInit.nativeZygoteInit()函数，而nativeZygoteInit函数执行appRuntime的onZygoteInit<br>代码，也就是App_main.cpp中的 onZygoteInit()函数，函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onZygoteInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">    proc-&gt;startThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ProcessState的self函数里面就会初始化ProcessState（），而这个初始化的一个非常重要的动作就是启动binder驱动和并构建binder的Map映射。具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::ProcessState(<span class="keyword">const</span> <span class="keyword">char</span> *driver)</span><br><span class="line">    : mDriverName(String8(driver))</span><br><span class="line">    , mDriverFD(open_driver(driver)) <span class="comment">//打开binder的虚拟驱动</span></span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(<span class="number">0</span>)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , mStarvationStartTimeMs(<span class="number">0</span>)</span><br><span class="line">    , mBinderContextCheckFunc(<span class="literal">nullptr</span>)</span><br><span class="line">    , mBinderContextUserData(<span class="literal">nullptr</span>)</span><br><span class="line">    , mThreadPoolStarted(<span class="literal">false</span>)</span><br><span class="line">    , mThreadPoolSeq(<span class="number">1</span>)</span><br><span class="line">    , mCallRestriction(CallRestriction::NONE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//调用mmap接口向Binder驱动中申请内核空间的内存</span></span><br><span class="line">        <span class="comment">// mmap the binder, providing a chunk of virtual address space to receive  transactions.</span></span><br><span class="line">        mVMStart = mmap(<span class="literal">nullptr</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE,mDriverFD, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mVMStart == MAP_FAILED) &#123;</span><br><span class="line">            <span class="built_in">close</span>(mDriverFD);</span><br><span class="line">            mDriverFD = <span class="number">-1</span>;</span><br><span class="line">            mDriverName.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，总的来说，Binder的初始化是在进程已创建就完成了。创建进程后会第一时间为这个进程打开一个binder驱动，并调用mmap接口向Binder驱动中申请内核空间的内存。</p>
<h4 id="Binder通信的流程"><a href="#Binder通信的流程" class="headerlink" title="Binder通信的流程"></a>Binder通信的流程</h4><ol>
<li><p>首先，一个进程使用 BINDERSETCONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager，Binder的引用在所有Client中都固定为0；</p>
</li>
<li><p>Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。</p>
</li>
<li><p>Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用。</p>
</li>
<li><p>通过这个Binder实体引用，Client实现和 Server 进程的通信。</p>
</li>
</ol>
<h4 id="aidl通信的基本步骤"><a href="#aidl通信的基本步骤" class="headerlink" title="aidl通信的基本步骤"></a>aidl通信的基本步骤</h4><ol>
<li><p>Client通过ServiceConnection获取到Server的Binder，并且封装成一个Proxy。 </p>
</li>
<li><p>通过Proxy来同步调用IPC方法（xxxFunction），同时通过Parcel将参数传给Binder，最终触发Binder的 transact方法。</p>
</li>
<li><p>Binder的transact方法最终会触发到Server上Stub的onTransact方法。 </p>
</li>
<li><p>Server上Stub的onTransact方法中，会先从Parcel中解析中参数，然后将参数带入真正的方法中执行，然后将 结果写入Parcel后传回。 </p>
</li>
<li><p>请注意：Client的Ipc方法中，执行Binder的transact时，是阻塞等待的，一直到Server逻辑执行结束后才会继 续执行。当然，如果IPC方法是oneWay的方式，那么就是非阻塞的等待。 </p>
</li>
<li><p>当Server返回结果后，Client从Parcel中取出返回值，于是实现了一次IPC调用。</p>
<h4 id="bindService的全流程"><a href="#bindService的全流程" class="headerlink" title="bindService的全流程"></a>bindService的全流程</h4><p>将Server端的Binder对象发送给Client端</p>
</li>
<li><p>Activity作为Client发起bindService，最终会调度到AMS 去执行bindService。在这个过程中，Client要去调用 AMS的代码，所以此时就会涉及到跨进程调度，基于第三章的Binder通信模型我们不难知道，Client会先和 ServiceManager通信，从ServiceManager中拿到AMS的IBinder。 </p>
</li>
<li><p>Activity拿到AMS的IBinder后，跨进程执行AMS的BindService函数； </p>
</li>
<li><p>由于AMS管理所有的应用进程，因此AMS中持有了应用进程的Binder，所以此时AMS可以发起第4步也就是跨进 程调度scheduleBindService(); </p>
</li>
<li><p>Server端会在收到AMS的bindService的请求后，会将自己的IBinder发送给client，但是Server必须通过AMS才能 将Binder对象传过去，所以此时需要跨进程从ServiceManager中去拿到AMS的binder； </p>
</li>
<li><p>Server端通过AMS的binder直接调用AMS的代码publishService(),将service的Binder发送给AMS； </p>
</li>
<li><p>经过层层调用，最终AMS讲Server端的binder通过回调connect函数传递给了Client端的Activity；</p>
</li>
</ol>
<h4 id="Java与Native-通信的基本流程"><a href="#Java与Native-通信的基本流程" class="headerlink" title="Java与Native 通信的基本流程"></a>Java与Native 通信的基本流程</h4><p><img src="https://note.youdao.com/yws/api/personal/file/WEB952bd9647a30851bd833b99e2e0597b6?method=download&shareKey=78cc7149cb6cf7706498543e988d821b" alt=""></p>
<ol>
<li>Client端通过ServiceManager 拿到Server端服务的Binder 代理，也就是BinderProxy(是Server端Binder的一个代理)；</li>
<li>这个BinderProxy的访问需要经过JNI层的Android_util_binder类将请求转交给native的BpBinder（p代表代理的意思）；</li>
<li>BpBinder会通过ioctl将请求转交给Binder驱动设备；</li>
<li>在服务端注册了一个监听请求的回调函数，一旦驱动层收到BpBinder 的调用，就会回调BBInder注册的回调函数，于是，就将请求转给了BBinder；</li>
<li>BBinder拿到请求后，会进行一些数据的处理，然后通过JNI将请求转交给了java类；</li>
<li>java层会通过aidl中的函数将请求发送给Server端的实现者，由Server端通过stub 去调用相关的执行代码，并将结果通过类似的路径返回。</li>
</ol>
<h4 id="ServcieManager场景"><a href="#ServcieManager场景" class="headerlink" title="ServcieManager场景"></a>ServcieManager场景</h4><p>在跨进程通信过程中，比如与AMS通信，首先需要拿到AMS的binder，然而，AMS的binder往往是通过ServcieManager获取的，因此会有代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceManager.getService(Context.ACTIVITY_SERVICE)</span><br></pre></td></tr></table></figure>

<p>j接下来调用Binder.allowBlocking(rawGetService(name))，核心代码在rawGetService中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IBinder <span class="title">rawGetService</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException </span>&#123; </span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">final</span> IBinder binder = getIServiceManager().getService(name); </span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">return</span> binder; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑是，先通过getIServiceManager()获取到IServiceManager对象，然后再通过这个IServiceManager对象获取到一个IBinder。<br>注意，此处有两个IPC：</p>
<ol>
<li><p>获取到IServiceManager</p>
</li>
<li><p>通过IServiceManager获取到该name的Service的Binder的IPC</p>
<p>重在探索java到native的逻辑，先看第一个。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager <span class="title">getIServiceManager</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (sServiceManager != <span class="keyword">null</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> sServiceManager; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// Find the service manager </span></span><br><span class="line"> sServiceManager = ServiceManagerNative </span><br><span class="line"> .asInterface(Binder.allowBlocking(BinderInternal.getContextObject())); </span><br><span class="line"> <span class="keyword">return</span> sServiceManager; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这，可以看到返回的其实是ServiceManagerNative.asInterface()的返回值。<br>对AIDL有所了解就知道，asInterface()的内容大概如下：<br>这个方法属于aidl接口的内部类 Stub。 在同一进程中，就会直接返回Stub，如果在另一个进程中调用，就会返回将这个ibinder封装好的Proxy对象。后面会分析ServiceManagerNative.asInterface 函数。先看一下IBinder的来源，也就BinderInternal.getContextObject()。<br>BinderInternal.getContextObject()代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">native</span> IBinder <span class="title">getContextObject</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>JNI层代码如下：<br>android_util_Binder.android_os_BinderInternal_getContextObject()代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">android_os_BinderInternal_getContextObject</span><span class="params">(JNIEnv* env, jobject clazz)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">return</span> javaObjectForIBinder(env, b); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先通过ProcessState获取到了一个native 层的IBinder强引用，也就是一个BpBinder。 然后将这个native层的IBinder强引用传入javaObjectForIBinder()方法，最终封装成java层的IBinder然后返回。此处先不深究ProcessState的逻辑，整个native层的binder有自己的一整套的逻辑，后面的文章会继续探索。我们可以先稍微看下javaObjectForIBinder()的大概逻辑。 android_util_Binder.javaObjectForIBinder()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个BpBinder对象(这是native中的类型)转换成java中的类型 </span></span><br><span class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"> <span class="comment">//JavaBBinder返回true，其他类均返回flase </span></span><br><span class="line">    <span class="keyword">if</span> (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123; </span><br><span class="line">        <span class="comment">// It's a JavaBBinder created by ibinderForJavaObject. Already has Java object. </span></span><br><span class="line">        jobject object = <span class="keyword">static_cast</span>&lt;JavaBBinder*&gt;(val.<span class="built_in">get</span>())-&gt;object(); </span><br><span class="line">        LOGDEATH(<span class="string">"objectForBinder %p: it's our own %p!\n"</span>, val.<span class="built_in">get</span>(), object); </span><br><span class="line">        <span class="keyword">return</span> object; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    BinderProxyNativeData* nativeData = <span class="keyword">new</span> BinderProxyNativeData(); </span><br><span class="line">    nativeData-&gt;mOrgue = <span class="keyword">new</span> DeathRecipientList; </span><br><span class="line">    nativeData-&gt;mObject = val; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 核心代码：运用反射创建一个BinderProxy对象 </span></span><br><span class="line">    jobject object = env-&gt;CallStaticObjectMethod(gBinderProxyOffsets.mClass, </span><br><span class="line">            gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.<span class="built_in">get</span>()); </span><br><span class="line">    <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123; </span><br><span class="line">        <span class="comment">// In the exception case, getInstance still took ownership of nativeData. </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    BinderProxyNativeData* actualNativeData = getBPNativeData(env, object); </span><br><span class="line"> 	<span class="comment">//如果object是刚刚新建出来的BinderProxy </span></span><br><span class="line">    <span class="keyword">if</span> (actualNativeData == nativeData) &#123; </span><br><span class="line"> 		<span class="comment">//处理proxy计数 </span></span><br><span class="line">        <span class="comment">// Created a new Proxy </span></span><br><span class="line">        <span class="keyword">uint32_t</span> numProxies = gNumProxies.fetch_add(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_relaxed); </span><br><span class="line">        <span class="keyword">uint32_t</span> numLastWarned = gProxiesWarned.load(<span class="built_in">std</span>::memory_order_relaxed); </span><br><span class="line">        <span class="keyword">if</span> (numProxies &gt;= numLastWarned + PROXY_WARN_INTERVAL) &#123; </span><br><span class="line">            <span class="comment">// Multiple threads can get here, make sure only one of them gets to </span></span><br><span class="line">            <span class="comment">// update the warn counter. </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (gProxiesWarned.compare_exchange_strong(numLastWarned, </span><br><span class="line">                        numLastWarned + PROXY_WARN_INTERVAL, <span class="built_in">std</span>::memory_order_relaxed)) </span><br><span class="line">            &#123; </span><br><span class="line">                ALOGW(<span class="string">"Unexpectedly many live BinderProxies: %d\n"</span>, numProxies); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">delete</span> nativeData; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> object;  <span class="comment">//object 是反射参数的java的 BinderProxy </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数就是将一个BpBinder对象(这是native中的类型)转换成java中的类型，中间采用了反射技术而已。</p>
<p>核心代码gBinderProxyOffsets</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">binderproxy_offsets_t</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="comment">// Class state. </span></span><br><span class="line">    jclass mClass; </span><br><span class="line">    jmethodID mGetInstance; </span><br><span class="line">    jmethodID mSendDeathNotice; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Object state. </span></span><br><span class="line">    <span class="comment">//指向BinderProxyNativeData的指针 </span></span><br><span class="line">    jfieldID mNativeData;  <span class="comment">// Field holds native pointer to BinderProxyNativeData. </span></span><br><span class="line">&#125; gBinderProxyOffsets; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kBinderProxyPathName = <span class="string">"android/os/BinderProxy"</span>; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">int_register_android_os_BinderProxy</span><span class="params">(JNIEnv* env)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ... </span><br><span class="line">    jclass clazz = FindClassOrDie(env, kBinderProxyPathName); </span><br><span class="line">    gBinderProxyOffsets.mClass = MakeGlobalRefOrDie(env, clazz); </span><br><span class="line">    gBinderProxyOffsets.mGetInstance = GetStaticMethodIDOrDie(env, clazz, <span class="string">"getInstance"</span>, </span><br><span class="line">            <span class="string">"(JJ)Landroid/os/BinderProxy;"</span>); </span><br><span class="line">    gBinderProxyOffsets.mSendDeathNotice = </span><br><span class="line">            GetStaticMethodIDOrDie(env, clazz, <span class="string">"sendDeathNotice"</span>, </span><br><span class="line">                                   <span class="string">"</span></span><br><span class="line"><span class="string">(Landroid/os/IBinder$DeathRecipient;Landroid/os/IBinder;)V"</span>); </span><br><span class="line">    gBinderProxyOffsets.mNativeData = GetFieldIDOrDie(env, clazz, <span class="string">"mNativeData"</span>, <span class="string">"J"</span>); </span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gBinderProxyOffsets实际上是一个用来记录一些java中对应类、方法以及字段的结构体，用于从native层调用java层代码，而通过int_register_android_os_BinderProxy，我们知道，binderproxy_oﬀsets_t中的mClass字段就是 BInderProxy，而mGetInstance 就是BInderProxy.java 中getInstance方法。因此核心代码创建的是一个BinderProxy对象。</p>
<p>具体的执行流程如下图所示：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe8b639edcfbc0ca9f2ce30e8c7ae5dff?method=download&shareKey=ac21ff3e14c9010a0b4976ceea2e6d25" alt=""></p>
<p><strong>第一大步</strong>：为了获取ServcieManager 的IServiceManager，首先要ServcieManager进程创建一个底层的Binder，所<br>以会有android_os_BinderInternal_getContextObject也就是第2步，第2步会在ProcessState::self()中初始化Binder<br>驱动，然后再执行第3步；<br><strong>第二大步</strong>：上图中第3步会调用到第4步，在第4步getStrongProxyForHandle代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getStrongProxyForHandle</span><span class="params">(<span class="keyword">int32_t</span> handle)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    sp&lt;IBinder&gt; result; </span><br><span class="line"> </span><br><span class="line">    AutoMutex _l(mLock); </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//查找或建立handle对应的handle_entry </span></span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123; </span><br><span class="line">        IBinder* b = e-&gt;binder; </span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">nullptr</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) &#123; </span><br><span class="line">            <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123; </span><br><span class="line">			 <span class="comment">//当handle为ServiceManager的特殊情况 </span></span><br><span class="line">			 <span class="comment">//需要确保在创建Binder引用之前，context manager已经被binder注册 </span></span><br><span class="line">			 <span class="comment">//需要先确保ServcieManager活着 </span></span><br><span class="line">                Parcel data; </span><br><span class="line">                <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact( </span><br><span class="line">                        <span class="number">0</span>, IBinder::PING_TRANSACTION, data, <span class="literal">nullptr</span>, <span class="number">0</span>); </span><br><span class="line">                <span class="keyword">if</span> (status == DEAD_OBJECT) </span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line"> 			<span class="comment">//创建BpBinder并保存下来以便后面再次查找 </span></span><br><span class="line">            b = BpBinder::create(handle); </span><br><span class="line">            e-&gt;binder = b; </span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs(); </span><br><span class="line">            result = b; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// This little bit of nastyness is to allow us to add a primary </span></span><br><span class="line">            <span class="comment">// reference to the remote proxy when this team doesn't have one </span></span><br><span class="line">            <span class="comment">// but another team is sending the handle to us. </span></span><br><span class="line">            result.force_set(b); </span><br><span class="line">            e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中会执行一个BpBinder::create(handle)，此处会创建一个BpBinder对象，并且将BpBinder对象赋值给result对象<br>并返回result，也就是返回BpBinder对象。这个BpBinder对象一路返回，最终在android_util_Binder.cpp中的<br>android_os_BinderInternal_getContextObject函数中执行。</p>
<p><strong>第三大步</strong>：BpBinder需要返回给java层Client端使用，所以此时的封装就是将BpBinder封装成为Java层的BinderProxy对象。因此在Client端得到的IServiceManager 其实是BinderProxy类的子类的对象。所以，BinderInternal.getContextObject()，返回的是一个层层封装的类的实例，具体来说，是Native层的BpBinder对象被封装成为BinderProxy对象并返回。</p>
<h4 id="不同类型的Binder"><a href="#不同类型的Binder" class="headerlink" title="不同类型的Binder"></a>不同类型的Binder</h4><h5 id="IBinder"><a href="#IBinder" class="headerlink" title="IBinder"></a>IBinder</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IBinder从Refbase继承而来，一提供强弱指针计数能力 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBinder</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">enum</span> &#123; </span><br><span class="line">        FIRST_CALL_TRANSACTION  = <span class="number">0x00000001</span>, </span><br><span class="line">        LAST_CALL_TRANSACTION   = <span class="number">0x00ffffff</span>, </span><br><span class="line">        PING_TRANSACTION        = B_PACK_CHARS(<span class="string">'_'</span>,<span class="string">'P'</span>,<span class="string">'N'</span>,<span class="string">'G'</span>), </span><br><span class="line">        DUMP_TRANSACTION        = B_PACK_CHARS(<span class="string">'_'</span>,<span class="string">'D'</span>,<span class="string">'M'</span>,<span class="string">'P'</span>), </span><br><span class="line">        INTERFACE_TRANSACTION   = B_PACK_CHARS(<span class="string">'_'</span>, <span class="string">'N'</span>, <span class="string">'T'</span>, <span class="string">'F'</span>), </span><br><span class="line">        SYSPROPS_TRANSACTION    = B_PACK_CHARS(<span class="string">'_'</span>, <span class="string">'S'</span>, <span class="string">'P'</span>, <span class="string">'R'</span>), </span><br><span class="line">        <span class="comment">// Corresponds to TF_ONE_WAY -- an asynchronous call. </span></span><br><span class="line">        FLAG_ONEWAY             = <span class="number">0x00000001</span> </span><br><span class="line">    &#125;; </span><br><span class="line"> 	IBinder(); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 根据descriptor查询相应的IInterface对象 </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IInterface&gt;  <span class="title">queryLocalInterface</span><span class="params">(<span class="keyword">const</span> String16&amp; descriptor)</span></span>; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取descriptor描述符 </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> String16&amp; <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>            <span class="title">isBinderAlive</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span>        <span class="title">pingBinder</span><span class="params">()</span> </span>= <span class="number">0</span>; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span>        <span class="title">dump</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> Vector&lt;String16&gt;&amp; args)</span> </span>= <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// transact binder通信函数 </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span>  <span class="title">transact</span><span class="params">(<span class="keyword">uint32_t</span> code, </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">const</span> Parcel&amp; data, </span></span></span><br><span class="line"><span class="function"><span class="params">                               Parcel* reply, </span></span></span><br><span class="line"><span class="function"><span class="params">							   <span class="keyword">uint32_t</span> flags = <span class="number">0</span>)</span> </span>= <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 死亡通知相应类 </span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DeathRecipient</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase </span><br><span class="line">    &#123; </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">(<span class="keyword">const</span> wp&lt;IBinder&gt;&amp; who)</span> </span>= <span class="number">0</span>; </span><br><span class="line">    &#125;; </span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 如其名，用于注册Binder用的 </span></span><br><span class="line"> 	<span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span>  <span class="title">linkToDeath</span><span class="params">(<span class="keyword">const</span> sp&lt;DeathRecipient&gt;&amp; recipient, </span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">void</span>* cookie = <span class="literal">NULL</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">uint32_t</span> flags = <span class="number">0</span>)</span> </span>= <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 撤销用之前注册的死亡通知函数 </span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span>  <span class="title">unlinkToDeath</span><span class="params">(  <span class="keyword">const</span> wp&lt;DeathRecipient&gt;&amp; recipient, </span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">void</span>* cookie = <span class="literal">NULL</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">uint32_t</span> flags = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">                                            wp&lt;DeathRecipient&gt;* outRecipient = <span class="literal">NULL</span>)</span> </span>= <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">heckSubclass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* subclassID)</span> <span class="keyword">const</span></span>; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*object_cleanup_func)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id, <span class="keyword">void</span>* obj, <span class="keyword">void</span>* cleanupCookie)</span></span>; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">attachObject</span><span class="params">(   <span class="keyword">const</span> <span class="keyword">void</span>* objectID, </span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">void</span>* object, </span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">void</span>* cleanupCookie, </span></span></span><br><span class="line"><span class="function"><span class="params">                                            object_cleanup_func func)</span> </span>= <span class="number">0</span>; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>* <span class="title">findObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* objectID)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>  <span class="title">detachObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* objectID)</span> </span>= <span class="number">0</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 返回服务端的binder引用 </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> BBinder* <span class="title">localBinder</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 放回客户端的binder引用 </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> BpBinder* <span class="title">remoteBinder</span><span class="params">()</span></span>; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line">    <span class="keyword">virtual</span> ~IBinder(); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于IBinder中的方法，基本都是没有实现的，这些方法的实现都交给继承它的子类来实现，那下面直接看BpBinder的内容。</p>
<h5 id="BpBinder-BBinder"><a href="#BpBinder-BBinder" class="headerlink" title="BpBinder,BBinder"></a>BpBinder,BBinder</h5><p>BpBinder和BBinder都是Android中与Binder通信相关的代表，他们都是从IBinder中继承而来的。其中BpBinder是客户端用来与Server交互的代理类，BBinder则是和proxy相对的一端，它是proxy交互的目的端。如果说Proxy代表客户端，那么BBinder就代表这服务端。这里BpBinder和BBinder是一一对应的，即某个BpBinder只能和对应的BBinder交互。</p>
<h5 id="JavaBBinder"><a href="#JavaBBinder" class="headerlink" title="JavaBBinder"></a>JavaBBinder</h5><p>IBinder是BBinder的父类，BBinder是JavaBBinder的父类。<br>java层直接与native层交互的对象有两个——Binder对象与BinderProxy对象。<br>Binder对应“Binder在本进程”的场景，BinderProxy对应“Binder在其他进程”的场景。<br>native层javaBBinder与java层的Binder一一对应。<br>native层的BinderProxyNativeData与java层的BinderProxy一一对应。<br>在native层，gBinderProxyOﬀsets(binderproxy_oﬀsets_t)存储了java层binderProxy的对象与需要调用的方法和属<br>性。gBinderOﬀsets(binderproxy_oﬀsets_t)存储了java层binder的对象与需要调用的方法和属性。<br>ibinderForJavaObject负责通过java的Binder或者BinderProxy对象，找到并返回native层的IBinder对象。</p>
<p>javaObjectForIBinder通过native层的IBinder对象，找到或者封装成java对象返回。</p>
<h4 id="ServiceManager-getService方法"><a href="#ServiceManager-getService方法" class="headerlink" title="ServiceManager.getService方法"></a>ServiceManager.getService方法</h4><p>第一步：先调用IServiceManager.Stub.Proxy的getService方法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">getService</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> </span></span><br><span class="line"><span class="function">android.os.RemoteException </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain(); </span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain(); </span><br><span class="line">    android.os.IBinder _result; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR); </span><br><span class="line">        _data.writeString(name); </span><br><span class="line">        <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_getService, _data, _reply, </span><br><span class="line">                          <span class="number">0</span>); </span><br><span class="line">        _reply.readException(); </span><br><span class="line">        _result = _reply.readStrongBinder(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">finally</span> &#123; </span><br><span class="line">        _reply.recycle(); </span><br><span class="line">        _data.recycle(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> _result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：接下来会调用mRemote.transact </p>
<p>而mRemote则是BinderProxy对象，所以接下来执行下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> </span></span><br><span class="line"><span class="function">RemoteException </span>&#123; </span><br><span class="line">    <span class="comment">//检查Parcel大小 if (CHECK_PARCEL_SIZE &amp;&amp; parcel.dataSize() &gt;= 800*1024)</span></span><br><span class="line">    Binder.checkParcel(<span class="keyword">this</span>, code, data, <span class="string">"Unreasonably large binder buffer"</span>);</span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">//trace </span></span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">//Binder事务处理回调 </span></span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">//AppOpsManager信息记录 </span></span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> result = transactNative(code, data, reply, flags); </span><br><span class="line">        <span class="keyword">if</span> (reply != <span class="keyword">null</span> &amp;&amp; !warnOnBlocking) &#123; </span><br><span class="line">            reply.addFlags(Parcel.FLAG_IS_REPLY_FROM_BLOCKING_ALLOWED_OBJECT); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> result; </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，系统会通过checkParcel检测数据的格式和大小，Android默认设置了Parcel数据传输不能超过800k,如果超过了的话，便会调用Slog.wtfStack打印日志，需要注意的是，在当前进程不是系统进程并且系统也不是工程版本的情况下，这个方法是会结束进程的，所以在应用开发的时候，我们需要注意跨进程数据传输的大小，避免因此引发crash。</p>
<p>核心函数是调用transactNative方法，这是一个native方法，在frameworks/base/core/jni/android_util_Binder.cpp中实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj, </span></span></span><br><span class="line"><span class="function"><span class="params">        jint code, jobject dataObj, jobject replyObj, jint flags)</span>  </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (dataObj == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        jniThrowNullPointerException(env, <span class="literal">NULL</span>); </span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    Parcel* data = parcelForJavaObject(env, dataObj); </span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE; </span><br><span class="line">    &#125; </span><br><span class="line">    Parcel* reply = parcelForJavaObject(env, replyObj); </span><br><span class="line">    <span class="keyword">if</span> (reply == <span class="literal">NULL</span> &amp;&amp; replyObj != <span class="literal">NULL</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    IBinder* target = getBPNativeData(env, obj)-&gt;mObject.<span class="built_in">get</span>(); </span><br><span class="line">    <span class="keyword">if</span> (target == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>, <span class="string">"Binder has been </span></span><br><span class="line"><span class="string">finalized!"</span>); </span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//log </span></span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">status_t</span> err = target-&gt;transact(code, *data, reply, flags); </span><br><span class="line">    <span class="comment">//log </span></span><br><span class="line">    ... </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123; </span><br><span class="line">        <span class="keyword">return</span> JNI_TRUE; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == UNKNOWN_TRANSACTION) &#123; </span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    signalExceptionForError(env, obj, err, <span class="literal">true</span> <span class="comment">/*canThrowRemoteException*/</span>,  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> data-&gt;dataSize()); </span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先是获得native层对应的Parcel并执行判断，Parcel实际上功能是在native中实现的，java中的Parcel类使用mNativePtr成员变量保存了其对应native中的Parcel的指针，然后调用getBPNativeData函数获得BinderProxy在native中对应的BinderProxyNativeData，再通过里面的mObject域成员变量得到其对应的BpBinder。</p>
<p>getBPNativeData(env, obj)-&gt;mObject.get();是上面代码的核心之一，调用getBPNativeData函数获得BinderProxy在native中对应的BinderProxyNativeData，target 事实上是BpBinder。</p>
<p>第三步，BpBinder 的transact函数<br>此时就顺理成章的调用到了BpBinder的transact函数了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BpBinder::transact</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life. </span></span><br><span class="line">    <span class="comment">//判断binder服务是否存活 </span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123; </span><br><span class="line">        ... </span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact( </span><br><span class="line">            mHandle, code, data, reply, flags); </span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> status; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个Alive判断，可以避免对一个已经死亡的binder服务再发起事务，浪费资源，除此之外便是调用IPCThreadState的transact函数了。</p>
<p>第四步：IPCThreadState的transact函数调用<br>路径：frameworks/native/libs/binder/IPCThreadState.cpp<br>ProcessState负责打开binder驱动并进行mmap映射，而IPCThreadState则是负责与binder驱动进行具体的交互<br>IPCThreadState也有一个self函数，与ProcessState的self不同的是，ProcessState是进程单例，而IPCThreadState是线程单例。<br>我们接着看它的ProcessState的transact函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="keyword">int32_t</span> handle, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">status_t</span> err; </span><br><span class="line">    flags |= TF_ACCEPT_FDS; </span><br><span class="line">    <span class="comment">//log </span></span><br><span class="line">    ...     </span><br><span class="line">    err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">nullptr</span>); </span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123; </span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err); </span><br><span class="line">        <span class="keyword">return</span> (mLastError = err); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;    <span class="comment">//binder事务不为TF_ONE_WAY </span></span><br><span class="line">        <span class="comment">//当线程限制binder事务不为TF_ONE_WAY时 </span></span><br><span class="line">        <span class="keyword">if</span> (UNLIKELY(mCallRestriction != ProcessState::CallRestriction::NONE)) &#123; </span><br><span class="line">            <span class="keyword">if</span> (mCallRestriction == ProcessState::CallRestriction::ERROR_IF_NOT_ONEWAY) &#123; </span><br><span class="line">                <span class="comment">//这个限制只是log记录 </span></span><br><span class="line">                ALOGE(<span class="string">"Process making non-oneway call (code: %u) but is restricted."</span>, code); </span><br><span class="line">                CallStack::logStack(<span class="string">"non-oneway call"</span>, CallStack::getCurrent(<span class="number">10</span>).<span class="built_in">get</span>(), </span><br><span class="line">                    ANDROID_LOG_ERROR); </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">/* FATAL_IF_NOT_ONEWAY */</span> &#123; </span><br><span class="line">                <span class="comment">//这个限制会终止线程 </span></span><br><span class="line">                LOG_ALWAYS_FATAL(<span class="string">"Process may not make non-oneway calls (code: %u)."</span>, code); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (reply) &#123; </span><br><span class="line">            err = waitForResponse(reply); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            Parcel fakeReply; </span><br><span class="line">            err = waitForResponse(&amp;fakeReply); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//log </span></span><br><span class="line">        ... </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">//binder事务为TF_ONE_WAY </span></span><br><span class="line">        err = waitForResponse(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> err; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的重点在于writeTransactionData和waitForResponse，我们依次分析:<br>首先看writeTransactionData:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    binder_transaction_data tr; </span><br><span class="line"> </span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don't pass uninitialized stack data to a remote process */</span> </span><br><span class="line">    <span class="comment">//目标binder句柄值，ServiceManager为0 </span></span><br><span class="line">    tr.target.handle = handle; </span><br><span class="line">    tr.code = code; </span><br><span class="line">    tr.flags = binderFlags; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    tr.cookie = <span class="number">0</span>; </span><br><span class="line">    tr.sender_pid = <span class="number">0</span>; </span><br><span class="line">    tr.sender_euid = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck(); </span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123; </span><br><span class="line">        <span class="comment">//数据大小 </span></span><br><span class="line">        tr.data_size = data.ipcDataSize(); </span><br><span class="line">        <span class="comment">//数据区起始地址 </span></span><br><span class="line">        tr.data.ptr.<span class="built_in">buffer</span> = data.ipcData(); </span><br><span class="line">        <span class="comment">//传递的偏移数组大小 </span></span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>); </span><br><span class="line">        <span class="comment">//偏移数组的起始地址 </span></span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects(); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123; </span><br><span class="line">        tr.flags |= TF_STATUS_CODE; </span><br><span class="line">        *statusBuffer = err; </span><br><span class="line">        tr.data_size = <span class="keyword">sizeof</span>(<span class="keyword">status_t</span>); </span><br><span class="line">        tr.data.ptr.<span class="built_in">buffer</span> = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(statusBuffer); </span><br><span class="line">        tr.offsets_size = <span class="number">0</span>; </span><br><span class="line">        tr.data.ptr.offsets = <span class="number">0</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> (mLastError = err); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//核心代码所在 </span></span><br><span class="line">    <span class="comment">//这里为BC_TRANSACTION </span></span><br><span class="line">    mOut.writeInt32(cmd); </span><br><span class="line">    mOut.<span class="built_in">write</span>(&amp;tr, <span class="keyword">sizeof</span>(tr)); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> NO_ERROR; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>binder_transaction_data结构体(tr结构体）是向Binder驱动通信的数据结构，上面函数中，我们将binder请求码（这里为BC_TRANSACTION）和binder_transaction_data结构体依次写入到mOut中，为之后binder_tansaction做准备。<br>再看waitForResponse函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">uint32_t</span> cmd; </span><br><span class="line">    <span class="keyword">int32_t</span> err; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>; </span><br><span class="line">        err = mIn.errorCheck(); </span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>; </span><br><span class="line">        cmd = (<span class="keyword">uint32_t</span>)mIn.readInt32(); </span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123; </span><br><span class="line">        <span class="keyword">case</span> BR_ONEWAY_SPAM_SUSPECT: </span><br><span class="line">            ... </span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE: </span><br><span class="line">            <span class="comment">//当TF_ONE_WAY模式下收到BR_TRANSACTION_COMPLETE直接返回，本次binder通信结束 </span></span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> BR_DEAD_REPLY: </span><br><span class="line">            ... </span><br><span class="line">        <span class="keyword">case</span> BR_FAILED_REPLY: </span><br><span class="line">            ... </span><br><span class="line">        <span class="keyword">case</span> BR_FROZEN_REPLY: </span><br><span class="line">            ... </span><br><span class="line">        <span class="keyword">case</span> BR_ACQUIRE_RESULT: </span><br><span class="line">            ... </span><br><span class="line">        <span class="keyword">case</span> BR_REPLY: </span><br><span class="line">            &#123; </span><br><span class="line">                binder_transaction_data tr; </span><br><span class="line">                err = mIn.<span class="built_in">read</span>(&amp;tr, <span class="keyword">sizeof</span>(tr)); </span><br><span class="line">                ALOG_ASSERT(err == NO_ERROR, <span class="string">"Not enough command data for brREPLY"</span>); </span><br><span class="line">                <span class="comment">//失败直接返回 </span></span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish; </span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (reply) &#123;    <span class="comment">//客户端需要接收replay </span></span><br><span class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;    <span class="comment">//正常reply内容 </span></span><br><span class="line">                        reply-&gt;ipcSetDataReference( </span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.<span class="built_in">buffer</span>), </span><br><span class="line">                            tr.data_size, </span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets), </span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>), </span><br><span class="line">                            freeBuffer <span class="comment">/*释放缓冲区*/</span>); </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//内容只是一个32位的状态码 </span></span><br><span class="line">                        <span class="comment">//接收状态码 </span></span><br><span class="line">                        err = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">status_t</span>*&gt;(tr.data.ptr.<span class="built_in">buffer</span>); </span><br><span class="line">                        <span class="comment">//释放缓冲区 </span></span><br><span class="line">                        freeBuffer(<span class="literal">nullptr</span>, </span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.<span class="built_in">buffer</span>), </span><br><span class="line">                            tr.data_size, </span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets), </span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>)); </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">//客户端不需要接收replay </span></span><br><span class="line">                    <span class="comment">//释放缓冲区 </span></span><br><span class="line">                    freeBuffer(<span class="literal">nullptr</span>, </span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.<span class="built_in">buffer</span>), </span><br><span class="line">                        tr.data_size, </span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets), </span><br><span class="line">                        tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>)); </span><br><span class="line">                    <span class="keyword">continue</span>; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">goto</span> finish; </span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            <span class="comment">//这里是binder服务端部分的处理，现在不需要关注 </span></span><br><span class="line">            err = executeCommand(cmd); </span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">finish: </span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123; </span><br><span class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err; </span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err); </span><br><span class="line">        mLastError = err; </span><br><span class="line">        logExtendedError(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> err; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个循环，正如函数名所描述，会一直等待到一整条binder事务链结束返回后才会退出这个循环，在这个循环的开头，便是talkWithDriver方法，在talkWithDriver 函数里面主要是调用Binder驱动的ioctl方法完成数据的传输。</p>
<p>上面整理了Client端通过ServiceManager的getService函数去获取对应服务的对象的过程，分析到了将getService请求发送给Binder驱动。下面继续开始分析服务端收到getService的请求后如何处理的总流程。</p>
<h4 id="ServiceManager进程-死循环"><a href="#ServiceManager进程-死循环" class="headerlink" title="ServiceManager进程 死循环"></a>ServiceManager进程 死循环</h4><p>servicemanager进程的入口函数在frameworks\native\cmds\servicemanager\main.cpp中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123; </span><br><span class="line"> <span class="comment">//根据上面的rc文件，argc == 1, argv[0] == "/system/bin/servicemanager" </span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">2</span>) &#123; </span><br><span class="line">        LOG(FATAL) &lt;&lt; <span class="string">"usage: "</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">" [binder driver]"</span>; </span><br><span class="line">    &#125; </span><br><span class="line"> <span class="comment">//此时，要使用的binder驱动为/dev/binder </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* driver = argc == <span class="number">2</span> ? argv[<span class="number">1</span>] : <span class="string">"/dev/binder"</span>; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//初始化binder驱动 </span></span><br><span class="line">    sp&lt;ProcessState&gt; ps = ProcessState::initWithDriver(driver); </span><br><span class="line">    ps-&gt;setThreadPoolMaxThreadCount(<span class="number">0</span>); </span><br><span class="line">    ps-&gt;setCallRestriction(ProcessState::CallRestriction::FATAL_IF_NOT_ONEWAY); </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//实例化ServiceManager，传入Access类用于鉴权 </span></span><br><span class="line">    sp&lt;ServiceManager&gt; manager = <span class="keyword">new</span> ServiceManager(<span class="built_in">std</span>::make_unique&lt;Access&gt;()); </span><br><span class="line">    <span class="comment">//将自身作为服务添加 </span></span><br><span class="line"> <span class="keyword">if</span> (!manager-&gt;addService(<span class="string">"manager"</span>, manager, <span class="literal">false</span> <span class="comment">/*allowIsolated*/</span>, </span><br><span class="line">IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).isOk()) &#123; </span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Could not self register servicemanager"</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//设置服务端Bbinder对象 </span></span><br><span class="line">    IPCThreadState::self()-&gt;setTheContextObject(manager); </span><br><span class="line"> <span class="comment">//设置成为binder驱动的context manager,成为上下文的管理者 </span></span><br><span class="line">    ps-&gt;becomeContextManager(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>); </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//通过Looper epoll机制处理binder事务 </span></span><br><span class="line">    sp&lt;Looper&gt; looper = Looper::<span class="built_in">prepare</span>(<span class="literal">false</span> <span class="comment">/*allowNonCallbacks*/</span>); </span><br><span class="line">    <span class="comment">//通知驱动BC_ENTER_LOOPER，监听驱动fd，有消息时回调到handleEvent处理binder调用 </span></span><br><span class="line">    BinderCallback::setupTo(looper); </span><br><span class="line">    <span class="comment">//服务的注册监听相关 </span></span><br><span class="line">    ClientCallbackCallback::setupTo(looper, manager); </span><br><span class="line">    <span class="comment">//无限循环等消息 </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line">        looper-&gt;pollAll(<span class="number">-1</span>);  </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// should not be reached </span></span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的Looper和我们平常应用开发所说的Looper是一个东西，可以通过Looper::addFd函数监听文件描述符，通过Looper::pollAll或Looper::pollOnce函数接收消息，消息抵达后会回调LooperCallback::handleEvent函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinderCallback</span> :</span> <span class="keyword">public</span> LooperCallback &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">static</span> sp&lt;BinderCallback&gt; <span class="title">setupTo</span><span class="params">(<span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper)</span> </span>&#123; </span><br><span class="line">        sp&lt;BinderCallback&gt; cb = <span class="keyword">new</span> BinderCallback; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> binder_fd = <span class="number">-1</span>; </span><br><span class="line">        <span class="comment">//向binder驱动发送BC_ENTER_LOOPER事务请求，并获得binder设备的文件描述符 </span></span><br><span class="line">        IPCThreadState::self()-&gt;setupPolling(&amp;binder_fd); </span><br><span class="line">        LOG_ALWAYS_FATAL_IF(binder_fd &lt; <span class="number">0</span>, <span class="string">"Failed to setupPolling: %d"</span>, binder_fd); </span><br><span class="line">        <span class="comment">// Flush after setupPolling(), to make sure the binder driver </span></span><br><span class="line">        <span class="comment">// knows about this thread handling commands. </span></span><br><span class="line">        IPCThreadState::self()-&gt;flushCommands(); </span><br><span class="line">         <span class="comment">//监听binder文件描述符 </span></span><br><span class="line">        <span class="keyword">int</span> ret = looper-&gt;addFd(binder_fd, </span><br><span class="line">                                Looper::POLL_CALLBACK, </span><br><span class="line">                                Looper::EVENT_INPUT, </span><br><span class="line">                                cb, </span><br><span class="line">                                <span class="literal">nullptr</span> <span class="comment">/*data*/</span>); </span><br><span class="line">        LOG_ALWAYS_FATAL_IF(ret != <span class="number">1</span>, <span class="string">"Failed to add binder FD to Looper"</span>); </span><br><span class="line">        <span class="keyword">return</span> cb; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">handleEvent</span><span class="params">(<span class="keyword">int</span> <span class="comment">/* fd */</span>, <span class="keyword">int</span> <span class="comment">/* events */</span>, <span class="keyword">void</span>* <span class="comment">/* data */</span>)</span> <span class="keyword">override</span> </span>&#123; </span><br><span class="line">        <span class="comment">//从binder驱动接收到消息并处理 </span></span><br><span class="line">        IPCThreadState::self()-&gt;handlePolledCommands(); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// Continue receiving callbacks. </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在servicemanager进程启动的过程中调用了BinderCallback::setupTo函数，这个函数首先向binder驱动发起了一个BC_ENTER_LOOPER事务请求，获得binder设备的文件描述符，然后调用Looper::addFd函数监听binder设备文件描述符，这样当binder驱动发来消息后，就可以通过Looper::handleEvent函数接收并处理了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::setupPolling</span><span class="params">(<span class="keyword">int</span>* fd)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> -EBADF; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//设置binder请求码 </span></span><br><span class="line">    mOut.writeInt32(BC_ENTER_LOOPER); </span><br><span class="line">    <span class="comment">//检查写缓存是否有可写数据，有的话发送给binder驱动 </span></span><br><span class="line">    flushCommands(); </span><br><span class="line">    <span class="comment">//赋值binder驱动的文件描述符 </span></span><br><span class="line">    *fd = mProcess-&gt;mDriverFD; </span><br><span class="line">    pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock); </span><br><span class="line">    mProcess-&gt;mCurrentThreads++; </span><br><span class="line">    pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于以上的分析，一旦Client端发送IPC请求，就会通过Binder驱动发送消息给服务端，而服务端则通过BinderCallback来接收消息，并做下一步的处理。</p>
<h4 id="Binder驱动事务处理"><a href="#Binder驱动事务处理" class="headerlink" title="Binder驱动事务处理"></a>Binder驱动事务处理</h4><p>BinderCallback类重写了handleEvent函数，里面调用了IPCThreadState::handlePolledCommands函数来接收处理binder事务</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::handlePolledCommands</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">status_t</span> result; </span><br><span class="line">    <span class="comment">//当读缓存中数据未消费完时，持续循环 </span></span><br><span class="line">    <span class="keyword">do</span> &#123; </span><br><span class="line">        result = getAndExecuteCommand(); </span><br><span class="line">    &#125; <span class="keyword">while</span> (mIn.dataPosition() &lt; mIn.dataSize()); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//当我们清空执行完所有的命令后，最后处理BR_DECREFS和BR_RELEASE </span></span><br><span class="line">    processPendingDerefs(); </span><br><span class="line">    flushCommands(); </span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的重点在getAndExecuteCommand，首先无论如何从binder驱动那里读取并处理一次响应，如果处理完后发现读缓存中还有数据尚未消费完，继续循环这个处理过程（理论来说此时不会再从binder驱动那里读写数据，只会处理剩余读缓存）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::getAndExecuteCommand</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">status_t</span> result; </span><br><span class="line">    <span class="keyword">int32_t</span> cmd; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//从binder驱动中读写数据（理论来说此时写缓存dataSize为0，也就是只读数据） </span></span><br><span class="line">    result = talkWithDriver(<span class="comment">/* true */</span>); </span><br><span class="line">    <span class="keyword">if</span> (result &gt;= NO_ERROR) &#123; </span><br><span class="line">        <span class="keyword">size_t</span> IN = mIn.dataAvail(); </span><br><span class="line">        <span class="keyword">if</span> (IN &lt; <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>)) <span class="keyword">return</span> result; </span><br><span class="line">        <span class="comment">//读取BR响应码 </span></span><br><span class="line">        cmd = mIn.readInt32(); </span><br><span class="line">        ... </span><br><span class="line">        result = executeCommand(cmd); </span><br><span class="line">        ... </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从binder驱动中读取数据，然后从数据中读取出BR响应码，接着调用executeCommand函数继续往下处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::executeCommand</span><span class="params">(<span class="keyword">int32_t</span> cmd)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    BBinder* obj; </span><br><span class="line">    RefBase::weakref_type* refs; </span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR; </span><br><span class="line">    <span class="keyword">switch</span> ((<span class="keyword">uint32_t</span>)cmd) &#123; </span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">case</span> BR_TRANSACTION_SEC_CTX: </span><br><span class="line">    <span class="keyword">case</span> BR_TRANSACTION: </span><br><span class="line">        &#123; </span><br><span class="line">            binder_transaction_data_secctx tr_secctx; </span><br><span class="line">            binder_transaction_data&amp; tr = tr_secctx.transaction_data; </span><br><span class="line">            <span class="keyword">if</span> (cmd == (<span class="keyword">int</span>) BR_TRANSACTION_SEC_CTX) &#123; </span><br><span class="line">                result = mIn.<span class="built_in">read</span>(&amp;tr_secctx, <span class="keyword">sizeof</span>(tr_secctx)); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                result = mIn.<span class="built_in">read</span>(&amp;tr, <span class="keyword">sizeof</span>(tr)); </span><br><span class="line">                tr_secctx.secctx = <span class="number">0</span>; </span><br><span class="line">            &#125; </span><br><span class="line">            ALOG_ASSERT(result == NO_ERROR, </span><br><span class="line">                <span class="string">"Not enough command data for brTRANSACTION"</span>); </span><br><span class="line">            <span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">break</span>; </span><br><span class="line">            <span class="comment">//读取数据到缓冲区 </span></span><br><span class="line">            Parcel <span class="built_in">buffer</span>; </span><br><span class="line">            <span class="built_in">buffer</span>.ipcSetDataReference( </span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.<span class="built_in">buffer</span>), </span><br><span class="line">                tr.data_size, </span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets), </span><br><span class="line">                tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>), freeBuffer, <span class="keyword">this</span>); </span><br><span class="line">            ... </span><br><span class="line">            Parcel reply; </span><br><span class="line">            <span class="keyword">status_t</span> error; </span><br><span class="line">            <span class="comment">//对于ServiceManager的binder节点来说，是没有ptr的 </span></span><br><span class="line">            <span class="keyword">if</span> (tr.target.ptr) &#123; </span><br><span class="line">                <span class="comment">// We only have a weak reference on the target object, so we must first try to </span></span><br><span class="line">                <span class="comment">// safely acquire a strong reference before doing anything else with it. </span></span><br><span class="line">                <span class="comment">//对于其他binder服务端来说，tr.cookie为本地BBinder对象指针 </span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">reinterpret_cast</span>&lt;RefBase::weakref_type*&gt;( </span><br><span class="line">                        tr.target.ptr)-&gt;attemptIncStrong(<span class="keyword">this</span>)) &#123; </span><br><span class="line">                    error = <span class="keyword">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, <span class="built_in">buffer</span>, </span><br><span class="line">                            &amp;reply, tr.flags); </span><br><span class="line">                    <span class="keyword">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;decStrong(<span class="keyword">this</span>); </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                    error = UNKNOWN_TRANSACTION; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">//对于ServiceManager来说，使用the_context_object这个BBinder对象 </span></span><br><span class="line">                error = the_context_object-&gt;transact(tr.code, <span class="built_in">buffer</span>, &amp;reply, tr.flags); </span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> ((tr.flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123; </span><br><span class="line">                LOG_ONEWAY(<span class="string">"Sending reply to %d!"</span>, mCallingPid); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error); </span><br><span class="line">                <span class="comment">//非TF_ONE_WAY模式下需要Reply </span></span><br><span class="line">                sendReply(reply, <span class="number">0</span>); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                ... <span class="comment">//TF_ONE_WAY模式下不需要Reply，这里只打了些日志 </span></span><br><span class="line">            &#125; </span><br><span class="line">            ... </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">        ... </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123; </span><br><span class="line">        mLastError = result; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点分析这个函数在BR_TRANSACTION下的case，首先，这个函数从读缓存中读取了binder_transaction_data，我们知道这个结构体记录了实际数据的地址、大小等信息，然后实例化了一个Parcel对象作为缓冲区，从binder_transaction_data中将实际数据读取出来。<br>接着找到本地BBinder对象，对于ServiceManager来说就是之前在main函数中setTheContextObject的ServiceManager对象，而对于其他binder服务端来说，则是通过tr.cookie获取，然后调用BBinder的transact函数。</p>
<p>理论上来说，the_context_object-&gt;transact(tr.code, buﬀer, &amp;reply, tr.ﬂags)，应该是执行ServiceManager中的transact函数，但是在ServiceManager中没有实现该函数，因此只能去父类BnServiceManager中去找transact函数，但是很不巧BnServiceManager中也不存在于是再找父类，只有在BBinder中存在transact函数，因此会执行到BBinder中的transact函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BBinder::transact</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//确保从头开始读取数据 </span></span><br><span class="line">    data.setDataPosition(<span class="number">0</span>); </span><br><span class="line">    <span class="keyword">if</span> (reply != <span class="literal">nullptr</span> &amp;&amp; (flags &amp; FLAG_CLEAR_BUF)) &#123; </span><br><span class="line">        <span class="comment">//标记这个Parcel在释放时需要将内存中数据用0覆盖（涉及安全） </span></span><br><span class="line">        reply-&gt;markSensitive(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">status_t</span> err = NO_ERROR; </span><br><span class="line">    <span class="comment">//这里的code是由binder客户端请求传递过来的 </span></span><br><span class="line">    <span class="comment">//是客户端与服务端的一个约定 </span></span><br><span class="line">    <span class="comment">//它标识了客户端像服务端发起的是哪种请求 </span></span><br><span class="line">    <span class="keyword">switch</span> (code) &#123; </span><br><span class="line">        ... </span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            err = onTransact(code, data, reply, flags); </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// In case this is being transacted on in the same process. </span></span><br><span class="line">    <span class="keyword">if</span> (reply != <span class="literal">nullptr</span>) &#123; </span><br><span class="line">        <span class="comment">//设置数据指针偏移为0，这样后续读取数据便会从头开始 </span></span><br><span class="line">        reply-&gt;setDataPosition(<span class="number">0</span>); </span><br><span class="line">        <span class="keyword">if</span> (reply-&gt;dataSize() &gt; LOG_REPLIES_OVER_SIZE) &#123; </span><br><span class="line">            ALOGW(<span class="string">"Large reply transaction of %zu bytes, interface descriptor %s, code %d"</span>, </span><br><span class="line">                  reply-&gt;dataSize(), String8(getInterfaceDescriptor()).c_str(), code); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> err; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析下继承关系后，会执行到BnServiceManager中的onTransact中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">android::<span class="keyword">status_t</span> <span class="title">BnServiceManager::onTransact</span><span class="params">(<span class="keyword">uint32_t</span> _aidl_code, <span class="keyword">const</span> ::android::Parcel&amp; </span></span></span><br><span class="line"><span class="function"><span class="params">_aidl_data, ::android::Parcel* _aidl_reply, <span class="keyword">uint32_t</span> _aidl_flags)</span> </span>&#123; </span><br><span class="line">  ::android::<span class="keyword">status_t</span> _aidl_ret_status = ::android::OK; </span><br><span class="line">  <span class="keyword">switch</span> (_aidl_code) &#123; </span><br><span class="line">  <span class="comment">// 省略代码 </span></span><br><span class="line">  <span class="keyword">case</span> ::android::IBinder::FIRST_CALL_TRANSACTION + <span class="number">2</span> <span class="comment">/* addService */</span>: </span><br><span class="line">  &#123; </span><br><span class="line">       ::android::binder::Status _aidl_status(addService(in_name, in_service,  in_allowIsolated, in_dumpPriority));  <span class="comment">//addService 是核心 </span></span><br><span class="line">        _aidl_ret_status = _aidl_status.writeToParcel(_aidl_reply); </span><br><span class="line">       <span class="keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123; </span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">    	&#125; </span><br><span class="line">      <span class="keyword">if</span> (!_aidl_status.isOk()) &#123; </span><br><span class="line">      	<span class="keyword">break</span>; </span><br><span class="line">    	&#125; </span><br><span class="line"> 	 &#125;</span><br><span class="line">   <span class="keyword">break</span>; </span><br><span class="line">   <span class="keyword">default</span>: </span><br><span class="line">  &#123; </span><br><span class="line">    _aidl_ret_status = ::android::BBinder::onTransact(_aidl_code, _aidl_data, _aidl_reply, </span><br><span class="line">_aidl_flags); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _aidl_ret_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码的核心是addService，而addService的实现类就是ServiceManager里面的addService函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ServiceManager::addService</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder, <span class="keyword">bool</span> </span></span></span><br><span class="line"><span class="function"><span class="params">allowIsolated, <span class="keyword">int32_t</span> dumpPriority)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">auto</span> ctx = mAccess-&gt;getCallingContext(); </span><br><span class="line">    <span class="comment">// apps cannot add services </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> VENDORSERVICEMANAGER </span></span><br><span class="line">    <span class="keyword">if</span> (!meetsDeclarationRequirements(binder, name)) &#123; </span><br><span class="line">        <span class="comment">// already logged </span></span><br><span class="line">        <span class="keyword">return</span> Status::fromExceptionCode(Status::EX_ILLEGAL_ARGUMENT); </span><br><span class="line">    &#125; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// !VENDORSERVICEMANAGER </span></span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// implicitly unlinked when the binder is removed </span></span><br><span class="line">    <span class="keyword">if</span> (binder-&gt;remoteBinder() != <span class="literal">nullptr</span> &amp;&amp; binder-&gt;linkToDeath(<span class="keyword">this</span>) != OK) &#123; </span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Could not linkToDeath when adding "</span> &lt;&lt; name; </span><br><span class="line">        <span class="keyword">return</span> Status::fromExceptionCode(Status::EX_ILLEGAL_STATE); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Overwrite the old service if it exists </span></span><br><span class="line">    mNameToService[name] = Service &#123; </span><br><span class="line">        .binder = binder, </span><br><span class="line">        .allowIsolated = allowIsolated, </span><br><span class="line">        .dumpPriority = dumpPriority, </span><br><span class="line">        .debugPid = ctx.debugPid, </span><br><span class="line">    &#125;; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> it = mNameToRegistrationCallback.<span class="built_in">find</span>(name); </span><br><span class="line">    <span class="keyword">if</span> (it != mNameToRegistrationCallback.<span class="built_in">end</span>()) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> sp&lt;IServiceCallback&gt;&amp; cb : it-&gt;second) &#123; </span><br><span class="line">            mNameToService[name].guaranteeClient = <span class="literal">true</span>; </span><br><span class="line">            <span class="comment">// permission checked in registerForNotifications </span></span><br><span class="line">            cb-&gt;onRegistration(name, binder); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> Status::ok(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，服务的binder被封装成为了一个Service，并复制给了mNameToService数组进行存储。</p>
<h4 id="IPCThreadState-解析"><a href="#IPCThreadState-解析" class="headerlink" title="IPCThreadState 解析"></a>IPCThreadState 解析</h4><p>在Android中，每个参与Binder通信的线程都会有一个IPCThreadState实例与之关联。我最开始接触到这个类是在BpBinder::transact方法中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">tatus_t</span> <span class="title">BpBinder::transact</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life. </span></span><br><span class="line">    <span class="comment">//判断binder服务是否存活 </span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123; </span><br><span class="line">       <span class="comment">//非核心代码 </span></span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact( </span><br><span class="line">            mHandle, code, data, reply, flags); </span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> status; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其就是调用的IPCThreadState::transact来完成的数据传输工作，其工作可以分为两步：</p>
<p>1、发送数据 </p>
<p>实际上，writeTransactionData只是将数据转换成binder_transaction_data结构并重新写入到IPCThreadState::mOut中。<br>并没有真正的将数据发送出去。实际的发送操作是在waitForResponse中完成的。</p>
<p>2、接收数据 </p>
<p>F_ONE_WAY表示的是单向通信，不需要对端回复。所以这里接收数据就多了几个判断分支。区别就是参数不一样。<br>该函数必定需要被执行的，因为数据要发出去</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="keyword">int32_t</span> handle, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">status_t</span> err; </span><br><span class="line">    flags |= TF_ACCEPT_FDS; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//writeTransactionData函数用于传输数据，其中第一个参数BC_TRANSACTION </span></span><br><span class="line"> <span class="comment">//代表向Binder驱动发送命令协议，向Binder设备发送的命令协议都以BC_开头， </span></span><br><span class="line"> <span class="comment">//而Binder驱动返回的命令协议以BR_开头 </span></span><br><span class="line">    err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">nullptr</span>); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123; </span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err); </span><br><span class="line">        <span class="keyword">return</span> (mLastError = err); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;  <span class="comment">//binder事务不为TF_ONE_WAY </span></span><br><span class="line">        <span class="comment">//省略代码 </span></span><br><span class="line">        <span class="keyword">if</span> (reply) &#123; </span><br><span class="line">            err = waitForResponse(reply); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            Parcel fakeReply; </span><br><span class="line">            err = waitForResponse(&amp;fakeReply); </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        err = waitForResponse(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> err; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">uint32_t</span> cmd; </span><br><span class="line">    <span class="keyword">int32_t</span> err; </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>; </span><br><span class="line">        err = mIn.errorCheck(); </span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>; </span><br><span class="line">        cmd = (<span class="keyword">uint32_t</span>)mIn.readInt32(); </span><br><span class="line"> </span><br><span class="line">        IF_LOG_COMMANDS() &#123; </span><br><span class="line">            alog &lt;&lt; <span class="string">"Processing waitForResponse Command: "</span> </span><br><span class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123; </span><br><span class="line">        <span class="comment">//处理命令 </span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line"> 			<span class="comment">//这里是binder服务端部分的处理</span></span><br><span class="line">            err = executeCommand(cmd); </span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">finish: </span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123; </span><br><span class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err; </span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err); </span><br><span class="line">        mLastError = err; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> err; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要处理如下这些cmd</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *kReturnStrings[] = &#123; </span><br><span class="line">    <span class="string">"BR_ERROR"</span>, </span><br><span class="line">    <span class="string">"BR_OK"</span>, </span><br><span class="line">    <span class="string">"BR_TRANSACTION"</span>, </span><br><span class="line">    <span class="string">"BR_REPLY"</span>, </span><br><span class="line">    <span class="string">"BR_ACQUIRE_RESULT"</span>, </span><br><span class="line">    <span class="string">"BR_DEAD_REPLY"</span>, </span><br><span class="line">    <span class="string">"BR_TRANSACTION_COMPLETE"</span>, </span><br><span class="line">    <span class="string">"BR_INCREFS"</span>, </span><br><span class="line">    <span class="string">"BR_ACQUIRE"</span>, </span><br><span class="line">    <span class="string">"BR_RELEASE"</span>, </span><br><span class="line">    <span class="string">"BR_DECREFS"</span>, </span><br><span class="line">    <span class="string">"BR_ATTEMPT_ACQUIRE"</span>, </span><br><span class="line">    <span class="string">"BR_NOOP"</span>, </span><br><span class="line">    <span class="string">"BR_SPAWN_LOOPER"</span>, </span><br><span class="line">    <span class="string">"BR_FINISHED"</span>, </span><br><span class="line">    <span class="string">"BR_DEAD_BINDER"</span>, </span><br><span class="line">    <span class="string">"BR_CLEAR_DEATH_NOTIFICATION_DONE"</span>, </span><br><span class="line">    <span class="string">"BR_FAILED_REPLY"</span>, </span><br><span class="line">    <span class="string">"BR_TRANSACTION_SEC_CTX"</span>, </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>处理CMD的函数就是waitForResponse和executeCommand。</p>
<p>前面通过writeTransactionData,已经把数据写入到了binder_transaction_data中。<br>talkWithDriver就是调用ioctl(BINDER_WRITE_READ)完成真正的数据接发</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="keyword">bool</span> doReceive)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> 	<span class="comment">//检查打开的binder设备的fd </span></span><br><span class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> -EBADF; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    binder_write_read bwr; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Is the read buffer empty? </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize(); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//需要写的数据大小，这里的doReceive默认为true，如果上一次的数据还没读完，则不会写入任何内容 </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    bwr.write_size = outAvail; </span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>)mOut.data(); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// This is what we'll read. </span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123; </span><br><span class="line"> 		<span class="comment">//将read_size设置为读缓存可用容量 </span></span><br><span class="line">        bwr.read_size = mIn.dataCapacity(); </span><br><span class="line"> 		<span class="comment">//设置读缓存起始地址 </span></span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>)mIn.data(); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        bwr.read_size = <span class="number">0</span>; </span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// Return immediately if there is nothing to do. </span></span><br><span class="line">     <span class="comment">//没有要读写的数据就直接返回 </span></span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR; </span><br><span class="line"> </span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>; </span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">status_t</span> err; </span><br><span class="line">    <span class="comment">//省略异常处理log </span></span><br><span class="line">    <span class="keyword">if</span> (err &gt;= NO_ERROR) &#123; </span><br><span class="line"> 		<span class="comment">//写数据被消费了 </span></span><br><span class="line">        <span class="keyword">if</span> (bwr.write_consumed &gt; <span class="number">0</span>) &#123; </span><br><span class="line">			 <span class="comment">//写数据没有被消费完 </span></span><br><span class="line">            <span class="keyword">if</span> (bwr.write_consumed &lt; mOut.dataSize()) </span><br><span class="line">                LOG_ALWAYS_FATAL(<span class="string">"Driver did not consume write buffer. "</span> </span><br><span class="line">                                 <span class="string">"err: %s consumed: %zu of %zu"</span>, </span><br><span class="line">                                 statusToString(err).c_str(), </span><br><span class="line">                                 (<span class="keyword">size_t</span>)bwr.write_consumed, </span><br><span class="line">                                 mOut.dataSize()); </span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line"> 				<span class="comment">//写数据消费完了，将数据大小设置为0，这样下次就不会再写数据了 </span></span><br><span class="line">                mOut.setDataSize(<span class="number">0</span>); </span><br><span class="line">                processPostWriteDerefs(); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line"> 		<span class="comment">//读到了数据 </span></span><br><span class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123; </span><br><span class="line">			 <span class="comment">//设置数据大小及数据指针偏移，这样后面就可以从中读取出来数据了 </span></span><br><span class="line">            mIn.setDataSize(bwr.read_consumed); </span><br><span class="line">            mIn.setDataPosition(<span class="number">0</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> NO_ERROR; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> err; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"><i class="fa fa-tag"></i> Android</a>
          
            <a href="/tags/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/" rel="tag"><i class="fa fa-tag"></i> 系统源码</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/16/MSM8953%207.1%E9%A2%84%E8%A3%85%E5%8F%AF%E5%8D%B8%E8%BD%BD%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8/" rel="next" title="MSM8953 7.1预装可卸载第三方应用">
                <i class="fa fa-chevron-left"></i> MSM8953 7.1预装可卸载第三方应用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2023/09/18/FW%20Init%E8%BF%9B%E7%A8%8B%E5%8F%8A%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%80%BB%E7%BB%93/" rel="prev" title="init进程及系统进程启动总结">
                init进程及系统进程启动总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/timg.png"
                alt="WZKingdom" />
            
              <p class="site-author-name" itemprop="name">WZKingdom</p>
              <p class="site-description motion-element" itemprop="description">撸起袖子加油干！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#Binder何时初始化"><span class="nav-number">1.</span> <span class="nav-text">Binder何时初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Binder通信的流程"><span class="nav-number">2.</span> <span class="nav-text">Binder通信的流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#aidl通信的基本步骤"><span class="nav-number">3.</span> <span class="nav-text">aidl通信的基本步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bindService的全流程"><span class="nav-number">4.</span> <span class="nav-text">bindService的全流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java与Native-通信的基本流程"><span class="nav-number">5.</span> <span class="nav-text">Java与Native 通信的基本流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ServcieManager场景"><span class="nav-number">6.</span> <span class="nav-text">ServcieManager场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不同类型的Binder"><span class="nav-number">7.</span> <span class="nav-text">不同类型的Binder</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#IBinder"><span class="nav-number">7.1.</span> <span class="nav-text">IBinder</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BpBinder-BBinder"><span class="nav-number">7.2.</span> <span class="nav-text">BpBinder,BBinder</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JavaBBinder"><span class="nav-number">7.3.</span> <span class="nav-text">JavaBBinder</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ServiceManager-getService方法"><span class="nav-number">8.</span> <span class="nav-text">ServiceManager.getService方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ServiceManager进程-死循环"><span class="nav-number">9.</span> <span class="nav-text">ServiceManager进程 死循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Binder驱动事务处理"><span class="nav-number">10.</span> <span class="nav-text">Binder驱动事务处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IPCThreadState-解析"><span class="nav-number">11.</span> <span class="nav-text">IPCThreadState 解析</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WZKingdom</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">65.9k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/miku.model.json"},"display":{"position":"right","width":100,"height":200},"mobile":{"show":true},"log":false});</script></body>
</html>
