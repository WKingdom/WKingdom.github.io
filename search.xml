<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Activity的启动模式</title>
    <url>/2018/05/02/Activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="LaunchMode"><a href="#LaunchMode" class="headerlink" title="LaunchMode"></a>LaunchMode</h4><p>四种启动模式：standard、singleTop、singleTask、singleInstance</p>
<h5 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h5><p>标准模式，系统默认的启动模式。每次启动一个Activity都会重新创建一个新的实例。在这种模式下，谁启动这个Activity,那么这个Activity就运行在启动它的那个Activity所在的栈中。</p>
<h5 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h5><p>栈顶复用模式，在这种模式下，如果新的Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建，同时它的onNewIntent方法会被回调，通过此方法的参数可以取出当前的请求信息。如果新的Activity实例已存在但不是位于栈顶，那么新的Activity仍然会被重新创建。</p>
<h5 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h5><p>栈内复用模式，在这种模式下，只要Activity在一个栈中存在，那么多次启动此Activity都不会重新创建实例，和singleTop一样，系统也会回调onNewIntent。</p>
<h5 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h5><p>单实例模式，这是一种加强的singleTask模式，具备此模式的Activity只能单独位于一个任务栈中。</p>
<h4 id="TaskAffinity"><a href="#TaskAffinity" class="headerlink" title="TaskAffinity"></a>TaskAffinity</h4><p>这个参数标识一个Activity所需要的任务栈的名字，默认情况下所有Activity所需的任务栈的名字是应用的包名。</p>
<p>TaskAffinity主要和singleTask启动模式或者allowTaskReparenting属性配对使用。</p>
<h4 id="给Activity指定启动模式"><a href="#给Activity指定启动模式" class="headerlink" title="给Activity指定启动模式"></a>给Activity指定启动模式</h4><p>1、通过AndroidMenifest为Activity指定启动模式；</p>
<p>2、通过在Intent中设置标志位。</p>
<p>这两种启动模式第二种的优先级高于第一种，当两种同时存在，以第二种为准；另外，两种方式在限定范围上有所不同，第一种无法直接为Activity设定FLAG_ACTIVITY_CLEAR_TOP标识，第二种不能指定singleInstance模式。</p>
<h4 id="Activity的Flags"><a href="#Activity的Flags" class="headerlink" title="Activity的Flags"></a>Activity的Flags</h4><h5 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a>FLAG_ACTIVITY_NEW_TASK</h5><p>为Activity指定singleTask启动模式，效果和XML中指定该启动模式相同。</p>
<h5 id="FLAG-ACTIVITY-SINGLE-TOP"><a href="#FLAG-ACTIVITY-SINGLE-TOP" class="headerlink" title="FLAG_ACTIVITY_SINGLE_TOP"></a>FLAG_ACTIVITY_SINGLE_TOP</h5><p>为Activity指定singleTop模式</p>
<h5 id="FLAG-ACTIVITY-CLEAR-TOP"><a href="#FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="FLAG_ACTIVITY_CLEAR_TOP"></a>FLAG_ACTIVITY_CLEAR_TOP</h5><p>具有此标记的Activity,当它启动时，在同一任务栈中的所以位于它上面的Activity都要出栈，这种模式一般和FLAG_ACTIVITY_NEW_TASK配合使用。</p>
<h4 id="IntentFilter的匹配规则"><a href="#IntentFilter的匹配规则" class="headerlink" title="IntentFilter的匹配规则"></a>IntentFilter的匹配规则</h4><p>IntentFilter的过滤信息有action、category、data，action的匹配规则只要有一个action成功匹配就可以，category每个都要和过滤规则中的相同。</p>
<p>data由两部分最初，mineType和URI,mineType指媒体类型，如image/jpeg、video/*等，</p>
<p>URI结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;scheme&gt;:&#x2F;&#x2F;&lt;host&gt;:&lt;port&gt;&#x2F;[&lt;path&gt;|[pathPrefix]|[pathPattern]]</span><br></pre></td></tr></table></figure>

<p>过滤规则中没有红的URI时默认content和file,也就是说，虽然没有指定URI,但是Intent的URI部分的scheme必须为content或者file才能匹配。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio安装panltUML</title>
    <url>/2024/07/13/Android%20Studio%E5%AE%89%E8%A3%85panltUML/</url>
    <content><![CDATA[<h3 id="安装panltUML插件"><a href="#安装panltUML插件" class="headerlink" title="安装panltUML插件"></a>安装panltUML插件</h3><p>1.File-&gt;Settings-&gt;Plugins-&gt;Browse repositories<br>2.在搜索框输入plantUML<br>3.导入插件Install plugin<br>如果以上步骤正确的完成，重启AndroidStudio 右键-&gt;new 的时候你会发现多了这么一堆东西，如果出现了这些说明plantUML已经正确的安装了。</p>
<h3 id="安装Graphviz"><a href="#安装Graphviz" class="headerlink" title="安装Graphviz"></a>安装Graphviz</h3><p>设置plantUML<br>1.点击右上角的设置按钮或进入File-&gt;Settings-&gt;Other Settings -&gt;PlantUML<br>2.将文件路径填写为刚刚Graphviz的目录下bin目录中dot.exe文件。<br>(我的为：D:/Program/Graphviz/bin/dot.exe)<br>3.点击OK 刷新一下界面就能看到这个了</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>UML</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>23 种设计模式的分类和功能</title>
    <url>/2020/04/03/23%20%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>设计模式有两种分类方法，即根据模式的<strong>目的和作用的范围</strong>划分</p>
<h3 id="1、根据目的来划分"><a href="#1、根据目的来划分" class="headerlink" title="1、根据目的来划分"></a>1、根据目的来划分</h3><p>根据模式是用来完成什么工作来划分，这种方式可分为<font color="#FF0000"> 创建型模式</font>、<font color="#FF0000">结构型模式</font>和<font color="#FF0000">行为型模式</font>3 种。</p>
<ol>
<li><strong>创建型模式：</strong>用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。其中单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</li>
<li><strong>结构型模式：</strong>用于描述如何将类或对象按某种布局组成更大的结构，其中代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</li>
<li><strong>行为型模式：</strong>用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。其中模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</li>
</ol>
<h3 id="2-根据作用范围来划分"><a href="#2-根据作用范围来划分" class="headerlink" title="2. 根据作用范围来划分"></a>2. 根据作用范围来划分</h3><p>根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。</p>
<ol>
<li><p><strong>类模式：</strong>用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。工厂方法、（类）适配器、模板方法、解释器属于该模式。</p>
</li>
<li><p><strong>对象模式：</strong>用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。除了以上 4 种，其他的都是对象模式。</p>
<h4 id="23-种设计模式的分类表"><a href="#23-种设计模式的分类表" class="headerlink" title="23 种设计模式的分类表"></a>23 种设计模式的分类表</h4></li>
</ol>
<table>
<thead>
<tr>
<th>范围\目的</th>
<th>创建型模式</th>
<th>结构型模式</th>
<th>行为型模式</th>
</tr>
</thead>
<tbody><tr>
<td>类模式</td>
<td>工厂方法</td>
<td>(类）适配器</td>
<td>模板方法、解释器</td>
</tr>
<tr>
<td>对象模式</td>
<td>单例<br/>原型<br/>抽象工厂<br/>建造者</td>
<td>代理<br/>(对象）适配器<br/>桥接<br/>装饰<br/>外观<br/>享元<br/>组合</td>
<td>策略<br/>命令<br/>职责链<br/>状态<br/>观察者<br/>中介者<br/>迭代器<br/>访问者<br/>备忘录</td>
</tr>
</tbody></table>
<h3 id="3-23种设计模式的功能"><a href="#3-23种设计模式的功能" class="headerlink" title="3. 23种设计模式的功能"></a>3. 23种设计模式的功能</h3><p>前面说明了 23 种设计模式的分类，现在对各个模式的功能进行介绍。</p>
<h4 id="1-单例（Singleton）模式"><a href="#1-单例（Singleton）模式" class="headerlink" title="1.  单例（Singleton）模式"></a>1.  <strong>单例（Singleton）模式</strong></h4><p>   某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</p>
<h4 id="2-原型（Prototype）模式"><a href="#2-原型（Prototype）模式" class="headerlink" title="2. 原型（Prototype）模式"></a>2. <strong>原型（Prototype）模式</strong></h4><p>   将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</p>
<h4 id="3-工厂方法（Factory-Method）模式"><a href="#3-工厂方法（Factory-Method）模式" class="headerlink" title="3. 工厂方法（Factory Method）模式"></a>3. <strong>工厂方法（Factory Method）模式</strong></h4><p>   定义一个用于创建产品的接口，由子类决定生产什么产品。</p>
<h4 id="4-抽象工厂（AbstractFactory）模式"><a href="#4-抽象工厂（AbstractFactory）模式" class="headerlink" title="4. 抽象工厂（AbstractFactory）模式"></a>4. <strong>抽象工厂（AbstractFactory）模式</strong></h4><p>   提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</p>
<h4 id="5-建造者（Builder）模式"><a href="#5-建造者（Builder）模式" class="headerlink" title="5. 建造者（Builder）模式"></a>5. <strong>建造者（Builder）模式</strong></h4><p>   将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</p>
<h4 id="6-代理（Proxy）模式"><a href="#6-代理（Proxy）模式" class="headerlink" title="6. 代理（Proxy）模式"></a>6. <strong>代理（Proxy）模式</strong></h4><p>   为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</p>
<h4 id="7-适配器（Adapter）模式"><a href="#7-适配器（Adapter）模式" class="headerlink" title="7. 适配器（Adapter）模式"></a>7. <strong>适配器（Adapter）模式</strong></h4><p>   将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>
<h4 id="8-桥接（Bridge）模式"><a href="#8-桥接（Bridge）模式" class="headerlink" title="8. 桥接（Bridge）模式"></a>8. <strong>桥接（Bridge）模式</strong></h4><p>   将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<h4 id="9-装饰（Decorator）模式"><a href="#9-装饰（Decorator）模式" class="headerlink" title="9. 装饰（Decorator）模式"></a>9. <strong>装饰（Decorator）模式</strong></h4><p>动态的给对象增加一些职责，即增加其额外的功能。</p>
<h4 id="10-外观（Facade）模式"><a href="#10-外观（Facade）模式" class="headerlink" title="10. 外观（Facade）模式"></a>10. <strong>外观（Facade）模式</strong></h4><p>为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</p>
<h4 id="11-享元（Flyweight）模式"><a href="#11-享元（Flyweight）模式" class="headerlink" title="11. 享元（Flyweight）模式"></a>11. <strong>享元（Flyweight）模式</strong></h4><p>运用共享技术来有效地支持大量细粒度对象的复用。</p>
<h4 id="12-组合（Composite）模式"><a href="#12-组合（Composite）模式" class="headerlink" title="12. 组合（Composite）模式"></a>12. <strong>组合（Composite）模式</strong></h4><p>将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</p>
<h4 id="13-模板方法（TemplateMethod）模式"><a href="#13-模板方法（TemplateMethod）模式" class="headerlink" title="13. 模板方法（TemplateMethod）模式"></a>13. <strong>模板方法（TemplateMethod）模式</strong></h4><p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p>
<h4 id="14-策略（Strategy）模式"><a href="#14-策略（Strategy）模式" class="headerlink" title="14. 策略（Strategy）模式"></a>14. <strong>策略（Strategy）模式</strong></h4><p>定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</p>
<h4 id="15-命令（Command）模式"><a href="#15-命令（Command）模式" class="headerlink" title="15. 命令（Command）模式"></a>15. <strong>命令（Command）模式</strong></h4><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</p>
<h4 id="16-职责链（Chain-of-Responsibility）模式"><a href="#16-职责链（Chain-of-Responsibility）模式" class="headerlink" title="16. 职责链（Chain of Responsibility）模式"></a>16. <strong>职责链（Chain of Responsibility）模式</strong></h4><p>把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</p>
<h4 id="17-状态（State）模式"><a href="#17-状态（State）模式" class="headerlink" title="17. 状态（State）模式"></a>17. <strong>状态（State）模式</strong></h4><p>允许一个对象在其内部状态发生改变时改变其行为能力。</p>
<h4 id="18-观察者（Observer）模式"><a href="#18-观察者（Observer）模式" class="headerlink" title="18. 观察者（Observer）模式"></a>18. <strong>观察者（Observer）模式</strong></h4><p>多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</p>
<h4 id="19-中介者（Mediator）模式"><a href="#19-中介者（Mediator）模式" class="headerlink" title="19. 中介者（Mediator）模式"></a>19. <strong>中介者（Mediator）模式</strong></h4><p>定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</p>
<h4 id="20-迭代器（Iterator）模式"><a href="#20-迭代器（Iterator）模式" class="headerlink" title="20. 迭代器（Iterator）模式"></a>20. <strong>迭代器（Iterator）模式</strong></h4><p>提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p>
<h4 id="21-访问者（Visitor）模式"><a href="#21-访问者（Visitor）模式" class="headerlink" title="21. 访问者（Visitor）模式"></a>21. <strong>访问者（Visitor）模式</strong></h4><p>在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</p>
<h4 id="22-备忘录（Memento）模式"><a href="#22-备忘录（Memento）模式" class="headerlink" title="22. 备忘录（Memento）模式"></a>22. <strong>备忘录（Memento）模式</strong></h4><p>在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</p>
<h4 id="23-解释器（Interpreter）模式"><a href="#23-解释器（Interpreter）模式" class="headerlink" title="23. 解释器（Interpreter）模式"></a>23. <strong>解释器（Interpreter）模式</strong></h4><p>提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Android.mk打包apk</title>
    <url>/2020/03/18/Android.mk%E6%89%93%E5%8C%85apk/</url>
    <content><![CDATA[<p>一、新建Android.mk文件 放在app/src/main 目录下</p>
<p>二、代码中引用的第三方库通过aar包存放在最外层libs目录下，所有app共享这些库文件。</p>
<p>如何有自己用的第三方开源库，<a href="https://www.jianshu.com/p/59efa895589e" target="_blank" rel="noopener">查找aar的方法</a> </p>
<p>电脑上rxandroid aar的目录：<br>C:\Users\Lenovo.gradle\caches\modules-2\files-2.1\io.reactivex\rxandroid（各个电脑目录不同）</p>
<p>Android.mk编写规则<br>（系统设置例子）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#代表mk当前文档路径</span><br><span class="line">LOCAL_PATH :&#x3D; $(call my-dir) </span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_PACKAGE_NAME :&#x3D; HQ_DevSet</span><br><span class="line"></span><br><span class="line">#指该模块在所有版本下都编译</span><br><span class="line">LOCAL_MODULE_TAGS :&#x3D; optional</span><br><span class="line"></span><br><span class="line">#混淆配置</span><br><span class="line">LOCAL_PROGUARD_ENABLED :&#x3D; full obfuscation</span><br><span class="line">LOCAL_PROGUARD_FLAG_FILES :&#x3D; ..&#x2F;..&#x2F;proguard-rules.pro</span><br><span class="line"></span><br><span class="line">#设置不打odex包</span><br><span class="line">LOCAL_DEX_PREOPT :&#x3D; false</span><br><span class="line">DONT_DEXPREOPT_PREBUILTS :&#x3D; true  </span><br><span class="line"></span><br><span class="line">#apk路径</span><br><span class="line">LOCAL_MODULE_PATH :&#x3D; $(TARGET_OUT)&#x2F;app</span><br><span class="line"></span><br><span class="line">#签名配置</span><br><span class="line">LOCAL_CERTIFICATE :&#x3D; platform</span><br><span class="line"></span><br><span class="line">LOCAL_MULTILIB :&#x3D; 32</span><br><span class="line"></span><br><span class="line">#源码文件</span><br><span class="line">#引用当前app的资源</span><br><span class="line">LOCAL_RESOURCE_DIR +&#x3D; $(LOCAL_PATH)&#x2F;res</span><br><span class="line"></span><br><span class="line">#声明当前app的代码目录</span><br><span class="line">src_dirs :&#x3D; java&#x2F;</span><br><span class="line"></span><br><span class="line">#引用当前app的代码</span><br><span class="line">LOCAL_SRC_FILES :&#x3D; $(call all-java-files-under, $(src_dirs))</span><br><span class="line"></span><br><span class="line">#添加aidl源码文件</span><br><span class="line">LOCAL_SRC_FILES +&#x3D; \</span><br><span class="line">src&#x2F;xx&#x2F;xx&#x2F;xx&#x2F;XxxOne.aidl \</span><br><span class="line">src&#x2F;xx&#x2F;xx&#x2F;xx&#x2F;XxxTwo.aidl</span><br><span class="line"></span><br><span class="line"># jar包</span><br><span class="line">#声明多个 jar 包的位置   ----其中\代表换行，后面不能跟任何字符，后面的一样</span><br><span class="line">LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES :&#x3D; \</span><br><span class="line"> hqlib:..&#x2F;..&#x2F;..&#x2F;libs&#x2F;hqlib.jar \</span><br><span class="line"> hqapi:..&#x2F;..&#x2F;..&#x2F;libs&#x2F;hqapi.jar \</span><br><span class="line"> hqapi_sq:..&#x2F;..&#x2F;..&#x2F;libs&#x2F;hqapi_sq.jar\</span><br><span class="line"> rxjava:..&#x2F;..&#x2F;..&#x2F;libs&#x2F;rxjava-1.3.7.jar</span><br><span class="line">																			</span><br><span class="line">#引用我们声明的多个 jar 包的变量</span><br><span class="line">LOCAL_STATIC_JAVA_LIBRARIES +&#x3D;  hqlib \</span><br><span class="line">                                hqapi \</span><br><span class="line">                                hqapi_sq \</span><br><span class="line">                                rxjava \</span><br><span class="line">                                android-support-v4</span><br><span class="line">#aar包</span><br><span class="line">#声明aar包</span><br><span class="line">LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES +&#x3D; PublicTitle2:..&#x2F;..&#x2F;..&#x2F;libs&#x2F;PublicTitle2.aar\</span><br><span class="line">rxandroid:..&#x2F;..&#x2F;..&#x2F;libs&#x2F;rxandroid-1.2.1.aar</span><br><span class="line"></span><br><span class="line">#引用aar包</span><br><span class="line">LOCAL_STATIC_JAVA_AAR_LIBRARIES +&#x3D; PublicTitle2 \</span><br><span class="line">								 Rxandroid</span><br><span class="line"></span><br><span class="line">#引入使用的资源 添加包名</span><br><span class="line">LOCAL_AAPT_FLAGS +&#x3D; --auto-add-overlay \</span><br><span class="line">					--extra-packages com.hopechart.sq.publictitle \</span><br><span class="line">					--extra-packages rx.android </span><br><span class="line"></span><br><span class="line">#设置version版本</span><br><span class="line">#设置版本号和名字，如果不写会默认使用系统api的版本号25 --7.1.1</span><br><span class="line">version_code &#x3D; 24</span><br><span class="line">version_name :&#x3D; 4.0.0.1</span><br><span class="line">						</span><br><span class="line">LOCAL_AAPT_FLAGS +&#x3D; --version-code $(version_code)</span><br><span class="line">LOCAL_AAPT_FLAGS +&#x3D; --version-name $(version_name)    </span><br><span class="line"></span><br><span class="line">#打出来的minSDK和targetSDK version都是19 </span><br><span class="line">LOCAL_SDK_VERSION :&#x3D; 19  </span><br><span class="line">#如果有特殊情况可在清单文件中添加</span><br><span class="line"># 【</span><br><span class="line">#  AndroidManifest.xml清单文件添加sdk版本，优先使用清单文件中</span><br><span class="line"># 的版本号</span><br><span class="line">#  &lt;uses-sdk android:minSdkVersion&#x3D;&quot;19&quot;</span><br><span class="line">#         android:targetSdkVersion&#x3D;&quot;25&quot;&#x2F;&gt;</span><br><span class="line"># 】</span><br><span class="line"></span><br><span class="line">#打apk包</span><br><span class="line">include $(BUILD_PACKAGE)</span><br><span class="line"></span><br><span class="line">#调用子目录的mk文件</span><br><span class="line">include $(call all-makefiles-under,$(LOCAL_PATH))</span><br></pre></td></tr></table></figure>


<p>#Android.mk END</p>
<p>#如果使用的系统的包，需要引入他们使用的资源文件，否则会提示编译资源找不到的错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#RecyclerView例子</span><br><span class="line">LOCAL_RESOURCE_DIR +&#x3D; frameworks&#x2F;support&#x2F;v7&#x2F;recyclerview&#x2F;res</span><br><span class="line">LOCAL_STATIC_JAVA_LIBRARIES +&#x3D; android-support-v7-recyclerview</span><br><span class="line">LOCAL_AAPT_FLAGS +&#x3D; --auto-add-overlay \</span><br><span class="line">--extra-packages android.support.v7.recyclerview</span><br></pre></td></tr></table></figure>

<p>代码编译<br>1、在源码任意目录下创建一个目录，把改好的代码上传到该目录；<br>2、切换到源码顶层目录，执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source build&#x2F;envsetup.sh;</span><br></pre></td></tr></table></figure>

<p>3、编译单个apk , 执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mmm  [apk mk文件的目录]</span><br></pre></td></tr></table></figure>

<p>需要在全编的情况下才能单独编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make -j32</span><br></pre></td></tr></table></figure>
<p>编译所有的模块编译所有的模块需要在每个模块的父级目录添加Android.mk文件</p>
<p>内容【</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOCAL_PATH :&#x3D; $(call my-dir)</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">include $(call all-makefiles-under,$(LOCAL_PATH))</span><br></pre></td></tr></table></figure>

<p>】<br>这样就可以执行子目录中的Android.mk文件。<br>如下目录执行的命令就是: mmm 代码目录/SQ10Inch,然后就可以在输出目录看到所有打包出来的apk文件。</p>
<p>参考链接：<br><a href="https://blog.csdn.net/jsn_ze/article/details/72790401" target="_blank" rel="noopener">Android源码编译第三方app如何写Android.mk</a><br><a href="https://www.jianshu.com/p/e19e0d3bf13a" target="_blank" rel="noopener">Android.mk引用jar包、so库、aar包系统签名</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>打包编译</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>打包编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Android下拉状态栏快捷开关的添加</title>
    <url>/2020/03/18/Android%E4%B8%8B%E6%8B%89%E7%8A%B6%E6%80%81%E6%A0%8F%E5%BF%AB%E6%8D%B7%E5%BC%80%E5%85%B3%E7%9A%84%E6%B7%BB%E5%8A%A0/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/lyjit/article/details/51579067" target="_blank" rel="noopener">下拉通知栏快捷开关的添加</a>  </p>
<h3 id="一：快捷开关功能以及开关状态的实现"><a href="#一：快捷开关功能以及开关状态的实现" class="headerlink" title="一：快捷开关功能以及开关状态的实现"></a>一：快捷开关功能以及开关状态的实现</h3><h4 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h4><p>首先看一下原生的下拉菜单按键的布局在哪里。打开这个路径的文件：frameworks/base/packages/SystemUI/res/values/config.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;string name&#x3D;&quot;quick_settings_tiles_default&quot; translatable&#x3D;&quot;false&quot;&gt;</span><br><span class="line">   wifi,bt,inversion,cell,airplane,rotation,flashlight,settings,dataconnection,location,screenshot,cast,hotspot,hotknot,audioprofile</span><br><span class="line">&lt;&#x2F;string&gt;</span><br></pre></td></tr></table></figure>

<p>对！自适应的布局，这些快捷按键的定义都在这里。要是想换成自己定义的按键开关，只要在这里替换就行，但这只是第一步。<br>我这里暂且换成自己定义的布局：wifi,蓝牙,无线麦克,FM</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;string name&#x3D;&quot;quick_settings_tiles_default&quot; translatable&#x3D;&quot;false&quot;&gt;</span><br><span class="line">        wifi,bluetooth,wirelessmic,fm</span><br><span class="line">&lt;&#x2F;string&gt;</span><br></pre></td></tr></table></figure>

<h4 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h4><p>在config.xml文件中定义我们想要的开关名称之后，还需要打开如下路径来添加相关的内容：<br>frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/QSTileHost.java<br>在如下方法里面添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 获取到预定义好的各快捷图标的QSTile</span><br><span class="line">     * *&#x2F;</span><br><span class="line">    private QSTile&lt;?&gt; createTile(String tileSpec) &#123;</span><br><span class="line">        IQuickSettingsPlugin quickSettingsPlugin &#x3D; PluginFactory</span><br><span class="line">                .getQuickSettingsPlugin(mContext);</span><br><span class="line">        if (tileSpec.equals(&quot;wifi&quot;)) return new WifiTile(this);</span><br><span class="line">        &#x2F;&#x2F;add by lyj</span><br><span class="line">        else if (tileSpec.equals(&quot;bluetooth&quot;)) return new CallBluetoothTile(this);</span><br><span class="line">        else if (tileSpec.equals(&quot;wirelessmic&quot;)) return new WirelessMicTile(this);</span><br><span class="line">        else if (tileSpec.equals(&quot;fm&quot;)) return new FMTile(this); &#x2F;&#x2F;要添加的FM</span><br><span class="line"> </span><br><span class="line">        ......</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是获取到预定义好的各个快捷图标的QSTile。其中FMTile文件是什么的，接着往下看</p>
<h4 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h4><p>这一步很重要，首先看一下这个路径：frameworks/base/packages/SystemUI/src/com/android/systemui/qs/tiles<br>这个路径下面就是你定义的开关实现功能的地方，这里新添加的FM在原有的快捷开关里面是没有的，所以要在这里新添加一个文件，咱们这里暂且起名为FMTile.java，也就是之前所说的FMTile文件。<br>新建好类之后要继承 QSTile&lt;QSTile.BooleanState&gt;<br>这样会生成一些方法，下面就来看一下这个文件各个方法的作用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FMTile extends QSTile&lt;QSTile.BooleanState&gt;&#123;</span><br><span class="line">	</span><br><span class="line">	public FMTile(com.android.systemui.qs.QSTile.Host host) &#123;</span><br><span class="line">		super(host);</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated constructor stub</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	@Override</span><br><span class="line">	public void setListening(boolean listening) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	@Override</span><br><span class="line">	protected com.android.systemui.qs.QSTile.BooleanState newTileState() &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">		return new BooleanState();</span><br><span class="line">	&#125;</span><br><span class="line">	public void setFmModeUpdate()&#123;</span><br><span class="line">		handleRefreshState(null);</span><br><span class="line">        &#125;</span><br><span class="line">	@Override</span><br><span class="line">       protected String getQSTileViewMarkBit()&#123;</span><br><span class="line">	 	return &quot;fm&quot; ;</span><br><span class="line">	 &#125;</span><br><span class="line"> </span><br><span class="line">	 @Override</span><br><span class="line">	protected void handleClick() &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">                &#x2F;&#x2F;开关默认关闭</span><br><span class="line">                int mState &#x3D; Settings.System.getInt(mContext.getContentResolver(), Settings.System.FM_SYSTEMUI, 1);</span><br><span class="line">		boolean mCloseState &#x3D; (mState &#x3D;&#x3D; 0);</span><br><span class="line">		Settings.System.putInt(mContext.getContentResolver(),Settings.System.FM_SYSTEMUI, mCloseState ? 1 : 0);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	@Override</span><br><span class="line">	protected void handleUpdateState(</span><br><span class="line">			com.android.systemui.qs.QSTile.BooleanState state, Object arg) &#123;</span><br><span class="line">		</span><br><span class="line">		int mState &#x3D; Settings.System.getInt(mContext.getContentResolver(), Settings.System.FM_SYSTEMUI, 1);</span><br><span class="line">		boolean mCloseState &#x3D; (mState &#x3D;&#x3D; 0);</span><br><span class="line">		state.visible &#x3D; true ;</span><br><span class="line">		state.label &#x3D; mContext.getString(R.string.quick_settings_fm_title);</span><br><span class="line">		state.icon &#x3D; ResourceIcon.get(mCloseState ? R.drawable.ic_settings_fm_on : R.drawable.ic_settings_fm_off);&#x2F;&#x2F;图片状态</span><br><span class="line">		if(mCloseState)&#123;&#x2F;&#x2F;open</span><br><span class="line">			&#x2F;&#x2F;开关打开相关功能的操作</span><br><span class="line">			</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			&#x2F;&#x2F;开关关闭相关功能的操作</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中Settings.System.FM_SYSTEMUI 是我们在settingProvader中定义的值，主要是控制与外界开关同步的问题，这个我们后面会有详细的介绍，这些方法中最重要的是handleClick()和handleUpdateState(…),每次点击开关会先走handleclick()方法，然后去刷新页面，刷新页面的处理就是在handleUpdateState(..)中处理。<br>这个方法里面有图片状态的改变，以及功能的实现。这个时候开关默认的是关闭，要是默认打开的话只要在两个方法中把mstate = Settings.System.getInt(*, *, 1);  把1改为0即可。<br>这里还要注意的方法首先是FMTile(..)这个方法是初始化用的，也就是开机之后只走一次，也就相当我Activity里面的Oncreate()方法,如果你有什么要初始化的东西可以在这里面定义。还有特别注意的两个方法setFmModeUpdate()和getQSTileViewMarkBit()。这两个方法不是文件自动生成的，需要你手动添加，那么这两个方法有什么作用呢，其实这两个方法也很重要，要是没有这两个方法的话点击开关是没有作用的，也就是没有起到刷新页面的作用，那这两个方法在那实现的呢，来接着看下面的解释：</p>
<h4 id="第四步："><a href="#第四步：" class="headerlink" title="第四步："></a>第四步：</h4><p>结合第三步最后的疑问我们来看一下这个文件：frameworks/base/packages/SystemUI/src/com/android/systemui/qs/QSTile.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected QSTile(Host host) &#123;</span><br><span class="line">        mHost &#x3D; host;</span><br><span class="line">        mContext &#x3D; host.getContext();</span><br><span class="line">        mHandler &#x3D; new H(host.getLooper());</span><br><span class="line">        setChangeObserver();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setChangeObserver()&#123; &#x2F;&#x2F;实时监听状态的变化</span><br><span class="line">    	mContext.getContentResolver().registerContentObserver(</span><br><span class="line">                Settings.System.getUriFor(Settings.System.FM_SYSTEMUI),</span><br><span class="line">                true, mFmModeChangeObserver);</span><br><span class="line">	.....</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">    private ContentObserver mFmModeChangeObserver &#x3D; new ContentObserver(new Handler()) &#123;</span><br><span class="line">		@Override</span><br><span class="line">		public void onChange(boolean selfChange) &#123;</span><br><span class="line">			setFmModeUpdate();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">    public void setFmModeUpdate()&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<pre><code>这些添加之后你的开关状态就能其作用了，但到这里如果你编译工程的时候会发现编译报错，如下图：</code></pre><p>这是怎么回事呢，这是因为你添加的FMTile.java文件里面的方法是从一个超类型实现的。</p>
<p>这个时候你还需有在QSTile.java文件中添加getQSTileViewMarkBit()方法，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span><br><span class="line">    protected QSTileView mQSTileView ;</span><br><span class="line">    public QSTileView createTileView(Context context) &#123;</span><br><span class="line">    	</span><br><span class="line">    	mQSTileView &#x3D; new QSTileView(context) ;</span><br><span class="line">    	mQSTileView.setMarkBit(getQSTileViewMarkBit());&#x2F;&#x2F;add </span><br><span class="line">    	Log.i(&quot;lyj_create&quot;, &quot;mQSTileView &#x3D; &quot;+mQSTileView);</span><br><span class="line">        return mQSTileView;</span><br><span class="line">    &#125;</span><br><span class="line">    protected String getQSTileViewMarkBit()&#123;</span><br><span class="line">		return null ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>到这里FM开关的添加就结束了。同样的方法添加其它快捷按键开关原理都是一样的。</p>
<h3 id="二：下拉FM开关与外界开关同步"><a href="#二：下拉FM开关与外界开关同步" class="headerlink" title="二：下拉FM开关与外界开关同步"></a>二：下拉FM开关与外界开关同步</h3><p>   其实刚才我们已经有所了解了，主要就是Settings值的作用，但这里面还涉及到一个重要的知识点，先不着急，我们先打开FM的应用代码，看怎么实现同步更新：</p>
<p>   首先在你应用里面控制开关的地方加上Settings.System.putInt(MainActivity.this.getContentResolver(), Settings.System.FM_SYSTEMUI, 0);  //0代表打开 关闭的时候调用Settings.System.putInt(MainActivity.this.getContentResolver(), Settings.System.FM_SYSTEMUI, 1);  //1代表关闭</p>
<p>   关键的代码来了：也就是我们之前说的实现同步更新的 ContentObserver 内容观察者</p>
<p>首先看一下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void registerContentObserver() &#123;</span><br><span class="line">		this.getContentResolver().registerContentObserver(</span><br><span class="line">				Settings.System.getUriFor(Settings.System.FM_SYSTEMU), true, mFmcContentObserver);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	private void unregisterContentObserver() &#123;</span><br><span class="line">		this.getContentResolver().unregisterContentObserver(mFmcContentObserver);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	private ContentObserver mFmcContentObserver&#x3D;new ContentObserver(new Handler()) &#123;</span><br><span class="line"> </span><br><span class="line">		@Override</span><br><span class="line">		public void onChange(boolean selfChange) &#123;</span><br><span class="line">			int mState &#x3D; Settings.System.getInt(getActivity().getContentResolver(), Settings.System.FM_SYSTEMU, 0);</span><br><span class="line">			boolean mCloseState &#x3D; (mState &#x3D;&#x3D; 0);</span><br><span class="line">			if(mCloseState)&#123;&#x2F;&#x2F;打开的相关操作</span><br><span class="line">				mSwitchPreference.setChecked(true);</span><br><span class="line">				Log.i(&quot;lyj_wire&quot;,&quot;mikeState: &#x3D; &quot;+mikeState);</span><br><span class="line">			&#125;else&#123;&#x2F;&#x2F;关闭的相关操作</span><br><span class="line">				mSwitchPreference.setChecked(false);</span><br><span class="line">				Log.i(&quot;lyj_wire&quot;,&quot;11mikeState:&quot;+mikeState);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p>在onChange方法里面主要是观察Settings值的变化，然后根据值的变化控制你应用的开关。我们定义的这个值在状态栏快捷开关里面也有所控制，这个刚才已经介绍。那么这个时候你会问，我们在应用里面添加观察者可是没有在下拉状态栏里添加，这样能同步吗？其实SystemUi里面已经添加过了,你只需要在你的应用里添加内容观察者即可。注意在初始化的地方要注册registerContentObserver() ，在退出的时候调用unregisterContentObserver()方法即可。这样以来就能实现应用开关和状态栏下拉快捷开关的同步。<br>这里还涉及到一个知识点：就是打开开关，不管是在你的应用里还是在状态栏快捷开关里，打开FM后在状态栏顶部需要有一个图标显示你打开了FM，关闭时图片消失。这个功能的实现我会在后续的文章中介绍。这里就不做说明了。</p>
<p>  相信看到这里你会对SystemUi状态栏的开发有新的帮助。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Android消息机制</title>
    <url>/2020/10/04/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="Handler-MessageQueue-Runnable和Looper"><a href="#Handler-MessageQueue-Runnable和Looper" class="headerlink" title="Handler,MessageQueue,Runnable和Looper"></a>Handler,MessageQueue,Runnable和Looper</h3><p>描述：Looper不断的从MessageQueue中获取一个Message，然后由Handler来处理。</p>
<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><ul>
<li>每个Thread只对应一个Looper;</li>
<li>每个Looper只对应一个MessageQueue;</li>
<li>每个MessageQueue中有N个Message;</li>
<li>每个Mesaage最多指定一个Handler来处理事件。</li>
</ul>
<p>可以推出Thread和Handler是一对多关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper mLooper; </span><br><span class="line">    <span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line">    <span class="keyword">final</span> Callback mCallback;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> mAsynchronous;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Handle system messages here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Looper从MessageQueue中取出一个Message后，首先会调用Handler.dispatchMessage进行消息派发，由上面方法可以看出有三种处理情况，</p>
<p>1、Message是通过Runnable发送的，这个Runnable会封装成Message赋值给Message的CallBack，分发消息的时候会先执行这个Runnable;</p>
<p>2、如何Handle以Handler(Callback callback，)这种带有 Callback 的参数初始化会执行这个实现里的handleMessage方法；</p>
<p>最后才执行handle里的handleMessage方法。</p>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          delayMillis = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>延迟多长时间发送，内部通过当前时间+延时时长计算出具体的时间点，然后发送到消息队列。</p>
<p>具体发送到消息队列的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">              IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                      msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">              Log.w(TAG, e.getMessage(), e);</span><br><span class="line">              msg.recycle();</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          msg.markInUse();</span><br><span class="line">          msg.when = when;</span><br><span class="line">          Message p = mMessages;</span><br><span class="line">          <span class="keyword">boolean</span> needWake;</span><br><span class="line">          <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">              <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">              msg.next = p;</span><br><span class="line">              mMessages = msg;</span><br><span class="line">              needWake = mBlocked;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">              <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">              <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">              needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">              Message prev;</span><br><span class="line">              <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                  prev = p;</span><br><span class="line">                  p = p.next;</span><br><span class="line">                  <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                      needWake = <span class="keyword">false</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">              prev.next = msg;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">          <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">              nativeWake(mPtr);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>由上面的方法可以看出，消息队列并不是队列，而是单链表结构。</p>
<h3 id="Looper死循环为什么不会导致应用卡死，会耗费大量资源吗？"><a href="#Looper死循环为什么不会导致应用卡死，会耗费大量资源吗？" class="headerlink" title="Looper死循环为什么不会导致应用卡死，会耗费大量资源吗？"></a>Looper死循环为什么不会导致应用卡死，会耗费大量资源吗？</h3><p>从前面的主线程、子线程的分析可以看出，Looper会在线程中不断的检索消息，如果是子线程的Looper死循环，一旦任务完成，用户应该手动退出，而不是让其一直休眠等待。（引用自Gityuan）线程其实就是一段可执行的代码，当可执行的代码执行完成后，线程的生命周期便该终止了，线程退出。而对于主线程，我们是绝不希望会被运行一段时间，自己就退出，那么如何保证能一直存活呢？简单做法就是可执行代码是能一直执行下去的，死循环便能保证不会被退出，例如，binder 线程也是采用死循环的方法，通过循环方式不同与 Binder 驱动进行读写操作，当然并非简单地死循环，无消息时会休眠。<strong>Android是基于消息处理机制的，用户的行为都在这个Looper循环中，我们在休眠时点击屏幕，便唤醒主线程继续进行工作</strong>。</p>
<p>主线程的死循环一直运行是不是特别消耗 CPU 资源呢？ 其实不然，这里就涉及到 Linux  pipe/epoll机制，简单说就是在主线程的 MessageQueue 没有消息时，便阻塞在 loop 的 queue.next() 中的 nativePollOnce() 方法里，此时主线程会释放 CPU 资源进入休眠状态，直到下个消息到达或者有事务发生，通过往 pipe 管道写端写入数据来唤醒主线程工作。这里采用的 epoll 机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。</p>
<h4 id="epoll机制"><a href="#epoll机制" class="headerlink" title="epoll机制"></a>epoll机制</h4><p>epoll机制在Handler中的应用，在主线程的 MessageQueue 没有消息时，便阻塞在 loop 的 queue.next() 中的 nativePollOnce() 方法里，最终调用到epoll_wait()进行阻塞等待。此时主线程会释放 CPU 资源进入休眠状态，直到下个消息到达或者有事务发生，通过往 pipe 管道写端写入数据来唤醒主线程工作。这里采用的 epoll 机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</span><br><span class="line">    <span class="comment">// sThreadLocal.get() will return null unless you've called prepare().</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal可以实现Looper在线程中的存取，Handler在初始化的时候通过Looper回去Looper中的消息队列。如果不使用，那么系统就必须提供一个全局的哈希表供Handlder查询指定线程的Looper。</p>
<h3 id="Handler的同步屏障机制"><a href="#Handler的同步屏障机制" class="headerlink" title="Handler的同步屏障机制"></a>Handler的同步屏障机制</h3><p>如果有一个紧急的Message需要优先处理，该怎么做？这其实涉及到架构方面的设计了，通用场景和特殊场景的设计。你可能会想到<code>sendMessageAtFrontOfQueue()</code>这个方法，实际也远远不只是如此，<strong>Handler中加入了同步屏障这种机制，来实现[异步消息优先]执行的功能</strong>。</p>
<p>postSyncBarrier()发送同步屏障，removeSyncBarrier()移除同步屏障</p>
<p>同步屏障的作用可以理解成拦截同步消息的执行，主线程的 Looper 会一直循环调用 MessageQueue 的 <code>next()</code> 来取出队头的 Message 执行，当 Message 执行完后再去取下一个。当 <code>next()</code> 方法在取 Message 时发现队头是一个同步屏障的消息时，就会去遍历整个队列，只寻找设置了异步标志的消息，如果有找到异步消息，那么就取出这个异步消息来执行，否则就让 <code>next()</code> 方法陷入阻塞状态。如果 <code>next()</code> 方法陷入阻塞状态，那么主线程此时就是处于空闲状态的，也就是没在干任何事。所以，如果队头是一个同步屏障的消息的话，那么在它后面的所有同步消息就都被拦截住了，直到这个同步屏障消息被移除出队列，否则主线程就一直不会去处理同步屏幕后面的同步消息。</p>
<p>而所有消息默认都是同步消息，只有手动设置了异步标志，这个消息才会是异步消息。另外，同步屏障消息只能由内部来发送，这个接口并没有公开给我们使用。</p>
<p>Choreographer 里所有跟 message 有关的代码，你会发现，<strong>都手动设置了异步消息的标志</strong>，所以这些操作是不受到同步屏障影响的。这样做的原因可能就是为了尽可能保证上层 app 在接收到屏幕刷新信号时，可以在第一时间执行遍历绘制 View 树的工作。</p>
<p>Choreographer 过程中的动作也都是异步消息，这样可以确保 Choreographer 的顺利运转，也确保了第一时间执行 doTraversal（doTraversal → performTraversals 就是执行 view 的 layout、measure、draw），这个过程中如果有其他同步消息，也无法得到处理，都要等到 doTraversal 之后。</p>
<p>因为主线程中如果有太多消息要执行，而这些消息又是根据时间戳进行排序，如果不加一个同步屏障的话，那么遍历绘制 View 树的工作就可能被迫延迟执行，因为它也需要排队，那么就有可能出现当一帧都快结束的时候才开始计算屏幕数据，那即使这次的计算少于 16.6ms，也同样会造成丢帧现象。</p>
<p>那么，<strong>有了同步屏障消息的控制就能保证每次一接收到屏幕刷新信号就第一时间处理遍历绘制 View 树的工作么？</strong></p>
<p>只能说，同步屏障是尽可能去做到，但并不能保证一定可以第一时间处理。因为，同步屏障是在 <code>scheduleTraversals()</code> 被调用时才发送到消息队列里的，也就是说，只有当某个 View 发起了刷新请求时，在这个时刻后面的同步消息才会被拦截掉。如果在 <code>scheduleTraversals()</code> 之前就发送到消息队列里的工作仍然会按顺序依次被取出来执行。</p>
<p><a href="https://juejin.cn/post/6893791473121280013" target="_blank" rel="noopener">https://juejin.cn/post/6893791473121280013</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统源码</tag>
      </tags>
  </entry>
  <entry>
    <title>GC回收机制与分代回收策略</title>
    <url>/2020/04/04/GC%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>堆和方法区考虑回收的问题，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的就是这部分内存。</p>
<h4 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h4><p>所谓垃圾就是内存中已经没有用的对象。 既然是”垃圾回收”，那就必须知道哪些对象是垃圾。Java 虚拟机中使用一种叫作”<strong>可达性分析</strong>”的算法来决定对象是否可以被回收。<strong>可达性分析</strong>通过一组名为”GC Root”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，最后通过判断对象的引用链是否可达来决定对象是否可以被回收。</p>
<h4 id="GCRoot对象"><a href="#GCRoot对象" class="headerlink" title="GCRoot对象"></a>GCRoot对象</h4><p>在Java中，有以下几种对象可以作为GCRoot：</p>
<ol>
<li>Java虚拟机栈（局部变量表）中的引用的对象;</li>
<li>方法区中静态引用指向的对象;</li>
<li>仍处于存活状态中的线程对象;</li>
<li>Native 方法中 JNI 引用的对象。</li>
</ol>
<h4 id="什么时候回收"><a href="#什么时候回收" class="headerlink" title="什么时候回收"></a>什么时候回收</h4><p>不同的虚拟机实现有着不同的GC实现机制，但是一般情况下每一种GC实现都会在以下两种情况下触发垃圾回收。</p>
<ol>
<li><p>AllocationFailure：在堆内存中分配时，如果因为可用剩余空间不足导致对象内存分配失败，这时系统会触发一次GC。</p>
</li>
<li><p>System.gc()：在应用层，Java 开发工程师可以主动调用此 API 来请求一次 GC。</p>
<h4 id="JVM分代回收策略"><a href="#JVM分代回收策略" class="headerlink" title="JVM分代回收策略"></a>JVM分代回收策略</h4><p>Java虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为<strong>新生代、老年代</strong>，这就是JVM的内存分代策略。<strong>注意:在HotSpot中除了新生代和老年代，还有永久代</strong>。</p>
<p>分代回收的中心思想就是：对于新创建的对象会在新生代中分配内存，此区域的对象生命周期一般较短。如果经过多次回收仍然存活下来，则将它们转移到老年代中。</p>
<h5 id="年轻代（YoungGeneration）"><a href="#年轻代（YoungGeneration）" class="headerlink" title="年轻代（YoungGeneration）"></a>年轻代（YoungGeneration）</h5><p>新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低，在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，回收效率很高。新生代中因为要进行一些复制操作，所以一般采用的 GC 回收算法是复制算法。</p>
<p>新生代又可以继续细分为 3 部分：Eden、Survivor0（简称 S0）、Survivor1（简称S1）。这 3 部分按照 8:1:1 的比例来划分新生代。这 3 块区域的内存分配过程如下:</p>
<ol>
<li><p>绝大多数刚刚被创建的对象会存放在 Eden区。当 Eden 区第一次满的时候，会进行垃圾回收。首先将 Eden 区的垃圾对象回收清除，并将存活的对象复制到 S0，此时 S1 是空的。</p>
</li>
<li><p>下一次 Eden 区满时，再执行一次垃圾回收。此次会将 Eden 和 S0 区中所有垃圾对象清除，并将存活对象复制到 S1，此时 S0 变为空。</p>
</li>
<li><p>如此反复在 S0 和 S1之间切换几次（默认 15 次）之后，如果还有存活对象。说明这些对象的生命周期较长，则将它们转移到老年代中。</p>
<h4 id="年老代（OldGeneration）"><a href="#年老代（OldGeneration）" class="headerlink" title="年老代（OldGeneration）"></a>年老代（OldGeneration）</h4><p>一个对象如果在新生代存活了足够长的时间而没有被清理掉，则会被复制到老年代。老年代的内存大小一般比新生代大，能存放更多的对象。如果对象比较大（比如长字符串或者大数组），并且新生代的剩余空间不足，则这个大对象会直接被分配到老年代上。</p>
<p>注意：对于老年代可能存在这么一种情况，老年代中的对象有时候会引用到新生代对象。这时如果要执行新生代GC，则可能需要查询整个老年代上可能存在引用新生代的情况，这显然是低效的。所以，老年代中维护了一个 512 byte 的 card table，所有老年代对象引用新生代对象的信息都记录在这里。每当新生代发生 GC 时，只需要检查这个 card table 即可，大大提高了性能。 </p>
<h4 id="GCLog分析"><a href="#GCLog分析" class="headerlink" title="GCLog分析"></a>GCLog分析</h4><p>为了让上层应用开发人员更加方便的调试Java程序，JVM提供了相应的GC日志。在GC执行垃圾回收事件的过程中，会有各种相应的log被打印出来。其中新生代和老年代所打印的日志是有区别的。</p>
<p>新生代GC：这一区域的GC叫作MinorGC。因为Java对象大多都具备朝生夕灭的特性，所以MinorGC非常频繁，一般回收速度也比较快。</p>
<p>老年代 GC：发生在这一区域的 GC 也叫作 Major GC 或者 Full GC。当出现了 Major GC，经常会伴随至少一次的 Minor GC。</p>
<p>注意：在有些虚拟机实现中，Major GC 和 Full GC 还是有一些区别的。Major GC 只是代表回收老年代的内存，而 Full GC 则代表回收整个堆中的内存，也就是新生代 + 老年代。 </p>
<h4 id="Java-命令的参数"><a href="#Java-命令的参数" class="headerlink" title="Java 命令的参数"></a>Java 命令的参数</h4><p><img src="https://s0.lgstatic.com/i/image3/M01/7C/9B/Cgq2xl58lmeAAsp5AABwifdCuEw841.png" alt=""></p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>判断对象是否存活我们是通过GCRoots的引用可达性来判断的。但是JVM中的引用关系并不止一种，而是有四种，根据引用强度的由强到弱，他们分别是:<strong>强引用(StrongReference)、软引用(SoftReference)、弱引用(Weak Reference)、虚引用(Phantom Reference)</strong>。</p>
<p>四种引用做简单对比</p>
<p><img src="https://s0.lgstatic.com/i/image3/M01/03/85/Ciqah158ltqAHyEHAACoLz2II_g092.png" alt=""></p>
</li>
</ol>
</li>
</ol>
<p>平时项目中，尤其是Android项目，因为有大量的图像(Bitmap)对象，使用软引用的场景较多。所以重点看下软引用SoftReference的使用，不当的使用软引用有时也会导致系统异常。</p>
<h5 id="软引用隐藏问题"><a href="#软引用隐藏问题" class="headerlink" title="软引用隐藏问题"></a>软引用隐藏问题</h5><p>“<strong>GC overhead</strong>“,之所以会抛出这个错误，是由于虚拟机一直在不断回收软引用，回收进行的速度过快，占用的cpu过大(超过98%)，并且每次回收掉的内存过小(小于2%)，导致最终抛出了这个错误。</p>
<p><strong>优化方法，</strong>合适的处理方式是注册一个引用队列，每次循环之后将引用队列中出现的软引用对象从cache中移除。</p>
<p>参考链接：<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67" target="_blank" rel="noopener">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>jni无法访问so提示not accessible</title>
    <url>/2020/09/04/JNI%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AEso%E6%8F%90%E7%A4%BAnot%20accessible/</url>
    <content><![CDATA[<p>问题：app需要引用系统的so库，当install形式的时候安装时，打开app需要使用/system/lib64目录下的so库时，提示不能访问。<br>原因分析：放到system/app下的app是可以找到的，但是普通的安装形式的app是没有权限访问的，所以需要需要声明公有so库才能使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">library &quot;&#x2F;system&#x2F;lib64&#x2F;libserialport.so&quot; (&quot;&#x2F;system&#x2F;lib64&#x2F;libhqbindcs.so&quot;) needed or</span><br><span class="line">dlopened by&quot;&#x2F;system&#x2F;lib64&#x2F;libhqbindcs.so&quot; is not accessible for the namespace</span><br><span class="line">&quot;classloader-namespace&quot;</span><br></pre></td></tr></table></figure>
<p>解决方法：<br>修改system/core/rootdir/etc/public.libraries.txt<br>添加你要使用的的so到此问题件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat public.libraries.txt </span><br><span class="line">....</span><br><span class="line">libz.so</span><br><span class="line">libhqbindcs.so</span><br></pre></td></tr></table></figure>

<p>也可以直接不编译在板子上修改，对应目录/system/etc  </p>
<p>参考：<br>Framework基础：Android N 公共so库怎么定义呢？<br><a href="https://www.jianshu.com/p/4be3d1dafbec" target="_blank" rel="noopener">https://www.jianshu.com/p/4be3d1dafbec</a></p>
<p>[Google]原生库的命名空间<br><a href="https://source.android.com/devices/tech/config/namespaces_libraries" target="_blank" rel="noopener">https://source.android.com/devices/tech/config/namespaces_libraries</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器共享文件夹Samba</title>
    <url>/2020/03/21/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9Samba/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/Utotao/article/details/100848930" target="_blank" rel="noopener">Windows访问Linux服务器共享文件夹–Samba</a></p>
<h4 id="1、Linux安装Samba及配置"><a href="#1、Linux安装Samba及配置" class="headerlink" title="1、Linux安装Samba及配置"></a>1、Linux安装Samba及配置</h4><h5 id="安装Samba："><a href="#安装Samba：" class="headerlink" title="安装Samba："></a>安装Samba：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install samba</span><br></pre></td></tr></table></figure>
<h5 id="配置Samba："><a href="#配置Samba：" class="headerlink" title="配置Samba："></a>配置Samba：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;samba&#x2F;smb.conf</span><br></pre></td></tr></table></figure>
<h5 id="配置内容："><a href="#配置内容：" class="headerlink" title="配置内容："></a>配置内容：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[share]</span><br><span class="line">    #comment &#x3D; Ubuntu File Server Share</span><br><span class="line">    path &#x3D; &#x2F;home&#x2F;ubuntu</span><br><span class="line">    valid users &#x3D; root</span><br><span class="line">    available &#x3D; yes</span><br><span class="line">    browsable &#x3D; yes</span><br><span class="line">    writable &#x3D; yes</span><br></pre></td></tr></table></figure>
<p>配置用户名密码：（windows访问share文件夹时候使用）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo smbpasswd -a root -&gt; 注意此处的用户名要和上面的valid users保持一致</span><br></pre></td></tr></table></figure>

<p>回车后会让你输入密码<br>设置共享文件夹权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chmod 777 &#x2F;home&#x2F;ubuntu</span><br></pre></td></tr></table></figure>

<p>重启：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;samb restart</span><br></pre></td></tr></table></figure>
<h3 id="2、windows访问共享文件夹"><a href="#2、windows访问共享文件夹" class="headerlink" title="2、windows访问共享文件夹"></a>2、windows访问共享文件夹</h3><p>网络—&gt;右键选择映射网络驱动器，填写IP+Samba配置文件中的[share]之[]里面的字样</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Nexus3.12私服搭建</title>
    <url>/2019/03/18/Nexus3.12%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h5 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h5><p>（1）、<a href="https://www.sonatype.com/download-oss-sonatype" target="_blank" rel="noopener">nexus最新版本下载</a>（Nexus Repository Manager OSS 3.x - Windows）<br>（2）、解压后，安装服务，启动服务  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）左shift打开CMD窗口nexus-3.12.1-01-win64\nexus-3.12.1-01\bin目录    </span><br><span class="line">2）nexus.exe &#x2F;install  安装服务  </span><br><span class="line">3）nexus.exe &#x2F;start    启动服务  </span><br><span class="line">4）nexus.exe &#x2F;stop     停止服务</span><br></pre></td></tr></table></figure>
<p>（3）、使用nexus软件<br>在浏览器中输入<a href="http://localhost:8081/，点击“login" target="_blank" rel="noopener">http://localhost:8081/，点击“login</a> in”，输入admin/admin123即可。<br>（4）、管理目前的仓库<br>将central的远程地址修改如下（即改为aliyun的镜像，主要是速度快一些）：<a href="http://maven.aliyun.com/nexus/content/groups/public/" target="_blank" rel="noopener">http://maven.aliyun.com/nexus/content/groups/public/</a><br>（<a href="https://blog.csdn.net/ytfrdfiw/article/details/78476087" target="_blank" rel="noopener">参考链接</a>）</p>
<h4 id="多平台Nexus私服搭建"><a href="#多平台Nexus私服搭建" class="headerlink" title="多平台Nexus私服搭建"></a>多平台Nexus私服搭建</h4><p><a href="http://www.10tiao.com/html/227/201703/2650238831/1.html" target="_blank" rel="noopener">Android Studio依赖管理与Nexus私服搭建</a>  </p>
<p>创建自己的仓库</p>
<p>创建用户</p>
<p>首先使用管理员密码登陆到 Nexus私服 并添加用户：</p>
<p>。。。。</p>
<p>上传自己的Module到仓库</p>
<p>1、 在项目级别的 build.gradle 中的 allprojects 下 repositories节点 添加 mavenLocal()：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenLocal()</span><br><span class="line">        maven&#123;</span><br><span class="line">            url &quot;http:&#x2F;&#x2F;localhost:8081&#x2F;repository&#x2F;PublicTitle&#x2F;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>2、 在 Lib Module 级别的 build.gradle 中添加 maven 插件 apply plugin: ‘maven’：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: &#39;com.android.library&#39;</span><br><span class="line">apply plugin: &#39;maven&#39;</span><br></pre></td></tr></table></figure>

<p>3、 在 Lib Module 级别的 build.gradle 中 android节点 添加上传行为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories.mavenDeployer &#123;</span><br><span class="line">        repository(url: &quot;http:&#x2F;&#x2F;localhost:8081&#x2F;repository&#x2F;PublicTitle&#x2F;&quot;)&#123;</span><br><span class="line">            authentication(userName: &quot;wz&quot;,password: &quot;123456&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        pom.groupId &#x3D; &#39;com.hopechart&#39;</span><br><span class="line">        pom.artifactId &#x3D; &#39;PublicTitle&#39;</span><br><span class="line">        pom.version &#x3D; &#39;1.0.1&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用Gradle插件上传aar到Maven私服，点击 uploadArchives 自动上传：</p>
<p>5、引用私服中的Module  </p>
<p>在需要依赖 Module 的 build.gradle 中添加如下节点,其中URL就是上文中创建仓库的ur</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;项目级别的 build.gradle</span><br><span class="line"> allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        ......</span><br><span class="line">        maven&#123;</span><br><span class="line">            url &quot;http:&#x2F;&#x2F;localhost:8081&#x2F;repository&#x2F;PublicTitle&#x2F;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;model级别的 build.gradle</span><br><span class="line"></span><br><span class="line"> compile &#39;com.hopechart:PublicTitle:1.0.0&#39;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
        <category>打包编译</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>打包编译</tag>
      </tags>
  </entry>
  <entry>
    <title>ROOM</title>
    <url>/2020/03/20/ROOM/</url>
    <content><![CDATA[<p>不使用AndroidX的依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def room_version &#x3D; &quot;1.1.1&quot;</span><br><span class="line"></span><br><span class="line">    implementation &quot;android.arch.persistence.room:runtime:$room_version&quot;</span><br><span class="line">    kapt &quot;android.arch.persistence.room:compiler:$room_version&quot; &#x2F;&#x2F; use kapt for Kotlin</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">data class User(</span><br><span class="line">        @PrimaryKey val uid: Int,</span><br><span class="line">        @ColumnInfo(name &#x3D; &quot;first_name&quot;) val firstName: String?,</span><br><span class="line">        @ColumnInfo(name &#x3D; &quot;last_name&quot;) val lastName: String?)</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Database(entities &#x3D; [User::class], version &#x3D; 1)</span><br><span class="line">abstract class AppDatabase : RoomDatabase() &#123;</span><br><span class="line">    abstract fun userDao(): UserDao</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Dao</span><br><span class="line">interface UserDao &#123;</span><br><span class="line">    @Query(&quot;SELECT * FROM user&quot;)</span><br><span class="line">    fun getAll(): List&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM user WHERE uid IN (:userIds)&quot;)</span><br><span class="line">    fun loadAllByIds(userIds: IntArray): List&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM user WHERE first_name LIKE :first AND &quot; +</span><br><span class="line">            &quot;last_name LIKE :last LIMIT 1&quot;)</span><br><span class="line">    fun findByName(first: String, last: String): User</span><br><span class="line"></span><br><span class="line">    @Insert</span><br><span class="line">    fun insertAll(vararg users: User)</span><br><span class="line"></span><br><span class="line">    @Delete</span><br><span class="line">    fun delete(user: User)</span><br><span class="line"></span><br><span class="line">    @Query(&quot;select max(uid) from user &quot;)</span><br><span class="line">    fun queryMaxId(): Int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val userDao: UserDao by lazy &#123;</span><br><span class="line">           Room.databaseBuilder(</span><br><span class="line">                   appContext,</span><br><span class="line">                   AppDatabase::class.java, &quot;database-name&quot;</span><br><span class="line">           ).build().userDao()</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h4 id="监控数据变化"><a href="#监控数据变化" class="headerlink" title="监控数据变化"></a>监控数据变化</h4><p>使用RoomDatabase.getInvalidationTracker获取InvalidationTracker对象来监听表数据的改变。一般推荐直接在DAO方法中返回LiveData或者Observable对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Query(&quot;SELECT * FROM ConsumeInfo where timeStr LIKE :month ORDER BY time ASC&quot;)</span><br><span class="line">  fun getDataWithMonth(month: String): LiveData&lt;List&lt;ConsumeInfo&gt;&gt;</span><br><span class="line">  </span><br><span class="line">  ViewModel中监听，也可以放在界面上监听，下面的代码只能在Model中监听</span><br><span class="line">  </span><br><span class="line">   val liveLists &#x3D; DaoUtil.instance.getConsumeInfoList(month)</span><br><span class="line">          &#x2F;&#x2F; 添加数据监听，当数据变化时自动更新数据</span><br><span class="line">          liveLists.observe(owner, Observer&lt;List&lt;ConsumeInfo&gt;&gt; &#123;</span><br><span class="line">              Logger.e(&quot;getHistoryConsume observe change&quot;)</span><br><span class="line">              getAverageConsume(it)</span><br><span class="line">          &#125;)</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private val users: MutableLiveData&lt;List&lt;User&gt;&gt; by lazy &#123;</span><br><span class="line">       MutableLiveData&lt;List&lt;User&gt;&gt;().also &#123;</span><br><span class="line">           uiScope.launch &#123;</span><br><span class="line">               val rst &#x3D; async(Dispatchers.IO) &#123; App.userDao.getAll() &#125;</span><br><span class="line">               it.value &#x3D; rst.await()</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fun getUsers(): LiveData&lt;List&lt;User&gt;&gt; &#123;</span><br><span class="line">       uiScope.launch &#123;</span><br><span class="line">           val rst &#x3D; async(Dispatchers.IO) &#123; App.userDao.getAll() &#125;</span><br><span class="line">           users.value &#x3D; rst.await()</span><br><span class="line">       &#125;</span><br><span class="line">       return users</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fun setUsers() &#123;</span><br><span class="line">       uiScope.launch &#123;</span><br><span class="line">           val rst &#x3D; async(Dispatchers.IO) &#123;</span><br><span class="line">               var count &#x3D; App.userDao.queryMaxId()</span><br><span class="line">               App.userDao.insertAll(User(++count, &quot;f$count&quot;, &quot;l$count&quot;))</span><br><span class="line">               App.userDao.getAll()</span><br><span class="line">           &#125;</span><br><span class="line">           users.value &#x3D; rst.await()</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
        <category>JetPack</category>
      </categories>
      <tags>
        <tag>JetPack</tag>
      </tags>
  </entry>
  <entry>
    <title>System.img的查看-处理</title>
    <url>/2020/06/04/System-img%E7%9A%84%E6%9F%A5%E7%9C%8B-%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>在服务器上编译完源码之后，有时候需要想要查看打出img的内容是不是自己想要的，比如说添加了一个新的apk文件，如果重新烧写到手机会浪费很多时间，想在服务器上直接查看，可以参考如下方法。<br><a href="https://blog.csdn.net/sir_zeng/article/details/51983432" target="_blank" rel="noopener">System.img的查看/处理</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file out&#x2F;target&#x2F;product&#x2F;px3&#x2F;system.img</span><br><span class="line"></span><br><span class="line">out&#x2F;host&#x2F;linux-x86&#x2F;bin&#x2F;simg2img out&#x2F;target&#x2F;product&#x2F;px3&#x2F;system.img system.img</span><br><span class="line">file system.img</span><br><span class="line">sudo mount -o loop system.img &#x2F;mnt</span><br><span class="line">ls -lh &#x2F;mnt&#x2F;</span><br></pre></td></tr></table></figure>
<p>解包system.img<br>simg2img<br>simg2img用于把压缩过/hash过的img文件还原为raw的img文件<br>它通常在编译输出的out/host/linux-x86/bin/simg2img中<br>查询原始system.img文件类型,可以看到是data  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file out&#x2F;target&#x2F;product&#x2F;msm8909&#x2F;system.img</span><br><span class="line">out&#x2F;target&#x2F;product&#x2F;msm8909&#x2F;system.img: data</span><br><span class="line">转换命令如下</span><br><span class="line"></span><br><span class="line">Usage: simg2img &lt;sparse_image_files&gt; &lt;raw_image_file&gt;</span><br><span class="line">out&#x2F;host&#x2F;linux-x86&#x2F;bin&#x2F;simg2img out&#x2F;target&#x2F;product&#x2F;msm8909&#x2F;system.img out&#x2F;target&#x2F;product&#x2F;msm8909&#x2F;systemraw.img</span><br></pre></td></tr></table></figure>

<p>查询下转换后的systemraw.img文件类型  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file out&#x2F;target&#x2F;product&#x2F;msm8909&#x2F;systemraw.img</span><br><span class="line">out&#x2F;target&#x2F;product&#x2F;msm8909&#x2F;systemraw.img: Linux rev 1.0 ext4 filesystem data, UUID&#x3D;57f8f4bc-abf4-655f-bf67-946fc0f9f25b (extents) (large files)</span><br></pre></td></tr></table></figure>

<p>[编辑] mount systemraw.img<br>这个systemraw.img就可以任意我们处理了,最好的处理方法是直接mount它,然后进去看/处理内容,如果直接解开,很容易丢失了软链接,甚至会到是selinux的权限错乱</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir aaa</span><br><span class="line">sudo mount -t ext4 -o loop out&#x2F;target&#x2F;product&#x2F;msm8909&#x2F;systemraw.img aaa</span><br></pre></td></tr></table></figure>

<p>[编辑] 处理mount的img<br>[编辑] 查看占用的空间<br>df -h<br>输出类似  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">&#x2F;dev&#x2F;loop0      2.0G  450M  1.5G  23% &#x2F;media&#x2F;work_r&#x2F;szgit&#x2F;8909&#x2F;LINUX&#x2F;android&#x2F;aaa</span><br></pre></td></tr></table></figure>

<p>[编辑] 其他处理<br>其他的诸如 chmod rm cp mv   chown想怎样就可以怎样了,随便修改  </p>
<p>[编辑] 保存处理mount的img<br>umount就ok,自动保存了  </p>
<p>sudo umount aaa<br>[编辑] 打包为system.img<br>[编辑] img2simg<br>img2simg用于把img文件打包<br>它通常在编译输出的out/host/linux-x86/bin/img2simg中<br>转换命令如下  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: img2simg &lt;raw_image_file&gt; &lt;sparse_image_file&gt; [&lt;block_size&gt;]</span><br><span class="line">out&#x2F;host&#x2F;linux-x86&#x2F;bin&#x2F;img2simg out&#x2F;target&#x2F;product&#x2F;msm8909&#x2F;systemraw.img out&#x2F;target&#x2F;product&#x2F;msm8909&#x2F;system.img</span><br></pre></td></tr></table></figure>

<p>转换出来 system.img和之前编译的没有啥区别,直接用fastboot就可以刷机  </p>
<p>[编辑] 其他<br>如果你找不到img2simg/simg2img,自己编译下,或者从其他项目中copy过来  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mmma system&#x2F;core&#x2F;libsparse&#x2F;   </span><br><span class="line">或者  </span><br><span class="line">mmm system&#x2F;core&#x2F;libsparse&#x2F;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统源码</tag>
      </tags>
  </entry>
  <entry>
    <title>android应用程序访问I2C接口</title>
    <url>/2020/09/11/android%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BF%E9%97%AEI2C%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>I2C总线是一种简单、双向二线制同步串行总线。它只需要两根线即可在连接于总线上的器件之间传送信息。<br>主器件用于启动总线传送数据，并产生时钟以开放传送的器件，此时任何被寻址的器件均被认为是从器件．在总线上主和从、发和收的关系不是恒定的，而取决于此时数据传送方向。如果主机要发送数据给从器件，则主机首先寻址从器件，然后主动发送数据至从器件，最后由主机终止数据传送；如果主机要接收从器件的数据，首先由主器件寻址从器件．然后主机接收从器件发送的数据，最后由主机终止接收过程。在这种情况下．主机负责产生定时时钟和终止数据传送。</p>
<p>Java code</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> xxxxxxx.xx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">I2cRadioTest</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"I2cRadioTest"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Called when the activity is first created. */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">int</span>[] buf = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">int</span> slaveAddr = <span class="number">0</span>xXX;</span><br><span class="line">        <span class="keyword">int</span> fileHander;</span><br><span class="line">        <span class="keyword">int</span> mode = <span class="number">0</span>xXX | <span class="number">0</span>xXX;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        I2c i2c = <span class="keyword">new</span> I2c();</span><br><span class="line">        fileHander = i2c.open(<span class="string">"/dev/i2c-1"</span>);</span><br><span class="line"></span><br><span class="line">        i2c.read(fileHander, slaveAddr, buf, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        Log.w(TAG,</span><br><span class="line">                <span class="string">"buf0= "</span> + Integer.toHexString(buf[<span class="number">0</span>]) + <span class="string">" buf1= "</span></span><br><span class="line">                        + Integer.toHexString(buf[<span class="number">1</span>]) + <span class="string">" buf2= "</span></span><br><span class="line">                        + Integer.toHexString(buf[<span class="number">2</span>]) + <span class="string">" buf=3 "</span></span><br><span class="line">                        + Integer.toHexString(buf[<span class="number">3</span>]));</span><br><span class="line"></span><br><span class="line">        buf[<span class="number">0</span>] = <span class="number">0x01</span>;</span><br><span class="line">        i = <span class="number">0</span>;<span class="comment">// i2c.write(fileHander, slaveAddr, mode, buf, 1);</span></span><br><span class="line">        Log.w(TAG, <span class="string">"write length "</span> + i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            buf[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i2c.read(fileHander, slaveAddr, buf, <span class="number">4</span>);</span><br><span class="line">        Log.w(TAG,</span><br><span class="line">                <span class="string">"buf0= "</span> + Integer.toHexString(buf[<span class="number">0</span>]) + <span class="string">" buf1= "</span></span><br><span class="line">                        + Integer.toHexString(buf[<span class="number">1</span>]) + <span class="string">" buf2= "</span></span><br><span class="line">                        + Integer.toHexString(buf[<span class="number">2</span>]) + <span class="string">" buf=3 "</span></span><br><span class="line">                        + Integer.toHexString(buf[<span class="number">3</span>]));</span><br><span class="line"></span><br><span class="line">        i2c.close(fileHander);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((buf[<span class="number">0</span>] &amp; <span class="number">0x10</span>) == <span class="number">0x01</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"------success-----"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"----fail-------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setContentView(R.layout.main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> xxxxxx.xxx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is a I2C operation class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">I2c</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nodeName</span></span><br><span class="line"><span class="comment">     *            node path name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> return file hander else return &lt;0 on fail</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">open</span><span class="params">(String nodeName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileHander</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i2c_adr</span></span><br><span class="line"><span class="comment">     *            slave addr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Lenth</span></span><br><span class="line"><span class="comment">     *            of buf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> read length</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fileHander, <span class="keyword">int</span> i2c_adr, <span class="keyword">int</span> buf[], <span class="keyword">int</span> Length)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileHander</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i2c_adr</span></span><br><span class="line"><span class="comment">     *            slave addr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sub_adr</span></span><br><span class="line"><span class="comment">     *            sub addr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Lenth</span></span><br><span class="line"><span class="comment">     *            of buf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> write length</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fileHander, <span class="keyword">int</span> i2c_adr, <span class="keyword">int</span> sub_adr,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> buf[], <span class="keyword">int</span> Length)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fileHander)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"test-i2c"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C/C++ code</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class xxxxxx_xxx_I2c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_xxxxxx_xxx_I2c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_xxxxxx_xxx_I2c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     xxxxxx_xxx_I2c</span></span><br><span class="line"><span class="comment"> * Method:    open</span></span><br><span class="line"><span class="comment"> * Signature: (Ljava/lang/String;)I</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jint JNICALL Java_xxxxxx_xxx_I2c_open</span><br><span class="line">  (JNIEnv *, jobject, jstring);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     xxxxxx_xxx_I2c</span></span><br><span class="line"><span class="comment"> * Method:    read</span></span><br><span class="line"><span class="comment"> * Signature: (II[II)I</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jint JNICALL Java_xxxxxx_xxx_I2c_read</span><br><span class="line">  (JNIEnv *, jobject, jint, jint, jintArray, jint);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     xxxxxx_xxx_I2c</span></span><br><span class="line"><span class="comment"> * Method:    write</span></span><br><span class="line"><span class="comment"> * Signature: (III[II)I</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jint JNICALL Java_xxxxxx_xxx_I2c_write</span><br><span class="line">  (JNIEnv *, jobject, jint, jint, jint, jintArray, jint);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     xxxxxx_xxx_I2c</span></span><br><span class="line"><span class="comment"> * Method:    close</span></span><br><span class="line"><span class="comment"> * Signature: (I)V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_xxxxxx_xxx_I2c_close</span><br><span class="line">  (JNIEnv *, jobject, jint);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test-i2c.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LOG_TAG    <span class="meta-string">"i2c"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LOGI(...)  __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LOGE(...)  __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL Java_xxxxxx_xxx_I2c_open</span><br><span class="line">  (JNIEnv *env, jobject obj, jstring file)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">char</span> fileName[<span class="number">64</span>];</span><br><span class="line">      <span class="keyword">const</span> jbyte *str;</span><br><span class="line">      </span><br><span class="line">      str = (*env)-&gt;GetStringUTFChars(env, file, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">if</span> (str == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          LOGI(<span class="string">"Can't get file name!"</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">sprintf</span>(fileName, <span class="string">"%s"</span>, str);</span><br><span class="line">    LOGI(<span class="string">"will open i2c device node %s"</span>, fileName);</span><br><span class="line">      (*env)-&gt;ReleaseStringUTFChars(env, file, str);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">open</span>(fileName, O_RDWR);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">JNIEXPORT jint JNICALL Java_xxxxxx_xxx_I2c_read</span><br><span class="line">  (JNIEnv * env, jobject obj, jint fileHander, jint slaveAddr, jintArray bufArr, jint len)</span><br><span class="line">  &#123;</span><br><span class="line">      jint *bufInt;</span><br><span class="line">      <span class="keyword">char</span> *bufByte;</span><br><span class="line">      <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          LOGE(<span class="string">"I2C: buf len &lt;=0"</span>);</span><br><span class="line">          <span class="keyword">goto</span> err0;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      bufInt = (jint *) <span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">      <span class="keyword">if</span> (bufInt == <span class="number">0</span>) &#123;</span><br><span class="line">          LOGE(<span class="string">"I2C: nomem"</span>);</span><br><span class="line">          <span class="keyword">goto</span> err0;</span><br><span class="line">      &#125;</span><br><span class="line">      bufByte = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(len);</span><br><span class="line">      <span class="keyword">if</span> (bufByte == <span class="number">0</span>) &#123;</span><br><span class="line">          LOGE(<span class="string">"I2C: nomem"</span>);</span><br><span class="line">          <span class="keyword">goto</span> err1;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      (*env)-&gt;GetIntArrayRegion(env, bufArr, <span class="number">0</span>, len, bufInt);</span><br><span class="line">      </span><br><span class="line">      res = ioctl(fileHander, I2C_SLAVE, slaveAddr);</span><br><span class="line">      <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">          LOGE(<span class="string">"I2C: Can't set slave address"</span>);</span><br><span class="line">          <span class="keyword">goto</span> err2;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">memset</span>(bufByte, <span class="string">'\0'</span>, len);</span><br><span class="line">      <span class="keyword">if</span> ((j = <span class="built_in">read</span>(fileHander, bufByte, len)) != len) &#123;</span><br><span class="line">        LOGE(<span class="string">"read fail in i2c read jni i = %d buf 4"</span>, i);</span><br><span class="line">        <span class="keyword">goto</span> err2;        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; j ; i++)</span><br><span class="line">            bufInt[i] = bufByte[i];</span><br><span class="line">        LOGI(<span class="string">"return %d %d %d %d in i2c read jni"</span>, bufByte[<span class="number">0</span>], bufByte[<span class="number">1</span>], bufByte[<span class="number">2</span>], bufByte[<span class="number">3</span>]);</span><br><span class="line">        (*env)-&gt;SetIntArrayRegion(env, bufArr, <span class="number">0</span>, len, bufInt);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(bufByte);</span><br><span class="line">    <span class="built_in">free</span>(bufInt);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line"></span><br><span class="line">err2:</span><br><span class="line">    <span class="built_in">free</span>(bufByte);</span><br><span class="line">err1:</span><br><span class="line">    <span class="built_in">free</span>(bufInt);</span><br><span class="line">err0:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;                                          </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">JNIEXPORT jint JNICALL Java_xxxxxx_xxx_I2c_write</span><br><span class="line">  (JNIEnv *env, jobject obj, jint fileHander, jint slaveAddr, jint mode,</span><br><span class="line">   jintArray bufArr, jint len)</span><br><span class="line">  &#123;</span><br><span class="line">      jint *bufInt;</span><br><span class="line">      <span class="keyword">char</span> *bufByte;</span><br><span class="line">      <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          LOGE(<span class="string">"I2C: buf len &lt;=0"</span>);</span><br><span class="line">          <span class="keyword">goto</span> err0;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      bufInt = (jint *) <span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">      <span class="keyword">if</span> (bufInt == <span class="number">0</span>) &#123;</span><br><span class="line">          LOGE(<span class="string">"I2C: nomem"</span>);</span><br><span class="line">          <span class="keyword">goto</span> err0;</span><br><span class="line">      &#125;</span><br><span class="line">      bufByte = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(len + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (bufByte == <span class="number">0</span>) &#123;</span><br><span class="line">          LOGE(<span class="string">"I2C: nomem"</span>);</span><br><span class="line">          <span class="keyword">goto</span> err1;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      (*env)-&gt;GetIntArrayRegion(env, bufArr, <span class="number">0</span>, len, bufInt);</span><br><span class="line">      bufByte[<span class="number">0</span>] = mode;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">          bufByte[i + <span class="number">1</span>] = bufInt[i];      </span><br><span class="line">      </span><br><span class="line">      res = ioctl(fileHander, I2C_SLAVE, slaveAddr);</span><br><span class="line">      <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">          LOGE(<span class="string">"I2C: Can't set slave address"</span>);</span><br><span class="line">          <span class="keyword">goto</span> err2;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> ((j = <span class="built_in">write</span>(fileHander, bufByte, len + <span class="number">1</span>)) != len + <span class="number">1</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"write fail in i2c"</span>);</span><br><span class="line">        <span class="keyword">goto</span> err2;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LOGI(<span class="string">"I2C: write %d byte"</span>, j);</span><br><span class="line">    <span class="built_in">free</span>(bufByte);</span><br><span class="line">    <span class="built_in">free</span>(bufInt);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> j - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">err2:</span><br><span class="line">    <span class="built_in">free</span>(bufByte);</span><br><span class="line">err1:</span><br><span class="line">    <span class="built_in">free</span>(bufInt);</span><br><span class="line">err0:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;     </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_xxxxxx_xxx_I2c_close</span><br><span class="line">  (JNIEnv *env, jobject obj, jint fileHander)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">close</span>(fileHander);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.jianshu.com/p/02dc4bb83c95" target="_blank" rel="noopener">https://www.jianshu.com/p/02dc4bb83c95</a> </p>
]]></content>
      <categories>
        <category>Android</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>system.img打包出错设备上没有空间</title>
    <url>/2020/06/14/system-img%E6%89%93%E5%8C%85%E5%87%BA%E9%94%99%E8%AE%BE%E5%A4%87%E4%B8%8A%E6%B2%A1%E6%9C%89%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<p>在打system.img的时候提示出错: 设备上没有空间</p>
<p>在现有android系统时，用adb工具把程序放入系统中</p>
<p>cmd </p>
<p>cd 到adb的目录下</p>
<p>adb push xxx.xml etc/</p>
<p>当我们要制作系统镜像时，可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir system</span><br><span class="line"></span><br><span class="line">sudo mount -o loop system.img system</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cp -rf xxx.xml system&#x2F;etc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo umount system</span><br></pre></td></tr></table></figure>




<p>执行cp时候，提示设备上没有空间，这时候，可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install e2fsprogs</span><br><span class="line"></span><br><span class="line">e2fsck -f system.img</span><br><span class="line">resize2fs system.img 1000M</span><br><span class="line">sudo mount -o loop system.img system</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cp xxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo umount system</span><br><span class="line">e2fsck -f system.img</span><br><span class="line">resize2fs -M system.img</span><br></pre></td></tr></table></figure>
<p>最后需要修改内存分配配置。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统源码</tag>
      </tags>
  </entry>
  <entry>
    <title>vi—终端中的编辑器</title>
    <url>/2020/03/18/vi%E2%80%94%E7%BB%88%E7%AB%AF%E4%B8%AD%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<h1 id="vi-——-终端中的编辑器"><a href="#vi-——-终端中的编辑器" class="headerlink" title="vi —— 终端中的编辑器"></a><code>vi</code> —— 终端中的编辑器</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li><code>vi</code> 简介</li>
<li>打开和新建文件</li>
<li>三种工作模式</li>
<li>常用命令</li>
<li>分屏命令</li>
<li>常用命令速查图</li>
</ul>
<h2 id="01-vi-简介"><a href="#01-vi-简介" class="headerlink" title="01. vi 简介"></a>01. <code>vi</code> 简介</h2><h3 id="1-1-学习-vi-的目的"><a href="#1-1-学习-vi-的目的" class="headerlink" title="1.1 学习 vi 的目的"></a>1.1 学习 <code>vi</code> 的目的</h3><ul>
<li>在工作中，要对 <strong>服务器</strong> 上的文件进行 <strong>简单</strong> 的修改，可以使用 <code>ssh</code> 远程登录到服务器上，并且使用 <code>vi</code> 进行快速的编辑即可</li>
<li>常见需要修改的文件包括：<ul>
<li><strong>源程序</strong></li>
<li><strong>配置文件</strong>，例如 <code>ssh</code> 的配置文件 <code>~/.ssh/config</code></li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>在没有图形界面的环境下，要编辑文件，<code>vi</code> 是最佳选择！</li>
<li>每一个要使用 Linux 的程序员，都应该或多或少的学习一些 <code>vi</code> 的常用命令</li>
</ul>
</blockquote>
<h3 id="1-2-vi-和-vim"><a href="#1-2-vi-和-vim" class="headerlink" title="1.2 vi 和 vim"></a>1.2 vi 和 vim</h3><ul>
<li>在很多 <code>Linux</code> 发行版中，直接把 <code>vi</code> 做成 <code>vim</code> 的软连接</li>
</ul>
<h4 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h4><ul>
<li><code>vi</code> 是 <code>Visual interface</code> 的简称，是 <code>Linux</code> 中 <strong>最经典</strong> 的文本编辑器</li>
<li><code>vi</code> 的核心设计思想 —— <strong>让程序员的手指始终保持在键盘的核心区域，就能完成所有的编辑操作</strong></li>
</ul>
<p><img src="media/14993340485745/001_vi%E9%94%AE%E7%9B%98.png" alt="001_vi键盘-w551"></p>
<ul>
<li><code>vi</code> 的特点：<ul>
<li><strong>没有图形界面</strong> 的 <strong>功能强大</strong> 的编辑器</li>
<li>只能是编辑 <strong>文本内容</strong>，不能对字体、段落进行排版</li>
<li><strong>不支持鼠标操作</strong></li>
<li><strong>没有菜单</strong></li>
<li><strong>只有命令</strong></li>
</ul>
</li>
<li><code>vi</code> 编辑器在 <strong>系统管理</strong>、<strong>服务器管理</strong> 编辑文件时，<strong>其功能永远不是图形界面的编辑器能比拟的</strong></li>
</ul>
<h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a><code>vim</code></h4><p><strong>vim = vi improved</strong></p>
<ul>
<li><code>vim</code> 是从 <code>vi</code> 发展出来的一个文本编辑器，支持 <strong>代码补全</strong>、<strong>编译</strong> 及 <strong>错误跳转</strong> 等方便编程的功能特别丰富，在程序员中被广泛使用，被称为 <strong>编辑器之神</strong></li>
</ul>
<h4 id="查询软连接命令（知道）"><a href="#查询软连接命令（知道）" class="headerlink" title="查询软连接命令（知道）"></a>查询软连接命令（知道）</h4><ul>
<li>在很多 <code>Linux</code> 发行版中直接把 <code>vi</code> 做成 <code>vim</code> 的软连接</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找 vi 的运行文件</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">which</span> vi</span><br><span class="line">$ ls -l /usr/bin/vi</span><br><span class="line">$ ls -l /etc/alternatives/vi</span><br><span class="line">$ ls -l /usr/bin/vim.basic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找 vim 的运行文件</span></span><br><span class="line">$ <span class="built_in">which</span> vim</span><br><span class="line">$ ls -l /usr/bin/vim</span><br><span class="line">$ ls -l /etc/alternatives/vim</span><br><span class="line">$ ls -l /usr/bin/vim.basic</span><br></pre></td></tr></table></figure>

<h2 id="02-打开和新建文件"><a href="#02-打开和新建文件" class="headerlink" title="02. 打开和新建文件"></a>02. 打开和新建文件</h2><ul>
<li>在终端中输入 <code>vi</code> <strong>在后面跟上文件名</strong> 即可</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi 文件名</span><br></pre></td></tr></table></figure>

<ul>
<li>如果文件已经存在，会直接打开该文件</li>
<li>如果文件不存在，会新建一个文件</li>
</ul>
<h3 id="2-1-打开文件并且定位行"><a href="#2-1-打开文件并且定位行" class="headerlink" title="2.1 打开文件并且定位行"></a>2.1 打开文件并且定位行</h3><ul>
<li><p>在日常工作中，有可能会遇到 <strong>打开一个文件，并定位到指定行</strong> 的情况</p>
</li>
<li><p>例如：在开发时，<strong>知道某一行代码有错误</strong>，可以 <strong>快速定位</strong> 到出错代码的位置</p>
</li>
<li><p>这个时候，可以使用以下命令打开文件</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi 文件名 +行数</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：如果只带上 <code>+</code> 而不指定行号，会直接定位到文件末尾</p>
</blockquote>
<h3 id="2-2-异常处理"><a href="#2-2-异常处理" class="headerlink" title="2.2 异常处理"></a>2.2 异常处理</h3><ul>
<li>如果 <code>vi</code> 异常退出，在磁盘上可能会保存有 <strong>交换文件</strong></li>
<li>下次再使用 <code>vi</code> 编辑该文件时，会看到以下屏幕信息，按下字母 <code>d</code> 可以 <strong>删除交换文件</strong> 即可</li>
</ul>
<blockquote>
<p>提示：按下键盘时，注意关闭输入法</p>
</blockquote>
<p><img src="media/14993340485745/002_%E5%88%A0%E9%99%A4%E4%BA%A4%E6%8D%A2%E6%96%87%E4%BB%B6.png" alt="002_删除交换文件-w1048"></p>
<h2 id="03-三种工作模式"><a href="#03-三种工作模式" class="headerlink" title="03. 三种工作模式"></a>03. 三种工作模式</h2><ul>
<li><p><code>vi</code> 有三种基本工作模式：</p>
<ol>
<li><strong>命令模式</strong><ul>
<li><strong>打开文件首先进入命令模式</strong>，是使用 <code>vi</code> 的 <strong>入口</strong></li>
<li>通过 <strong>命令</strong> 对文件进行常规的编辑操作，例如：<strong>定位</strong>、<strong>翻页</strong>、<strong>复制</strong>、<strong>粘贴</strong>、<strong>删除</strong>……</li>
<li>在其他图形编辑器下，通过 <strong>快捷键</strong> 或者 <strong>鼠标</strong> 实现的操作，都在 <strong>命令模式</strong> 下实现</li>
</ul>
</li>
<li><strong>末行模式</strong> —— 执行 <strong>保存</strong>、<strong>退出</strong> 等操作 <ul>
<li>要退出 <code>vi</code> 返回到控制台，需要在末行模式下输入命令</li>
<li><strong>末行模式</strong> 是 <code>vi</code> 的 <strong>出口</strong></li>
</ul>
</li>
<li><strong>编辑模式</strong> —— 正常的编辑文字</li>
</ol>
</li>
</ul>
<p><img src="media/14993340485745/003_vi%E7%9A%84%E6%A8%A1%E5%BC%8F.png" alt="003_vi的模式-w500"></p>
<blockquote>
<p>提示：在 <code>Touch Bar</code> 的 Mac 电脑上 ，按 <code>ESC</code> 不方便，可以使用 <code>CTRL + [</code> 替代</p>
</blockquote>
<h3 id="末行模式命令"><a href="#末行模式命令" class="headerlink" title="末行模式命令"></a>末行模式命令</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">w</td>
<td align="center">write</td>
<td>保存</td>
</tr>
<tr>
<td align="center">q</td>
<td align="center">quit</td>
<td>退出，如果没有保存，不允许退出</td>
</tr>
<tr>
<td align="center">q!</td>
<td align="center">quit</td>
<td>强行退出，不保存退出</td>
</tr>
<tr>
<td align="center">wq</td>
<td align="center">write &amp; quit</td>
<td>保存并退出</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center"></td>
<td>保存并退出</td>
</tr>
</tbody></table>
<h2 id="04-常用命令"><a href="#04-常用命令" class="headerlink" title="04. 常用命令"></a>04. 常用命令</h2><h3 id="命令线路图"><a href="#命令线路图" class="headerlink" title="命令线路图"></a>命令线路图</h3><ol start="0">
<li>重复次数<ul>
<li>在命令模式下，<strong>先输入一个数字</strong>，<strong>再跟上一个命令</strong>，可以让该命令 <strong>重复执行指定次数</strong> </li>
</ul>
</li>
<li>移动和选择（<strong>多练</strong>）<ul>
<li><code>vi</code> 之所以快，关键在于 <strong>能够快速定位到要编辑的代码行</strong></li>
<li><strong>移动命令</strong> 能够 和 <strong>编辑操作</strong> 命令 <strong>组合使用</strong></li>
</ul>
</li>
<li>编辑操作<ul>
<li><strong>删除</strong>、<strong>复制</strong>、<strong>粘贴</strong>、<strong>替换</strong>、<strong>缩排</strong></li>
</ul>
</li>
<li>撤销和重复</li>
<li>查找替换</li>
<li>编辑</li>
</ol>
<h4 id="学习提示"><a href="#学习提示" class="headerlink" title="学习提示"></a>学习提示</h4><ol>
<li><code>vi</code> 的命令较多，<strong>不要期望一下子全部记住</strong>，个别命令忘记了，只是会影响编辑速度而已</li>
<li>在使用 <code>vi</code> 命令时，注意 <strong>关闭中文输入法</strong></li>
</ol>
<h3 id="4-1-移动（基本）"><a href="#4-1-移动（基本）" class="headerlink" title="4.1 移动（基本）"></a>4.1 移动（基本）</h3><ul>
<li>要熟练使用 <code>vi</code>，首先应该学会怎么在 <strong>命令模式</strong> 下样快速移动光标</li>
<li><strong>编辑操作命令</strong>，能够和 <strong>移动命令</strong> 结合在一起使用</li>
</ul>
<h4 id="1-上、下、左、右"><a href="#1-上、下、左、右" class="headerlink" title="1) 上、下、左、右"></a>1) 上、下、左、右</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th>功能</th>
<th align="center">手指</th>
</tr>
</thead>
<tbody><tr>
<td align="center">h</td>
<td>向左</td>
<td align="center">食指</td>
</tr>
<tr>
<td align="center">j</td>
<td>向下</td>
<td align="center">食指</td>
</tr>
<tr>
<td align="center">k</td>
<td>向上</td>
<td align="center">中指</td>
</tr>
<tr>
<td align="center">l</td>
<td>向右</td>
<td align="center">无名指</td>
</tr>
</tbody></table>
<p><img src="media/14993340485745/005_%E7%A7%BB%E5%8A%A8%E5%85%89%E6%A0%87.png" alt="005_移动光标-w551"></p>
<h4 id="2-行内移动"><a href="#2-行内移动" class="headerlink" title="2) 行内移动"></a>2) 行内移动</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">w</td>
<td align="center">word</td>
<td>向后移动一个单词</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">back</td>
<td>向前移动一个单词</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center"></td>
<td>行首</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center"></td>
<td>行首，第一个不是空白字符的位置</td>
</tr>
<tr>
<td align="center">$</td>
<td align="center"></td>
<td>行尾</td>
</tr>
</tbody></table>
<h4 id="3-行数移动"><a href="#3-行数移动" class="headerlink" title="3) 行数移动"></a>3) 行数移动</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">gg</td>
<td align="center">go</td>
<td>文件顶部</td>
</tr>
<tr>
<td align="center">G</td>
<td align="center">go</td>
<td>文件末尾</td>
</tr>
<tr>
<td align="center">数字gg</td>
<td align="center">go</td>
<td>移动到 数字 对应行数</td>
</tr>
<tr>
<td align="center">数字G</td>
<td align="center">go</td>
<td>移动到 数字 对应行数</td>
</tr>
<tr>
<td align="center">:数字</td>
<td align="center"></td>
<td>移动到 数字 对应行数</td>
</tr>
</tbody></table>
<h4 id="4-屏幕移动"><a href="#4-屏幕移动" class="headerlink" title="4) 屏幕移动"></a>4) 屏幕移动</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ctrl + b</td>
<td align="center">back</td>
<td>向上翻页</td>
</tr>
<tr>
<td align="center">Ctrl + f</td>
<td align="center">forward</td>
<td>向下翻页</td>
</tr>
<tr>
<td align="center">H</td>
<td align="center">Head</td>
<td>屏幕顶部</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">Middle</td>
<td>屏幕中间</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">Low</td>
<td>屏幕底部</td>
</tr>
</tbody></table>
<h3 id="4-2-移动（程序）"><a href="#4-2-移动（程序）" class="headerlink" title="4.2 移动（程序）"></a>4.2 移动（程序）</h3><h4 id="1-段落移动"><a href="#1-段落移动" class="headerlink" title="1) 段落移动"></a>1) 段落移动</h4><ul>
<li><code>vi</code> 中使用 空行 来区分段落</li>
<li>在程序开发时，通常 <strong>一段功能相关的代码会写在一起</strong> —— 之间没有空行</li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">{</td>
<td>上一段</td>
</tr>
<tr>
<td align="center">}</td>
<td>下一段</td>
</tr>
</tbody></table>
<h4 id="2-括号切换"><a href="#2-括号切换" class="headerlink" title="2) 括号切换"></a>2) 括号切换</h4><ul>
<li>在程序世界中，<code>()</code>、<code>[]</code>、<code>{}</code> 使用频率很高，而且 <strong>都是成对出现的</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%</td>
<td>括号匹配及切换</td>
</tr>
</tbody></table>
<h4 id="3-标记"><a href="#3-标记" class="headerlink" title="3) 标记"></a>3) 标记</h4><ul>
<li>在开发时，某一块代码可能<strong>需要稍后处理</strong>，例如：编辑、查看</li>
<li>此时先使用 <code>m</code> 增加一个标记，这样可以 <strong>在需要时快速地跳转回来</strong> 或者 <strong>执行其他编辑操作</strong></li>
<li><strong>标记名称</strong> 可以是 <code>a~z</code> 或者 <code>A~Z</code> 之间的任意 <strong>一个</strong> 字母</li>
<li>添加了标记的 <strong>行如果被删除</strong>，<strong>标记同时被删除</strong></li>
<li>如果 <strong>在其他行添加了相同名称的标记</strong>，<strong>之前添加的标记也会被替换掉</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mx</td>
<td align="center">mark</td>
<td>添加标记 x，x 是 a<del>z 或者 A</del>Z 之间的任意一个字母</td>
</tr>
<tr>
<td align="center">‘x</td>
<td align="center"></td>
<td>直接定位到标记 x 所在位置</td>
</tr>
</tbody></table>
<h3 id="4-3-选中文本（可视模式）"><a href="#4-3-选中文本（可视模式）" class="headerlink" title="4.3 选中文本（可视模式）"></a>4.3 选中文本（可视模式）</h3><ul>
<li>学习 <code>复制</code> 命令前，应该先学会 <strong>怎么样选中 要复制的代码</strong></li>
<li>在 <code>vi</code> 中要选择文本，需要先使用 <code>Visual</code> 命令切换到 <strong>可视模式</strong></li>
<li><code>vi</code> 中提供了 <strong>三种</strong> 可视模式，可以方便程序员选择 <strong>选中文本的方式</strong></li>
<li>按 <code>ESC</code> 可以放弃选中，返回到 <strong>命令模式</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th>模式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">v</td>
<td>可视模式</td>
<td>从光标位置开始按照正常模式选择文本</td>
</tr>
<tr>
<td align="center">V</td>
<td>可视行模式</td>
<td>选中光标经过的完整行</td>
</tr>
<tr>
<td align="center">Ctrl + v</td>
<td>可视块模式</td>
<td>垂直方向选中文本</td>
</tr>
</tbody></table>
<ul>
<li><strong>可视模式</strong>下，可以和 <strong>移动命令</strong> 连用，例如：<code>ggVG</code> 能够选中所有内容</li>
</ul>
<h3 id="4-4-撤销和恢复撤销"><a href="#4-4-撤销和恢复撤销" class="headerlink" title="4.4 撤销和恢复撤销"></a>4.4 撤销和恢复撤销</h3><ul>
<li>在学习编辑命令之前，先要知道怎样撤销之前一次 <strong>错误的</strong> 编辑动作！</li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u</td>
<td align="center">undo</td>
<td>撤销上次命令</td>
</tr>
<tr>
<td align="center">CTRL + r</td>
<td align="center">redo</td>
<td>恢复撤销的命令</td>
</tr>
</tbody></table>
<h3 id="4-5-删除文本"><a href="#4-5-删除文本" class="headerlink" title="4.5 删除文本"></a>4.5 删除文本</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x</td>
<td align="center">cut</td>
<td>删除光标所在字符，或者选中文字</td>
</tr>
<tr>
<td align="center">d(移动命令)</td>
<td align="center">delete</td>
<td>删除移动命令对应的内容</td>
</tr>
<tr>
<td align="center">dd</td>
<td align="center">delete</td>
<td>删除光标所在行，可以 ndd 复制多行</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">delete</td>
<td>删除至行尾</td>
</tr>
</tbody></table>
<blockquote>
<p>提示：如果使用 <strong>可视模式</strong> 已经选中了一段文本，那么无论使用 <code>d</code> 还是 <code>x</code>，都可以删除选中文本</p>
</blockquote>
<ul>
<li>删除命令可以和 <strong>移动命令</strong> 连用，以下是常见的组合命令：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* dw        # 从光标位置删除到单词末尾</span><br><span class="line">* d0        # 从光标位置删除到一行的起始位置</span><br><span class="line">* d&#125;        # 从光标位置删除到段落结尾</span><br><span class="line">* ndd       # 从光标位置向下连续删除 n 行</span><br><span class="line">* d代码行G   # 从光标所在行 删除到 指定代码行 之间的所有代码</span><br><span class="line">* d&#39;a       # 从光标所在行 删除到 标记a 之间的所有代码</span><br></pre></td></tr></table></figure>

<h3 id="4-6-复制、粘贴"><a href="#4-6-复制、粘贴" class="headerlink" title="4.6 复制、粘贴"></a>4.6 复制、粘贴</h3><ul>
<li><code>vi</code> 中提供有一个 <strong>被复制文本的缓冲区</strong><ul>
<li><strong>复制</strong> 命令会将选中的文字保存在缓冲区 </li>
<li><strong>删除</strong> 命令删除的文字会被保存在缓冲区</li>
<li>在需要的位置，使用 <strong>粘贴</strong> 命令可以将缓冲区的文字插入到光标所在位置</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">y(移动命令)</td>
<td align="center">copy</td>
<td>复制</td>
</tr>
<tr>
<td align="center">yy</td>
<td align="center">copy</td>
<td>复制一行，可以 nyy 复制多行</td>
</tr>
<tr>
<td align="center">p</td>
<td align="center">paste</td>
<td>粘贴</td>
</tr>
</tbody></table>
<p><strong>提示</strong></p>
<ul>
<li>命令 <code>d</code>、<code>x</code> 类似于图形界面的 <strong>剪切操作</strong> —— <code>CTRL + X</code></li>
<li>命令 <code>y</code> 类似于图形界面的 <strong>复制操作</strong> —— <code>CTRL + C</code></li>
<li>命令 <code>p</code> 类似于图形界面的 <strong>粘贴操作</strong> —— <code>CTRL + V</code></li>
<li><code>vi</code> 中的 <strong>文本缓冲区同样只有一个</strong>，如果后续做过 <strong>复制、剪切</strong> 操作，之前缓冲区中的内容会被替换</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li><code>vi</code> 中的 <strong>文本缓冲区</strong> 和系统的 <strong>剪贴板</strong> 不是同一个</li>
<li>所以在其他软件中使用 <code>CTRL + C</code> 复制的内容，不能在 <code>vi</code> 中通过 <code>P</code> 命令粘贴</li>
<li>可以在 <strong>编辑模式</strong> 下使用 <strong>鼠标右键粘贴</strong></li>
</ul>
<h3 id="4-7-替换"><a href="#4-7-替换" class="headerlink" title="4.7 替换"></a>4.7 替换</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
<th>工作模式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">r</td>
<td align="center">replace</td>
<td>替换当前字符</td>
<td>命令模式</td>
</tr>
<tr>
<td align="center">R</td>
<td align="center">replace</td>
<td>替换当前行光标后的字符</td>
<td>替换模式</td>
</tr>
</tbody></table>
<ul>
<li><code>R</code> 命令可以进入 <strong>替换模式</strong>，替换完成后，按下 <code>ESC</code> 可以回到 <strong>命令模式</strong></li>
<li><strong>替换命令</strong> 的作用就是不用进入 <strong>编辑模式</strong>，对文件进行 <strong>轻量级的修改</strong></li>
</ul>
<h3 id="4-8-缩排和重复执行"><a href="#4-8-缩排和重复执行" class="headerlink" title="4.8 缩排和重复执行"></a>4.8 缩排和重复执行</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&gt;&gt;</td>
<td>向右增加缩进</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td>向左减少缩进</td>
</tr>
<tr>
<td align="center">.</td>
<td>重复上次命令</td>
</tr>
</tbody></table>
<ul>
<li><strong>缩排命令</strong> 在开发程序时，<strong>统一增加代码的缩进</strong> 比较有用！<ul>
<li>一次性 <strong>在选中代码前增加 4 个空格</strong>，就叫做 <strong>增加缩进</strong></li>
<li>一次性 <strong>在选中代码前删除 4 个空格</strong>，就叫做 <strong>减少缩进</strong></li>
</ul>
</li>
<li>在 <strong>可视模式</strong> 下，缩排命令只需要使用 <strong>一个</strong> <code>&gt;</code> 或者 <code>&lt;</code> </li>
</ul>
<blockquote>
<p>在程序中，<strong>缩进</strong> 通常用来表示代码的归属关系</p>
<ul>
<li>前面空格越少，代码的级别越高</li>
<li>前面空格越多，代码的级别越低</li>
</ul>
</blockquote>
<h3 id="4-9-查找"><a href="#4-9-查找" class="headerlink" title="4.9 查找"></a>4.9 查找</h3><h4 id="常规查找"><a href="#常规查找" class="headerlink" title="常规查找"></a>常规查找</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">/str</td>
<td>查找 str</td>
</tr>
</tbody></table>
<ul>
<li>查找到指定内容之后，使用 <code>Next</code> 查找下一个出现的位置：<ul>
<li><code>n</code>: 查找下一个</li>
<li><code>N</code>: 查找上一个</li>
</ul>
</li>
<li>如果不想看到高亮显示，可以随便查找一个文件中不存在的内容即可</li>
</ul>
<h4 id="单词快速匹配"><a href="#单词快速匹配" class="headerlink" title="单词快速匹配"></a>单词快速匹配</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">*</td>
<td>向后查找当前光标所在单词</td>
</tr>
<tr>
<td align="center">#</td>
<td>向前查找当前光标所在单词</td>
</tr>
</tbody></table>
<ul>
<li>在开发中，通过单词快速匹配，可以快速看到这个单词在其他什么位置使用过</li>
</ul>
<h3 id="4-10-查找并替换"><a href="#4-10-查找并替换" class="headerlink" title="4.10 查找并替换"></a>4.10 查找并替换</h3><ul>
<li>在 <code>vi</code> 中查找和替换命令需要在 <strong>末行模式</strong> 下执行</li>
<li>记忆命令格式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:%s&#x2F;&#x2F;&#x2F;g</span><br></pre></td></tr></table></figure>

<h4 id="1-全局替换"><a href="#1-全局替换" class="headerlink" title="1) 全局替换"></a>1) 全局替换</h4><ul>
<li><strong>一次性</strong>替换文件中的 <strong>所有出现的旧文本</strong></li>
<li>命令格式如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:%s&#x2F;旧文本&#x2F;新文本&#x2F;g</span><br></pre></td></tr></table></figure>

<h4 id="2-可视区域替换"><a href="#2-可视区域替换" class="headerlink" title="2) 可视区域替换"></a>2) 可视区域替换</h4><ul>
<li><strong>先选中</strong> 要替换文字的 <strong>范围</strong></li>
<li>命令格式如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:s&#x2F;旧文本&#x2F;新文本&#x2F;g</span><br></pre></td></tr></table></figure>

<h4 id="3-确认替换"><a href="#3-确认替换" class="headerlink" title="3) 确认替换"></a>3) 确认替换</h4><ul>
<li>如果把末尾的 <code>g</code> 改成 <code>gc</code> 在替换的时候，会有提示！<strong>推荐使用！</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:%s&#x2F;旧文本&#x2F;新文本&#x2F;gc</span><br></pre></td></tr></table></figure>

<ol>
<li><code>y</code> - <code>yes</code> 替换</li>
<li><code>n</code> - <code>no</code> 不替换</li>
<li><code>a</code> - <code>all</code> 替换所有</li>
<li><code>q</code> - <code>quit</code> 退出替换</li>
<li><code>l</code> - <code>last</code> 最后一个，并把光标移动到行首</li>
<li><code>^E</code> 向下滚屏</li>
<li><code>^Y</code> 向上滚屏</li>
</ol>
<h3 id="4-11-插入命令"><a href="#4-11-插入命令" class="headerlink" title="4.11 插入命令"></a>4.11 插入命令</h3><ul>
<li>在 <code>vi</code> 中除了常用的 <code>i</code> 进入 <strong>编辑模式</strong> 外，还提供了以下命令同样可以进入编辑模式：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
<th align="center">常用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i</td>
<td align="center">insert</td>
<td>在当前字符前插入文本</td>
<td align="center">常用</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">insert</td>
<td>在行首插入文本</td>
<td align="center">较常用</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">append</td>
<td>在当前字符后添加文本</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">A</td>
<td align="center">append</td>
<td>在行末添加文本</td>
<td align="center">较常用</td>
</tr>
<tr>
<td align="center">o</td>
<td align="center"></td>
<td>在当前行后面插入一空行</td>
<td align="center">常用</td>
</tr>
<tr>
<td align="center">O</td>
<td align="center"></td>
<td>在当前行前面插入一空行</td>
<td align="center">常用</td>
</tr>
</tbody></table>
<p><img src="media/14993340485745/004_%E6%8F%92%E5%85%A5%E5%91%BD%E4%BB%A4.png" alt="004_插入命令-w400"></p>
<h4 id="演练-1-——-编辑命令和数字连用"><a href="#演练-1-——-编辑命令和数字连用" class="headerlink" title="演练 1 —— 编辑命令和数字连用"></a>演练 1 —— 编辑命令和数字连用</h4><ul>
<li>在开发中，可能会遇到连续输入 <code>N</code> 个同样的字符</li>
</ul>
<blockquote>
<p>在 <code>Python</code> 中有简单的方法，但是其他语言中通常需要自己输入</p>
</blockquote>
<ul>
<li>例如：<code>**********</code> 连续 10 个星号</li>
</ul>
<p>要实现这个效果可以在 <strong>命令模式</strong> 下</p>
<ol>
<li>输入 <code>10</code>，表示要重复 10 次</li>
<li>输入 <code>i</code> 进入 <strong>编辑模式</strong></li>
<li>输入 <code>*</code> 也就是重复的文字</li>
<li>按下 <code>ESC</code> 返回到 <strong>命令模式</strong>，返回之后 <code>vi</code> 就会把第 <code>2、3</code> 两步的操作重复 <code>10</code> 次</li>
</ol>
<blockquote>
<p>提示：正常开发时，在 <strong>进入编辑模式之前，不要按数字</strong></p>
</blockquote>
<h4 id="演练-2-——-利用-可视块-给多行代码增加注释"><a href="#演练-2-——-利用-可视块-给多行代码增加注释" class="headerlink" title="演练 2 —— 利用 可视块 给多行代码增加注释"></a>演练 2 —— 利用 可视块 给多行代码增加注释</h4><ul>
<li>在开发中，可能会遇到一次性给多行代码 <strong>增加注释</strong> 的情况</li>
</ul>
<blockquote>
<p>在 <code>Python</code> 中，要给代码增加注释，可以在代码前增加一个 <code>#</code></p>
</blockquote>
<p>要实现这个效果可以在 <strong>命令模式</strong> 下</p>
<ol>
<li>移动到要添加注释的 <strong>第 1 行代码</strong>，按 <code>^</code> 来到行首</li>
<li>按 <code>CTRL + v</code> 进入 <strong>可视块</strong> 模式</li>
<li>使用 <code>j</code> 向下连续选中要添加的代码行</li>
<li>输入 <code>I</code> 进入 <strong>编辑模式</strong>，并在 <strong>行首插入</strong>，注意：一定要使用 <strong>I</strong></li>
<li>输入 <code>#</code> 也就是注释符号</li>
<li>按下 <code>ESC</code> 返回到 <strong>命令模式</strong>，返回之后 <code>vi</code> 会在之前选中的每一行代码 <strong>前</strong> 插入 <code>#</code></li>
</ol>
<h2 id="05-分屏命令"><a href="#05-分屏命令" class="headerlink" title="05. 分屏命令"></a>05. 分屏命令</h2><ul>
<li>属于 <code>vi</code> 的高级命令 —— 可以 <strong>同时编辑和查看多个文件</strong></li>
</ul>
<h3 id="5-1-末行命令扩展"><a href="#5-1-末行命令扩展" class="headerlink" title="5.1 末行命令扩展"></a>5.1 末行命令扩展</h3><p><strong>末行命令</strong> 主要是针对文件进行操作的：<strong>保存</strong>、<strong>退出</strong>、<strong>保存&amp;退出</strong>、<strong>搜索&amp;替换</strong>、<strong>另存</strong>、<strong>新建</strong>、<strong>浏览文件</strong></p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">:e .</td>
<td align="center">edit</td>
<td>会打开内置的文件浏览器，浏览要当前目录下的文件</td>
</tr>
<tr>
<td align="center">:n 文件名</td>
<td align="center">new</td>
<td>新建文件</td>
</tr>
<tr>
<td align="center">:w 文件名</td>
<td align="center">write</td>
<td>另存为，但是仍然编辑当前文件，并不会切换文件</td>
</tr>
</tbody></table>
<blockquote>
<p>提示：切换文件之前，必须保证当前这个文件已经被保存！</p>
</blockquote>
<ul>
<li>已经学习过的 <strong>末行命令</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">:w</td>
<td align="center">write</td>
<td>保存</td>
</tr>
<tr>
<td align="center">:q</td>
<td align="center">quit</td>
<td>退出，如果没有保存，不允许退出</td>
</tr>
<tr>
<td align="center">:q!</td>
<td align="center">quit</td>
<td>强行退出，不保存退出</td>
</tr>
<tr>
<td align="center">:wq</td>
<td align="center">write &amp; quit</td>
<td>保存并退出</td>
</tr>
<tr>
<td align="center">:x</td>
<td align="center"></td>
<td>保存并退出</td>
</tr>
<tr>
<td align="center">:%s///gc</td>
<td align="center"></td>
<td>确认搜索并替换</td>
</tr>
</tbody></table>
<blockquote>
<p>在实际开发中，可以使用 <code>w</code> 命令 <strong>阶段性的备份代码</strong></p>
</blockquote>
<h3 id="5-2-分屏命令"><a href="#5-2-分屏命令" class="headerlink" title="5.2 分屏命令"></a>5.2 分屏命令</h3><ul>
<li>使用 <strong>分屏命令</strong>，可以 <strong>同时编辑和查看多个文件</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">:sp [文件名]</td>
<td align="center">split</td>
<td>横向增加分屏</td>
</tr>
<tr>
<td align="center">:vsp [文件名]</td>
<td align="center">vertical split</td>
<td>纵向增加分屏</td>
</tr>
</tbody></table>
<h4 id="1-切换分屏窗口"><a href="#1-切换分屏窗口" class="headerlink" title="1) 切换分屏窗口"></a>1) 切换分屏窗口</h4><blockquote>
<p>分屏窗口都是基于 <code>CTRL + W</code> 这个快捷键的，<code>w</code> 对应的英文单词是 <code>window</code></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">w</td>
<td align="center">window</td>
<td>切换到下一个窗口</td>
</tr>
<tr>
<td align="center">r</td>
<td align="center">reverse</td>
<td>互换窗口</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">close</td>
<td>关闭当前窗口，但是不能关闭最后一个窗口</td>
</tr>
<tr>
<td align="center">q</td>
<td align="center">quit</td>
<td>退出当前窗口，如果是最后一个窗口，则关闭 vi</td>
</tr>
<tr>
<td align="center">o</td>
<td align="center">other</td>
<td>关闭其他窗口</td>
</tr>
</tbody></table>
<h4 id="2-调整窗口大小"><a href="#2-调整窗口大小" class="headerlink" title="2) 调整窗口大小"></a>2) 调整窗口大小</h4><blockquote>
<p>分屏窗口都是基于 <code>CTRL + W</code> 这个快捷键的，<code>w</code> 对应的英文单词是 <code>window</code></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center"></td>
<td>增加窗口高度</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"></td>
<td>减少窗口高度</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center"></td>
<td>增加窗口宽度</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center"></td>
<td>减少窗口宽度</td>
</tr>
<tr>
<td align="center">=</td>
<td align="center"></td>
<td>等分窗口大小</td>
</tr>
</tbody></table>
<blockquote>
<p>调整窗口宽高的命令可以和数字连用，例如：<code>5 CTRL + W +</code> 连续 5 次增加高度</p>
</blockquote>
<h2 id="06-常用命令速查图"><a href="#06-常用命令速查图" class="headerlink" title="06. 常用命令速查图"></a>06. 常用命令速查图</h2><p><img src="media/14993340485745/vim.png" alt="vi"></p>
<h3 id="vimrc"><a href="#vimrc" class="headerlink" title="vimrc"></a>vimrc</h3><ul>
<li><code>vimrc</code> 是 <code>vim</code> 的配置文件，可以设置 vim 的配置，包括：<strong>热键</strong>、<strong>配色</strong>、<strong>语法高亮</strong>、<strong>插件</strong> 等</li>
<li><code>Linux</code> 中 <code>vimrc</code> 有两个位置，<strong>家目录下的配置文件优先级更高</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;vim&#x2F;vimrc</span><br><span class="line">~&#x2F;.vimrc</span><br></pre></td></tr></table></figure>

<ul>
<li>常用的插件有：<ul>
<li>代码补全</li>
<li>代码折叠</li>
<li>搜索</li>
<li>Git 集成</li>
<li>……</li>
</ul>
</li>
<li>网上有很多高手已经配置好的针对 <code>python</code> 开发的 <code>vimrc</code> 文件，可以下载过来直接使用，或者等大家多 <code>Linux</code> 比较熟悉后，再行学习！</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用wpa_supplicant, wpa_cli连接wifi</title>
    <url>/2020/01/04/%E4%BD%BF%E7%94%A8wpa_supplicant%20wpa_cli%E8%BF%9E%E6%8E%A5wifi/</url>
    <content><![CDATA[<p>WIFI on:</p>
<p>adb shell svc wifi enable</p>
<p>WIFI off:</p>
<p>adb shell svc wifi disable</p>
<p><a href="http://blog.sina.com.cn/s/blog_15e89db360102x7qv.html" target="_blank" rel="noopener">使用wpa_supplicant, wpa_cli连接wifi</a></p>
<p>如果对应的命令没有需要从源码编译后，导入到/system/bin目录下，修改权限755<br>dhcpcd目录 \external\dhcpcd-6.8.2<br>wpa_cli  \external\wpa_supplicant_8 编译后会生成该文件  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpa_supplicant.conf目录  </span><br><span class="line">&#x2F;data&#x2F;misc&#x2F;wifi&#x2F;wpa_supplicant.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#&#x2F;system&#x2F;bin&#x2F;sh</span><br><span class="line">ssid&#x3D;$&#123;1&#125;</span><br><span class="line">psk&#x3D;$&#123;2&#125;</span><br><span class="line">svc wifi enable</span><br><span class="line">sleep 6</span><br><span class="line">wpa_cli scan</span><br><span class="line">wpa_cli scan_result</span><br><span class="line">addID&#x3D;&#96;wpa_cli add_net | sed -n &#39;2p&#39;&#96;</span><br><span class="line"></span><br><span class="line">echo $addID</span><br><span class="line">wpa_cli set_net $&#123;addID&#125; ssid &quot;\&quot;$&#123;ssid&#125;\&quot;&quot;</span><br><span class="line">wpa_cli set_net $&#123;addID&#125; psk &quot;\&quot;$&#123;psk&#125;\&quot;&quot;</span><br><span class="line">wpa_cli select_net $&#123;addID&#125;</span><br><span class="line">wpa_cli enable_net $&#123;addID&#125;</span><br><span class="line"></span><br><span class="line">dhcpcd wlan0</span><br></pre></td></tr></table></figure>

<p>debug WifiStateMachine 程序需要debug system process进程</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统源码</tag>
      </tags>
  </entry>
  <entry>
    <title>wz</title>
    <url>/2017/10/04/wz/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Android</category>
        <category>系统源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统源码</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2019/03/20/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><p>确保某个类只有一个实例,并且自行实例化并向整个系统提供这个实例。</p>
<h4 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2.介绍"></a>2.介绍</h4><p>单例模式属于创建类模式。<br>单例模式有以下特点：</p>
<ol>
<li>单例类只能有一个实例。</li>
<li>单例类必须自己创建自己的唯一实例。</li>
<li>单例类必须给所有其他对象提供这一实例。</li>
</ol>
<h4 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h4><h5 id="3-4-饿汉式"><a href="#3-4-饿汉式" class="headerlink" title="3.4 饿汉式"></a>3.4 饿汉式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;单例类.   </span><br><span class="line">public class Singleton &#123;</span><br><span class="line">    </span><br><span class="line">    private Singleton() &#123;&#x2F;&#x2F;构造方法为private,防止外部代码直接通过new来构造多个对象</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final Singleton single &#x3D; new Singleton();  &#x2F;&#x2F;在类初始化时，已经自行实例化,所以是线程安全的。</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;  &#x2F;&#x2F;通过getInstance()方法获取实例对象</span><br><span class="line">        return single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：写法简单，线程安全。</li>
<li>缺点：没有懒加载的效果，如果没有使用过的话会造成内存浪费。</li>
</ul>
<h5 id="3-1-懒汉式（线程不安全）"><a href="#3-1-懒汉式（线程不安全）" class="headerlink" title="3.1 懒汉式（线程不安全）"></a>3.1 懒汉式（线程不安全）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;单例类</span><br><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Singleton single &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (single &#x3D;&#x3D; null) &#123;</span><br><span class="line">            single &#x3D; new Singleton();  &#x2F;&#x2F;在第一次调用getInstance()时才实例化，实现懒加载,所以叫懒汉式</span><br><span class="line">        &#125;</span><br><span class="line">        return single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：实现了懒加载的效果。</li>
<li>缺点：线程不安全。</li>
</ul>
<h5 id="3-1-懒汉式（线程安全）"><a href="#3-1-懒汉式（线程安全）" class="headerlink" title="3.1 懒汉式（线程安全）"></a>3.1 懒汉式（线程安全）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;单例类</span><br><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Singleton single &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public static synchronized Singleton getInstance() &#123; &#x2F;&#x2F;加上synchronized同步 </span><br><span class="line">        if (single &#x3D;&#x3D; null) &#123;</span><br><span class="line">            single &#x3D; new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>优点：实现了懒加载的效果，线程安全。</li>
<li>缺点：使用synchronized会造成不必要的同步开销，而且大部分时候我们是用不到同步的。</li>
</ul>
<h5 id="3-3-双重检查锁定（DCL）"><a href="#3-3-双重检查锁定（DCL）" class="headerlink" title="3.3 双重检查锁定（DCL）"></a>3.3 双重检查锁定（DCL）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private volatile static Singleton singleton; &#x2F;&#x2F;volatile 能够防止代码的重排序，保证得到的对象是初始化过</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getSingleton() &#123;</span><br><span class="line">        if (singleton &#x3D;&#x3D; null) &#123;  &#x2F;&#x2F;第一次检查，避免不必要的同步</span><br><span class="line">            synchronized (Singleton.class) &#123;  &#x2F;&#x2F;同步</span><br><span class="line">                if (singleton &#x3D;&#x3D; null) &#123;   &#x2F;&#x2F;第二次检查，为null时才创建实例</span><br><span class="line">                    singleton &#x3D; new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>优点：懒加载，线程安全，效率较高</li>
<li>缺点：volatile影响一点性能，高并发下有一定的缺陷，某些情况下DCL会失效，虽然概率较小。</li>
</ul>
<h5 id="3-5-静态内部类"><a href="#3-5-静态内部类" class="headerlink" title="3.5 静态内部类"></a>3.5 静态内部类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        &#x2F;&#x2F;第一次调用getInstance方法时才加载SingletonHolder并初始化sInstance</span><br><span class="line">        return SingletonHolder.sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;静态内部类</span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final Singleton sInstance &#x3D; new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>优点：懒加载，线程安全，推荐使用</p>
<h5 id="3-6-枚举单例"><a href="#3-6-枚举单例" class="headerlink" title="3.6 枚举单例"></a>3.6 枚举单例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;   &#x2F;&#x2F;定义一个枚举的元素，它就是Singleton的一个实例</span><br><span class="line"></span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优点：线程安全，写法简单，能防止反序列化重新创建新的对象。</li>
<li>缺点：可读性不高，枚举会比静态常量多那么一丁点的内存。</li>
</ul>
<h5 id="3-7-使用容器实现单例模式"><a href="#3-7-使用容器实现单例模式" class="headerlink" title="3.7 使用容器实现单例模式"></a>3.7 使用容器实现单例模式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;单例管理类</span><br><span class="line">public class SingletonManager &#123;</span><br><span class="line">    private static Map&lt;String, Object&gt; objMap &#x3D; new HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    public static void registerService(String key, Object instance) &#123;</span><br><span class="line">        if (!objMap.containsKey(key)) &#123;</span><br><span class="line">            objMap.put(key, instance);&#x2F;&#x2F;添加单例</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object getService(String key) &#123;</span><br><span class="line">        return objMap.get(key);&#x2F;&#x2F;获取单例</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优点：方便管理。</li>
<li>缺点：写法稍复杂。</li>
</ul>
<h4 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a>4.注意事项</h4><p>使用反射能够破坏单例模式，所以应该慎用反射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Constructor con &#x3D; Singleton.class.getDeclaredConstructor();</span><br><span class="line">    con.setAccessible(true);</span><br><span class="line">    &#x2F;&#x2F; 通过反射获取实例</span><br><span class="line">    Singleton singeton1 &#x3D; (Singleton) con.newInstance();</span><br><span class="line">    Singleton singeton2 &#x3D; (Singleton) con.newInstance();</span><br><span class="line">    System.out.println(singeton1&#x3D;&#x3D;singeton2);&#x2F;&#x2F;结果为false,singeton1和singeton2将是两个不同的实例</span><br></pre></td></tr></table></figure>



<p>可以通过当第二次调用构造函数时抛出异常来防止反射破坏单例，以懒汉式为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static boolean flag &#x3D; true;</span><br><span class="line">    private static Singleton single &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            flag &#x3D; !flag;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new RuntimeException(&quot;单例模式被破坏！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (single &#x3D;&#x3D; null) &#123;</span><br><span class="line">            single &#x3D; new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>反序列化时也会破坏单例模式，可以通过重写readResolve方法避免，以饿汉式为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton implements Serializable &#123;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final Singleton single &#x3D; new Singleton();</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return single;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object readResolve() throws ObjectStreamException &#123;&#x2F;&#x2F;重写readResolve()</span><br><span class="line">        return single;&#x2F;&#x2F;直接返回单例对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5.应用场景"></a>5.应用场景</h5><ul>
<li>频繁访问数据库或文件的对象。</li>
<li>工具类对象；</li>
<li>创建对象时耗时过多或耗费资源过多，但又经常用到的对象；</li>
</ul>
<h5 id="6-优点"><a href="#6-优点" class="headerlink" title="6.优点"></a>6.优点</h5><ul>
<li>内存中只存在一个对象，节省了系统资源。</li>
<li>避免对资源的多重占用，例如一个文件操作，由于只有一个实例存在内存中，避免对同一资源文件的同时操作。</li>
</ul>
<h5 id="7-缺点"><a href="#7-缺点" class="headerlink" title="7.缺点"></a>7.缺点</h5><ul>
<li>获取对象时不能用new</li>
<li>单例对象如果持有Context，那么很容易引发内存泄露。</li>
<li>单例模式一般没有接口，扩展很困难，若要扩展，只能修改代码来实现。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>六大原则</title>
    <url>/2019/03/20/%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/bf92927c9d22" target="_blank" rel="noopener">https://www.jianshu.com/p/bf92927c9d22</a></p>
<h4 id="面向对象的六大原则"><a href="#面向对象的六大原则" class="headerlink" title="面向对象的六大原则"></a>面向对象的六大原则</h4><h5 id="1-单一职责原则（Single-Responsibility-Principle-SRP）"><a href="#1-单一职责原则（Single-Responsibility-Principle-SRP）" class="headerlink" title="1.单一职责原则（Single Responsibility Principle, SRP）"></a>1.单一职责原则（Single Responsibility Principle, SRP）</h5><p>定义：一个类应只包含单一的职责。</p>
<ul>
<li>一个类职责过大的话，首先引起的问题就是这个类比较大，显得过于臃肿，同时其复用性是比较差的。</li>
<li>其次就是如果修改某个职责，有可能引起另一个职责发生错误。这是我们极力所避免的，因此设计一个类时我们应当去遵循单一职责原则。</li>
</ul>
<h5 id="2-开放封闭原则-Open-ClosedPrinciple-OCP"><a href="#2-开放封闭原则-Open-ClosedPrinciple-OCP" class="headerlink" title="2.开放封闭原则(Open - ClosedPrinciple ,OCP)"></a>2.开放封闭原则(Open - ClosedPrinciple ,OCP)</h5><p>定义：一个模块、类、函数应当是对修改关闭，扩展开放。</p>
<ul>
<li>修改原有的代码可能会导致原本正常的功能出现问题。</li>
<li>因此，当需求有变化时，最好是通过扩展来实现，增加新的方法满足需求，而不是去修改原有代码。</li>
</ul>
<h5 id="3-里氏代换原则-Liskov-Substitution-Principle-LSP"><a href="#3-里氏代换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="3.里氏代换原则( Liskov Substitution Principle ,LSP )"></a>3.里氏代换原则( Liskov Substitution Principle ,LSP )</h5><p>定义：使用父类的地方能够使用子类来替换，反过来，则不行。</p>
<ul>
<li>使用子类对象去替换父类对象，程序将不会产生错误</li>
<li>因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</li>
<li>需要注意的是：</li>
</ul>
<ol>
<li>子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。如果一个方法只存在子类中，没有在父类中声明，则无法在以父类定义的对象中使用该方法。</li>
<li>父类应当被尽量设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现</li>
</ol>
<h5 id="4-依赖倒置原则-Dependence-Inversion-Principle-DIP"><a href="#4-依赖倒置原则-Dependence-Inversion-Principle-DIP" class="headerlink" title="4.依赖倒置原则( Dependence Inversion Principle ,DIP )"></a>4.依赖倒置原则( Dependence Inversion Principle ,DIP )</h5><p>定义：抽象不应该依赖于细节，细节应当依赖于抽象。</p>
<ul>
<li>即要面向接口编程，而不是面向具体实现去编程。</li>
<li>高层模块不应该依赖低层模块，应该去依赖抽象。</li>
</ul>
<h5 id="5-接口隔离原则-Interface-Segregation-Principle，ISL）"><a href="#5-接口隔离原则-Interface-Segregation-Principle，ISL）" class="headerlink" title="5.接口隔离原则(Interface Segregation Principle，ISL）"></a>5.接口隔离原则(Interface Segregation Principle，ISL）</h5><p>定义：一个类对另一个类的依赖应该建立在最小的接口上。</p>
<ul>
<li>一个类不应该依赖他不需要的接口。</li>
<li>接口的粒度要尽可能小，如果一个接口的方法过多，可以拆成多个接口。</li>
</ul>
<h5 id="6-迪米特原则-Law-of-Demeter-LoD"><a href="#6-迪米特原则-Law-of-Demeter-LoD" class="headerlink" title="6.迪米特原则(Law of  Demeter, LoD)"></a>6.迪米特原则(Law of  Demeter, LoD)</h5><p>定义：一个类尽量不要与其他类发生关系</p>
<ul>
<li>一个类对其他类知道的越少，耦合越小。</li>
<li>当修改一个类时，其他类的影响就越小，发生错误的可能性就越小。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓系统签名转keystore</title>
    <url>/2019/10/18/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E7%AD%BE%E5%90%8D%E8%BD%ACkeystore/</url>
    <content><![CDATA[<p> 单独签名解决方案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">找到平台签名文件“platform.pk8”和“platform.x509.pem”</span><br><span class="line"></span><br><span class="line">文件位置 android&#x2F;build&#x2F;target&#x2F;product&#x2F;security&#x2F;</span><br></pre></td></tr></table></figure>




<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">签名工具“signapk.jar”</span><br><span class="line"></span><br><span class="line">位置：android&#x2F;prebuilts&#x2F;sdk&#x2F;tools&#x2F;lib</span><br></pre></td></tr></table></figure>




<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">签名证书“platform.pk8 ”“platform.x509.pem ”，签名工具“signapk.jar ”放置在同一个文件夹；</span><br></pre></td></tr></table></figure>

<p> 下载 keytool-importkeypair 工具，使用sdk的security文件生成对应平台的key：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;keytool-importkeypair -k [jks文件名] -p [jks的密码] -pk8 platform.pk8 -cert platform.x509.pem -alias [jks的别名]</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line">.&#x2F;keytool-importkeypair -k .&#x2F;SignDemo.jks -p 123456 -pk8 platform.pk8 -cert platform.x509.pem -alias SignDemo</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统源码</tag>
      </tags>
  </entry>
  <entry>
    <title>时序图语法</title>
    <url>/2020/02/04/%E6%97%B6%E5%BA%8F%E5%9B%BE%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p><a href="http://archive.3zso.com/archives/plantuml-quickstart.html#sec-5-4-1" target="_blank" rel="noopener">使用Emacs敲出UML，PlantUML快速指南</a><br><a href="https://blog.csdn.net/junhuahouse/article/details/80753374" target="_blank" rel="noopener">PlantUML 之时序图</a>  </p>
<h3 id="顺序图（Sequence-Diagram）"><a href="#顺序图（Sequence-Diagram）" class="headerlink" title="顺序图（Sequence Diagram）"></a>顺序图（Sequence Diagram）</h3><p>简单示例<br>顺序图用 -&gt; , –&gt;, &lt;-, &lt;– 来绘制参与者（Participants）之 间的消息（Message）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">hide footbox</span><br><span class="line">title login by token</span><br><span class="line"></span><br><span class="line">  Alice -&gt; Bob: Authentication Request</span><br><span class="line">  Bob --&gt; Alice: Authentication Response</span><br><span class="line"></span><br><span class="line">  Alice -&gt; Bob: Another atuhentication Request</span><br><span class="line">  Alice &lt;-- Bob: Another authentication Response</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p><img src="http://archive.3zso.com/img/plantuml-quickstart-s1.png" alt="image"></p>
<h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><p>分为行注解使用英文符号 ‘+行内容<br>多行注解使用英文符号/‘ + 内容 + ‘/ </p>
<h3 id="申明参与者"><a href="#申明参与者" class="headerlink" title="申明参与者"></a>申明参与者</h3><p>申明参与者，可以使用 participant 关键词，也可以使用下面的参与者   分类关键词来申明参与者：  </p>
<ul>
<li>actor</li>
<li>boundary</li>
<li>control</li>
<li>entity</li>
<li>database  </li>
</ul>
<p><strong>不同的参与者类型，其图标也是不一样的</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">hide footbox</span><br><span class="line">actor actor #red</span><br><span class="line">boundary boundary #yellow</span><br><span class="line">control control #blue</span><br><span class="line">entity entity #green</span><br><span class="line">database database #EE4000</span><br><span class="line">&quot;学术袁&quot; -&gt; Blog :方形</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p><img src="http://archive.3zso.com/img/plantuml-quickstart-s2.png" alt="image"></p>
<p>使用 as 关键词可以为参与者起一个别名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">participant &quot;I have a really\nlong name&quot; as L #99ff99</span><br></pre></td></tr></table></figure>
<h3 id="改变箭头的样式（Change-arrow-style）"><a href="#改变箭头的样式（Change-arrow-style）" class="headerlink" title="改变箭头的样式（Change arrow style）"></a>改变箭头的样式（Change arrow style）</h3><p>在用例图里可以通过以下方式来改变箭头的样式：</p>
<p>使用 \ 或 / 来替换 &lt; 或 &gt; 可以让箭头只显示上半部分或下半 部分。<br>重复输入箭头或斜杠（ &gt;&gt; // ），用来绘制空心箭头。<br>使用双横线 – 替代 - 可以用来绘制点线。<br>在箭头后面加个 o 可以在箭头前绘制一个圆圈。<br>使用 &lt;-&gt; 可用来绘制双向箭头。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bob -&gt; Alice</span><br><span class="line">Bob -&gt;&gt; Alice</span><br><span class="line">Bob -\ Alice</span><br><span class="line">Bob \\- Alice</span><br><span class="line">Bob &#x2F;&#x2F;-- Alice</span><br><span class="line"></span><br><span class="line">Bob -&gt;o Alice</span><br><span class="line">Bob o\\-- Alice</span><br><span class="line"></span><br><span class="line">Bob &lt;-&gt; Alice</span><br><span class="line">Bob &lt;&lt;-\\o Alice</span><br></pre></td></tr></table></figure>
<p><img src="http://archive.3zso.com/img/plantuml-quickstart-s6.png" alt="image"></p>
<h3 id="改变箭头的颜色（Change-arrow-color）"><a href="#改变箭头的颜色（Change-arrow-color）" class="headerlink" title="改变箭头的颜色（Change arrow color）"></a>改变箭头的颜色（Change arrow color）</h3><p>要改变箭头的颜色，可以使用HTML颜色符号，参看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bob -[#red]&gt; Alice : hello</span><br><span class="line"> Alice -[#0000FF]-&gt;Bob : ok</span><br></pre></td></tr></table></figure>
<p><img src="http://archive.3zso.com/img/plantuml-quickstart-s7.png" alt="image"></p>
<h3 id="消息序号（Message-sequence-numbering）"><a href="#消息序号（Message-sequence-numbering）" class="headerlink" title="消息序号（Message sequence numbering）"></a>消息序号（Message sequence numbering）</h3><p>关键词 autonumber 用来给自动的给消息添加上序号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">autonumber</span><br><span class="line"> Bob -&gt; Alice : Authentication Request</span><br><span class="line"> Bob &lt;- Alice : Authentication Response</span><br><span class="line"></span><br><span class="line"> autonumber 15</span><br><span class="line"> Bob -&gt; Alice : Another authentication Request</span><br><span class="line"> Bob &lt;- Alice : Another authentication Response</span><br><span class="line"></span><br><span class="line"> autonumber 40 10</span><br><span class="line"> Bob -&gt; Alice : Yet another authentication Request</span><br><span class="line"> Bob &lt;- Alice : Yet another authentication Response</span><br></pre></td></tr></table></figure>
<p><img src="http://archive.3zso.com/img/plantuml-quickstart-s9.png" alt="image"></p>
<h3 id="标题（Title）"><a href="#标题（Title）" class="headerlink" title="标题（Title）"></a>标题（Title）</h3><p>要给图形加一个标题可以用 title 关键词来设置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title Simple Comunication example</span><br></pre></td></tr></table></figure>
<p><img src="http://archive.3zso.com/img/plantuml-quickstart-s11.png" alt="image"></p>
<h3 id="消息分组（Grouping-message）"><a href="#消息分组（Grouping-message）" class="headerlink" title="消息分组（Grouping message）"></a>消息分组（Grouping message）</h3><p>有时候可能需要对消息进行分组，那么可以使用下面的关键词来实现：</p>
<ul>
<li>alt/else</li>
<li>opt</li>
<li>loop</li>
<li>par</li>
<li>break</li>
<li>critical</li>
<li>group<br>这个关键词后面的文字会作为组名显示在图形上<br>上面的关键词后可以添加一些文本用来显示在头部（注： group 除外，因 为它后面的文本用来显示在组名称的位置）。在组嵌套组的结构里可以用关 键词 end 来关闭组或者说是表示一个组符号的结束符（类似 if/endif ）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alice -&gt; Bob: Authentication Request</span><br><span class="line"></span><br><span class="line"> alt successful case</span><br><span class="line">   Bob -&gt; Alice: Authentication Accepted</span><br><span class="line"> else some kind of failure</span><br><span class="line">   Bob -&gt; Alice: Atuhentication Failue</span><br><span class="line">   group My own label</span><br><span class="line">     Alice -&gt; Log : Log attack start</span><br><span class="line">     loop 1000 times</span><br><span class="line">       Alice -&gt; Bob: DNS Attack</span><br><span class="line">     end</span><br><span class="line">     Alice -&gt; Log : Loag alice end</span><br><span class="line">   end</span><br><span class="line"> else Another type of failue</span><br><span class="line">   Bob -&gt; Alice: Please repeat</span><br><span class="line"> end</span><br></pre></td></tr></table></figure>
<p><img src="http://archive.3zso.com/img/plantuml-quickstart-s14.png" alt="image"></p>
<h3 id="消息注解（Notes-on-messages）"><a href="#消息注解（Notes-on-messages）" class="headerlink" title="消息注解（Notes on messages）"></a>消息注解（Notes on messages）</h3><p>我们可能经常会在消息的左边或右边使用注解，要添加注解，只要使用 note left 或 note right 关键词就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alice -&gt; Bob : hello</span><br><span class="line">  note left: this is a first note</span><br><span class="line"></span><br><span class="line">  Bob -&gt; Alice : ok</span><br><span class="line">  note right: this is anther note</span><br><span class="line"></span><br><span class="line">  Bob -&gt; Bob : I am thinking</span><br><span class="line">  note left</span><br><span class="line">       a note</span><br><span class="line">       can also be defined</span><br><span class="line">       on several lines</span><br><span class="line">  end note</span><br></pre></td></tr></table></figure>
<p><img src="http://archive.3zso.com/img/plantuml-quickstart-s15.png" alt="image"></p>
<h3 id="一些其他的注解方式（Some-other-notes）"><a href="#一些其他的注解方式（Some-other-notes）" class="headerlink" title="一些其他的注解方式（Some other notes）"></a>一些其他的注解方式（Some other notes）</h3><p>通过使用关键词 note left of ， note right of 或 note over ， 我们还可以把注解放置在与之相关的参与者的左边或右边，或下方。</p>
<p>通过改变注解的背景色，我们还可以高亮一个注解文本块。</p>
<p>如果要使用多行注解，可以使用关键词 end note 来表示注解的结束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">participant Alice</span><br><span class="line"> participant Bob</span><br><span class="line"> note left of Alice #aqua</span><br><span class="line">      This is displayed</span><br><span class="line">      left of Alice.</span><br><span class="line"> end note</span><br><span class="line"></span><br><span class="line"> note right of Alice: This is displayed right of Alice.</span><br><span class="line"></span><br><span class="line"> note over Alice: This displayed over Alice.</span><br><span class="line"></span><br><span class="line"> note over Alice, Bob #FFAAAA: This is displayed\n over Bob and Alice.</span><br><span class="line"></span><br><span class="line"> note over Bob, Alice</span><br><span class="line">      This is yet another</span><br><span class="line">      example of</span><br><span class="line">      a long note.</span><br><span class="line"> end note</span><br></pre></td></tr></table></figure>
<p><img src="http://archive.3zso.com/img/plantuml-quickstart-s16.png" alt="image"></p>
<h3 id="使用HTML进行格式化（Formatting-using-HTML）"><a href="#使用HTML进行格式化（Formatting-using-HTML）" class="headerlink" title="使用HTML进行格式化（Formatting using HTML）"></a>使用HTML进行格式化（Formatting using HTML）</h3><p>我们可以使用少量的HTML标签来格式化文本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;b&gt; 加粗文本</span><br><span class="line">&lt;u&gt; 或 &lt;u:#AAAAAA&gt; 或 &lt;u:colorName&gt; 用来加下划线</span><br><span class="line">&lt;i&gt; 斜体</span><br><span class="line">&lt;s&gt; 或 &lt;s:#AAAAAA&gt; 或 &lt;s:colorName&gt; 用来加删除线</span><br><span class="line">&lt;w&gt; 或 &lt;w:#AAAAAA&gt; 或 &lt;w:colorName&gt; 用来加波浪线</span><br><span class="line">&lt;color:#AAAAAA&gt; 或 &lt;color:colorName&gt; 用来设置文本颜色</span><br><span class="line">&lt;back:#AAAAAA&gt; 或 &lt;back:colorName&gt; 用来设置背景色</span><br><span class="line">&lt;size:nn&gt; 设置字体大小</span><br><span class="line">&lt;img src&#x3D;&quot;file&quot;&gt; 或 &lt;img:file&gt; 用来添加图片，图片文件必须 是可以访问得到才行。</span><br><span class="line">&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;url&quot;&gt; 或 &lt;img:http:&#x2F;&#x2F;url&gt; 用来添加一个互 联网图片，同样的图片地址必须是可用的才行。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">participant Alice</span><br><span class="line"> participant &quot;The &lt;b&gt;Famous&lt;&#x2F;b&gt; Bob&quot; as Bob</span><br><span class="line"></span><br><span class="line"> Alice -&gt; Bob : A &lt;i&gt;well formated&lt;&#x2F;i&gt; message</span><br><span class="line"> note right of Alice</span><br><span class="line">   This is &lt;back:cadetblue&gt;&lt;size:18&gt;displayed&lt;&#x2F;size&gt;&lt;&#x2F;back&gt;</span><br><span class="line">   &lt;u&gt;left of&lt;&#x2F;u&gt; Alice.</span><br><span class="line"> end note</span><br><span class="line"> note left of Bob</span><br><span class="line">   &lt;u:red&gt;This&lt;&#x2F;u&gt; is &lt;color #118888&gt;displayed&lt;&#x2F;color&gt;</span><br><span class="line">   &lt;b&gt;&lt;color purple&gt;left of&lt;&#x2F;color&gt; &lt;s:red&gt;Alice&lt;&#x2F;strike&gt; Bob&lt;&#x2F;b&gt;</span><br><span class="line"> end note</span><br><span class="line"> note over Alice, Bob</span><br><span class="line">   &lt;w:#FF33FF&gt;This is hosted&lt;&#x2F;w&gt; by &lt;img ..&#x2F;img&#x2F;code.png&gt;</span><br><span class="line"> end note</span><br></pre></td></tr></table></figure>
<p><img src="http://archive.3zso.com/img/plantuml-quickstart-s17.png" alt="image"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>UML</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2018/03/16/%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方 法，而&lt;? super T&gt;不能使用 get 方法，作为接口调用赋值时易出错。<br>说明：扩展说一下 PECS(Producer Extends Consumer Super)原则：第一、频繁往外读取内<br>容的，适合用&lt;? extends T&gt;。第二、经常往里插入的，适合用&lt;? super T&gt;。</p>
<h5 id="泛型类的最基本写法"><a href="#泛型类的最基本写法" class="headerlink" title="泛型类的最基本写法"></a>泛型类的最基本写法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123;</span><br><span class="line">  private 泛型标识 &#x2F;*（成员变量类型）*&#x2F; var; </span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个最普通的泛型类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br><span class="line">&#x2F;&#x2F;在实例化泛型类时，必须指定T的具体类型</span><br><span class="line">public class Generic&lt;T&gt;&#123; </span><br><span class="line">    &#x2F;&#x2F;key这个成员变量的类型为T,T的类型由外部指定  </span><br><span class="line">    private T key;</span><br><span class="line"></span><br><span class="line">    public Generic(T key) &#123; &#x2F;&#x2F;泛型构造方法形参key的类型也为T，T的类型由外部指定</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getKey()&#123; &#x2F;&#x2F;泛型方法getKey的返回值类型为T，T的类型由外部指定</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span><br><span class="line">&#x2F;&#x2F;传入的实参类型需与泛型的类型参数类型相同，即为Integer.</span><br><span class="line">Generic&lt;Integer&gt; genericInteger &#x3D; new Generic&lt;Integer&gt;(123456);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;传入的实参类型需与泛型的类型参数类型相同，即为String.</span><br><span class="line">Generic&lt;String&gt; genericString &#x3D; new Generic&lt;String&gt;(&quot;key_vlaue&quot;);</span><br><span class="line">Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericInteger.getKey());</span><br><span class="line">Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericString.getKey());</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意：</span><br><span class="line"></span><br><span class="line">泛型的类型参数只能是类类型，不能是简单类型。</span><br><span class="line">不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。</span><br><span class="line"></span><br><span class="line">if(ex_num instanceof Generic&lt;Number&gt;)&#123;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个泛型接口</span><br><span class="line">public interface Generator&lt;T&gt; &#123;</span><br><span class="line">    public T next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当实现泛型接口的类，未传入泛型实参时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span><br><span class="line"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span><br><span class="line"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public T next() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当实现泛型接口的类，传入泛型实参时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 传入泛型实参时：</span><br><span class="line"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span><br><span class="line"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span><br><span class="line"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span><br><span class="line"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class FruitGenerator implements Generator&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private String[] fruits &#x3D; new String[]&#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String next() &#123;</span><br><span class="line">        Random rand &#x3D; new Random();</span><br><span class="line">        return fruits[rand.nextInt(3)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T这个T可以出现在这个泛型方法的任意位置.</span><br><span class="line">泛型的数量也可以为任意多个如：</span><br><span class="line">public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span><br><span class="line">             ...</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛型方法与可变参数"><a href="#泛型方法与可变参数" class="headerlink" title="泛型方法与可变参数"></a>泛型方法与可变参数</h4><p>泛型方法和可变参数的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printMsg</span><span class="params">( T... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(T t : args)&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"t is "</span> + t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printMsg(<span class="string">"111"</span>,<span class="number">222</span>,<span class="string">"aaaa"</span>,<span class="string">"2323.4"</span>,<span class="number">55.55</span>);</span><br></pre></td></tr></table></figure>
<h4 id="静态方法与泛型"><a href="#静态方法与泛型" class="headerlink" title="静态方法与泛型"></a>静态方法与泛型</h4><p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：==静态方法无法访问类上定义的泛型==；<br>如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。<br>即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticGenerator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span></span><br><span class="line"><span class="comment">     * 即使静态方法要使用泛型类中已经声明过的泛型也不行。</span></span><br><span class="line"><span class="comment">     * 如：public static void show(T t)&#123;..&#125;,</span></span><br><span class="line"><span class="comment">     *此时编译器会提示错误信息：</span></span><br><span class="line"><span class="comment">     *  "StaticGenerator cannot be refrenced from *static context"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型上下边界"><a href="#泛型上下边界" class="headerlink" title="泛型上下边界"></a>泛型上下边界</h3><h5 id="泛型类的例子"><a href="#泛型类的例子" class="headerlink" title="泛型类的例子"></a>泛型类的例子</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="泛型方法的例子："><a href="#泛型方法的例子：" class="headerlink" title="泛型方法的例子："></a>泛型方法的例子：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加</span></span><br><span class="line"><span class="comment">//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错："Unexpected bound"</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">    T test = container.getKey();</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛型方法的类型推断"><a href="#泛型方法的类型推断" class="headerlink" title="泛型方法的类型推断"></a>泛型方法的类型推断</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**不指定泛型的时候*/</span>  </span><br><span class="line"> <span class="keyword">int</span> i=Test.add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//这两个参数都是Integer，所以T替换为Integer类型  </span></span><br><span class="line">Number f=Test.add(<span class="number">1</span>, <span class="number">1.2</span>);<span class="comment">//这两个参数一个是Integer，另一个是Float，所以取同一父类的最小级，为Number  </span></span><br><span class="line">Object o=Test.add(<span class="number">1</span>, <span class="string">"asd"</span>);<span class="comment">//这两个参数一个是Integer，另一个是String，所以取同一父类的最小级，为Object</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/**指定泛型的时候*/</span>  </span><br><span class="line"><span class="keyword">int</span> a=Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//指定了Integer，所以只能为Integer类型或者其子类  </span></span><br><span class="line"><span class="keyword">int</span> b=Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2.2</span>);<span class="comment">//编译错误，指定了Integer，不能为Float  </span></span><br><span class="line">Number c=Test.&lt;Number&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//指定为Number，所以可以为Integer和Float  </span></span><br><span class="line">      </span><br><span class="line"><span class="comment">//这是一个简单的泛型方法  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">add</span><span class="params">(T x,T y)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> y;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>编译期间，所有的泛型信息都会被擦除,List<Integer>和List<String>类型，在编译后都会变成List类型（原始类型）.  </p>
<h5 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h5><p>原始类型就是泛型类型擦除了泛型信息后，在字节码中真正的类型。无论何时定义一个泛型类型，相应的原始类型都会被自动提供。原始类型的名字就是删去类型参数后的泛型类型的类名。擦除类型变量，并替换为限定类型（T为无限定的类型变量，用Object替换）<br><strong>因为在Pair<T>中，T是一个无限定的类型变量，所以用Object替换。<br>如果是Pair<T extends Number>，擦除后，类型变量用Number类型替换</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; array=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">array.add(<span class="number">1</span>);<span class="comment">//这样调用add方法只能存储整形，因为泛型类型的实例为Integer  </span></span><br><span class="line">array.getClass().getMethod("add", Object.class).invoke(array, "asd");  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.size();i++) &#123;  </span><br><span class="line">    System.out.println(array.get(i));  </span><br><span class="line">    &#125;  </span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span></span><br><span class="line">asd</span><br></pre></td></tr></table></figure>

<h2 id="PECS法则"><a href="#PECS法则" class="headerlink" title="PECS法则"></a>PECS法则</h2><p>PECS法则：生产者（Producer）使用extends，消费者（Consumer）使用super</p>
<h6 id="1、生产者"><a href="#1、生产者" class="headerlink" title="1、生产者"></a>1、生产者</h6><p>如果你需要一个提供E类型元素的集合，使用泛型通配符&lt;? extends E&gt;。它好比一个生产者，可以提供数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Number&gt; list&#x3D;new ArrayList();</span><br><span class="line">list.add(new Integer(1));&#x2F;&#x2F;编译错误</span><br><span class="line">list.add(new Float(1.0));&#x2F;&#x2F;编译错误</span><br><span class="line"></span><br><span class="line">List&lt;? extends Number&gt; list1&#x3D;new ArrayList&lt;Integer&gt;();</span><br><span class="line">List&lt;? extends Number&gt; list2&#x3D;new ArrayList&lt;Float&gt;();</span><br></pre></td></tr></table></figure>

<h5 id="2、消费者"><a href="#2、消费者" class="headerlink" title="2、消费者"></a>2、消费者</h5><p>如果你需要一个只能装入E类型元素的集合，使用泛型通配符&lt;? super E&gt;。它好比一个消费者，可以消费你提供的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;? super Number&gt; list&#x3D;new ArrayList(); </span><br><span class="line">list.add(new Integer(1));</span><br><span class="line">list.add(new Float(1.1));</span><br></pre></td></tr></table></figure>

<h5 id="3、既是生产者也是消费者"><a href="#3、既是生产者也是消费者" class="headerlink" title="3、既是生产者也是消费者"></a>3、既是生产者也是消费者</h5><p>既要存储又要读取，那就别使用泛型通配符。</p>
<h2 id="泛型相关问题"><a href="#泛型相关问题" class="headerlink" title="泛型相关问题"></a>泛型相关问题</h2><h4 id="1、泛型类型引用传递问题"><a href="#1、泛型类型引用传递问题" class="headerlink" title="1、泛型类型引用传递问题"></a>1、泛型类型引用传递问题</h4><p>在Java中，像下面形式的引用传递是不允许的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList1=<span class="keyword">new</span> ArrayList&lt;Object&gt;();<span class="comment">//编译错误  </span></span><br><span class="line">ArrayList&lt;Object&gt; arrayList1=<span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>
<h6 id="第一种情况，将第一种情况拓展成下面的形式："><a href="#第一种情况，将第一种情况拓展成下面的形式：" class="headerlink" title="第一种情况，将第一种情况拓展成下面的形式："></a>第一种情况，将第一种情况拓展成下面的形式：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; arrayList1=<span class="keyword">new</span> ArrayList&lt;Object&gt;();  </span><br><span class="line">          arrayList1.add(<span class="keyword">new</span> Object());  </span><br><span class="line">          arrayList1.add(<span class="keyword">new</span> Object());  </span><br><span class="line">          ArrayList&lt;String&gt; arrayList2=arrayList1;<span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>

<p>在第4行代码处，就会有编译错误。那么，先假设它编译没错。那么当我们使用arrayList2引用用get()方法取值的时候，返回的都是String类型的对象，可是它里面实际上已经存放了Object类型的对象，这样，就会有ClassCastException了。  </p>
<h6 id="在看第二种情况，将第二种情况拓展成下面的形式："><a href="#在看第二种情况，将第二种情况拓展成下面的形式：" class="headerlink" title="在看第二种情况，将第二种情况拓展成下面的形式："></a>在看第二种情况，将第二种情况拓展成下面的形式：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList1=<span class="keyword">new</span> ArrayList&lt;String&gt;();  </span><br><span class="line">          arrayList1.add(<span class="keyword">new</span> String());  </span><br><span class="line">          arrayList1.add(<span class="keyword">new</span> String());  </span><br><span class="line">          ArrayList&lt;Object&gt; arrayList2=arrayList1;<span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>
<p>这样的情况比第一种情况好的多，最起码，用arrayList2取值的时候不会出现ClassCastException，因为是从String转换为Object。可是，这样做有什么意义呢，泛型出现的原因，就是为了解决类型转换的问题。我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以java不允许这么干。再说，如果又用arrayList2往里面add()新的对象，那么到时候取得时候，我怎么知道我取出来的到底是String类型的，还是Object类型的呢？<br>所以，要格外注意泛型中引用传递问题。</p>
<h4 id="2、泛型类型变量不能是基本数据类型"><a href="#2、泛型类型变量不能是基本数据类型" class="headerlink" title="2、泛型类型变量不能是基本数据类型"></a>2、泛型类型变量不能是基本数据类型</h4><p>比如，没有ArrayList<double>，只有ArrayList<Double>。因为当类型擦除后，ArrayList的原始类中的类型变量（T）替换为Object，但Object类型不能存储double值.</p>
<h4 id="3、运行时类型查询"><a href="#3、运行时类型查询" class="headerlink" title="3、运行时类型查询"></a>3、运行时类型查询</h4><p>举个例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<p>因为类型擦除之后，ArrayList<String>只剩下原始类型，泛型信息String不存在了。那么，运行时进行类型查询的时候使用下面的方法是错误的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( arrayList <span class="keyword">instanceof</span> ArrayList&lt;String&gt;)</span><br></pre></td></tr></table></figure>
<p>java限定了这种类型查询的方式，？为通配符，也即非限定符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( arrayList <span class="keyword">instanceof</span> ArrayList&lt;?&gt;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>基础语法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>程序运行时，内存到底是如何进行分配的</title>
    <url>/2019/04/04/%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%8C%E5%86%85%E5%AD%98%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E9%85%8D%E7%9A%84/</url>
    <content><![CDATA[<h3 id="JVM-中的内存划分"><a href="#JVM-中的内存划分" class="headerlink" title="JVM 中的内存划分"></a>JVM 中的内存划分</h3><p>JVM 中的内存可以划分为若干个不同的数据区域，主要分为：程序计数器、虚拟机栈、本地方法栈、堆、方法区。</p>
<p>线程私有数据区：程序计数器、虚拟机栈、本地方法栈；</p>
<p>线程共有数据区：堆、方法区；</p>
<p>下面的图可以概况本章内容</p>
<p><img src="https://s0.lgstatic.com/i/image3/M01/02/8D/Ciqah157GD2AYLFtAADxheNgCA0454.png" alt=""></p>
<h4 id="程序计数器（ProgramCounterRegister）"><a href="#程序计数器（ProgramCounterRegister）" class="headerlink" title="程序计数器（ProgramCounterRegister）"></a>程序计数器（ProgramCounterRegister）</h4><p>Java程序是多线程的，CPU可以在多个线程中分配执行时间片段。当某一个线程被CPU挂起时，需要记录代码已经执行到的位置，方便 CPU 重新执行此线程时，知道从哪行指令开始执行。这就是程序计数器的作用。</p>
<p>程序计数器”是虚拟机中一块较小的内存空间，主要用于记录当前线程执行的位置。</p>
<p>关于程序计数器还有几点<strong>需要格外注意</strong>：</p>
<p>在 Java 虚拟机规范中，对程序计数器这一区域没有规定任何 OutOfMemoryError 情况（或许是感觉没有必要吧）。</p>
<p>程序计数器是线程私有的，每条线程内部都有一个私有程序计数器。它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
<p>当一个线程正在执行一个 Java 方法的时候，这个计数器记录的是正在执行的虚拟机字节码指令的地址。如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。</p>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>虚拟机栈也是线程私有的，与线程的生命周期同步。在 Java 虚拟机规范中，对这个区域规定了两种异常状况：</p>
<ol>
<li>StackOverflowError：当线程请求栈深度超出虚拟机栈所允许的深度时抛出</li>
<li>OutOfMemoryError：当Java虚拟机动态扩展到无法申请足够内存时抛出。</li>
</ol>
<p>JVM 是基于栈的解释器执行的，DVM 是基于寄存器解释器执行的。</p>
<p>上面这句话里的“基于栈”指的就是虚拟机栈。虚拟机栈的初衷是用来描述 Java 方法执行的内存模型，每个方法被执行的时候，JVM 都会在虚拟机栈中创建一个栈帧。</p>
<h5 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h5><p>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，每一个线程在执行某个方法时，都会为这个方法创建一个栈帧。一个线程包含多个栈帧，而每个栈帧内部包含局部变量表、操作数栈、动态连接、返回地址等。</p>
<h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><p>本地方法栈和上面介绍的虚拟栈基本相同，只不过是针对本地（native）方法。在开发中如果涉及JNI可能接触本地方法栈多一些。</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>Java堆（Heap）是JVM所管理的内存中最大的一块，该区域唯一目的就是存放对象实例，几乎所有对象的实例都在堆里面分配，因此它也是Java垃圾收集器（GC）管理的主要区域，有时候也叫作“GC 堆”（关于堆的 GC 回收机制将会在后续课时中做详细介绍）。同时它也是所有线程共享的内存区域，因此被分配在此区域的对象如果被多个线程访问的话，需要考虑线程安全问题。</p>
<p>按照对象存储时间的不同，堆中的内存可以划分为新生代（Young）和老年代（Old），其中新生代又被划分为 Eden 和 Survivor 区。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区（MethodArea）也是JVM规范里规定的一块运行时数据区。方法区主要是存储已经被JVM加载的类信息（版本、字段、方法、接口）、常量、静态变量、即时编译器编译后的代码和数据。该区域同堆一样，也是被各个线程共享的内存区域。</p>
<p><strong>注意：关于方法区，很多开发者会将其跟“永久区”混淆。</strong></p>
<p>所以我在这里对这两个概念进行一下对比：</p>
<ul>
<li><p>方法区是JVM规范中规定的一块区域，但是并不是实际实现，切忌将规范跟实现混为一谈。不同的JVM厂商可以有不同版本的“方法区”的实现。</p>
</li>
<li><p>HotSpot在JDK1.7以前使用“永久区”（或者叫Perm区）来实现方法区，在JDK1.8之后“永久区”就已经被移除了，取而代之的是一个叫作“元空间（metaspace）”的实现方式。</p>
<p><strong>总结一下就是：</strong></p>
<p>方法区是规范层面的东西，规定了这一个区域要存放哪些数据。永久区或者是metaspace是对方法区的不同实现，是实现层面的东西。</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对于JVM运行时内存布局，我们需要始终记住一点：上面介绍的这5块内容都是在Java虚拟机规范中定义的规则，这些规则只是描述了各个区域是负责做什么事情、存储什么样的数据、如何处理异常、是否允许线程间共享等。千万不要将它们理解为虚拟机的“具体实现”，虚拟机的具体实现有很多，比如Sun公司的HotSpot、JRocket、IBMJ9、以及我们非常熟悉的 Android Dalvik 和 ART 等。这些具体实现在符合上面 5 种运行时数据区的前提下，又各自有不同的实现方式。</p>
<p>总结来说，JVM的运行时内存结构中一共有两个“栈”和一个“堆”，分别是：Java虚拟机栈和本地方法栈，以及“GC堆”和方法区。除此之外还有一个程序计数器，但是我们开发者几乎不会用到这一部分，所以并不是重点学习内容。JVM内存中只有堆和方法区是线程共享的数据区域，其它区域都是线程私有的。并且程序计数器是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 </p>
<p>参考链接：<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67" target="_blank" rel="noopener">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>编译插桩操纵字节码</title>
    <url>/2020/04/13/%E7%BC%96%E8%AF%91%E6%8F%92%E6%A1%A9%E6%93%8D%E7%BA%B5%E5%AD%97%E8%8A%82%E7%A0%81/</url>
    <content><![CDATA[<h4 id="编译插桩是什么"><a href="#编译插桩是什么" class="headerlink" title="编译插桩是什么"></a>编译插桩是什么</h4><p>编译插桩就是在代码编译期间修改已有的代码或者生成新代码。Dagger、ButterKnife甚至是Kotlin语言，它们都用到了编译插桩的技术。</p>
<p>具体实现有如下两种方式：</p>
<ol>
<li>在.java文件编译成.class文件时，APT、AndroidAnnotation等就是在此处触发代码生成。</li>
<li>在 .class 文件进一步优化成 .dex 文件时，也就是直接操作字节码文件，这种方式功能更加强大，应用场景也更多。但是门槛比较高，需要对字节码有一定的理解。具体处理如下图：</li>
</ol>
<p><img src="https://s0.lgstatic.com/i/image3/M01/81/65/Cgq2xl6FrD2ABAAgAACZzFsVdz4155.png" alt=""></p>
<p>一般情况下，我们经常会使用编译插桩实现如下几种功能：</p>
<ul>
<li><p>日志埋点；</p>
</li>
<li><p>性能监控；</p>
</li>
<li><p>动态权限控制；</p>
</li>
<li><p>业务逻辑跳转时，校验是否已经登录；</p>
</li>
<li><p>甚至是代码调试等。</p>
</li>
</ul>
<h4 id="插桩工具介绍"><a href="#插桩工具介绍" class="headerlink" title="插桩工具介绍"></a>插桩工具介绍</h4><p>目前市面上主要流行两种实现编译插桩的方式：</p>
<h5 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h5><p>AspectJ是老牌AOP（Aspect-OrientedProgramming）框架，，如果你做过 J2EE 开发可能对这个框架更加熟悉，经常会拿这个框架跟 Spring AOP 进行比较。其主要优势是成熟稳定，使用者也不需要对字节码文件有深入的理解。</p>
<h5 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h5><p>目前另一种编译插桩的方式ASM越来越受到广大工程师的喜爱。通过ASM可以修改现有的字节码文件，也可以动态生成字节码文件，并且它是一款完全以字节码层面来操纵字节码并分析字节码的框架。</p>
<hr>
<p>下面介绍使用 ASM 来实现简单的编译插桩效果，通过插桩实现课时开始讲的需求，在每一个 Activity 打开时输出相应的 log 日志。</p>
<h4 id="使用-ASM"><a href="#使用-ASM" class="headerlink" title="使用 ASM"></a>使用 ASM</h4><h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h5><p>过程主要包含两步：</p>
<ol>
<li><strong>找到项目中编译生成的所有.class文件</strong></li>
</ol>
<p>AndroidStudio使用Gradle编译项目中的.java文件，并且从Gradle1.5.0之后，我们可以自己定义Transform，来获取所有.class文件引用。</p>
<p>但是Transform的使用需要依赖GradlePlugin。因此我们第一步需要创建一个单独的GradlePlugin，并在 Gradle Plugin 中使用自定义 Transform 找出所有的 .class 文件。遍历到目标.class文件（Activity）之后，</p>
<p>2.<strong>通过ASM动态注入需要被插入的字节码</strong></p>
<p>如果第一步进行顺利，我们可以找出所有的.class文件。接下来就需要过滤出目标 Activity 文件，并在目标 Activity 文件的 onCreate 方法中，通过 ASM 插入相应的 log 日志字节码。</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>1、<strong>创建 ASMLifeCycleDemo 项目</strong></p>
<p>创建主项目 ASMLifeCycleDemo，当前项目中只有一个 MainActivity；</p>
<p>2、<strong>创建自定义Gradle插件</strong></p>
<p>2.1、首先在ASMLifeCycleDemo项目中创建一个新的module，并选择AndroidLibrary类型，命名为asm_lifecycle_plugin。将asm_lifecycle_pluginmodule中除了build.gradle和main文件夹之外的所有内容都删除。然后在 main 目录下分别创建 groovy 和 java 目录；</p>
<p>因为Gradle插件是使用groovy语言编写的，所以需要新建一个groovy目录，用来存放插件相关的.groovy类。但ASM是java层面的框架，所以在 java 目录里存放 ASM 相关的类。</p>
<p>2.2、然后，在groovy中创建目录danny.jiang.plugin，并在此目录中创建类LifeCyclePlugin.groovy文件。在LifeCyclePlugin中重写 apply 方法，实现插件逻辑，因为是 demo 演示，所以我只是简单的打印 log 日志。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hopechart.plugin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.android.build.gradle.external.cmake.server.Project</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Plugin</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeCyclePlugin</span>  <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">        System.out.println(<span class="string">"==LifeCyclePlugin gradle plugin=="</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看出LifeCyclePlugin实现了gradleapi中的Plugin接口。当我们在appmodule的build.gradle文件中使用此插件时，其LifeCyclePlugin的apply方法将会被自动调用。</p>
<p>2.3、接下来，将asm_lifecycle_pluginmodule的build.gradle中的内容全部删掉，改为如下内容：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'groovy'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'maven'</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(<span class="string">dir:</span> <span class="string">'libs'</span>, <span class="string">include:</span> [<span class="string">'*.jar'</span>])</span><br><span class="line"></span><br><span class="line">    compile  gradleApi()</span><br><span class="line">    compile  localGroovy()</span><br><span class="line"></span><br><span class="line">    compile  <span class="string">'com.android.tools.build:gradle:3.6.2'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ASM相关依赖</span></span><br><span class="line">    implementation <span class="string">'org.ow2.asm:asm:7.1'</span></span><br><span class="line">    implementation <span class="string">'org.ow2.asm:asm-commons:7.1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group=<span class="string">'com.hopechart.plugin'</span></span><br><span class="line">version=<span class="string">'1.0.0'</span></span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            <span class="comment">//本地的Maven地址设置</span></span><br><span class="line">            repository(<span class="string">url:</span> uri(<span class="string">'../asm_lifecycle_repo'</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>group和version都需要在appmodule引用此插件时使用。所有的插件都需要被部署到maven库中，我们可以选择部署到远程或者本地。这里只是演示，所以只是将插件部署到本地目录中。具体地址通过 repository 属性配置，如图所示我将其配置在项目根目录下的 asm_lifecycle_repo 目录下。</p>
<p>2.4、最后一步，创建properties文件。在plugin/src/main目录下新建目录resources/META-INF/gradle-plguins，然后在此目录下新建一个文件：danny.asm.lifecycle.properties，其中文件名 danny.asm.lifecycle 就是我们自定义插件的名称，稍后我们在 app module 中会使用到此名称。配置文件内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation-class&#x3D;com.hopechart.plugin.LifeCyclePlugin</span><br></pre></td></tr></table></figure>

<p>在 .properties 文件中，需要指定我们自定义的插件类名 LifeCyclePlugin，</p>
<p>2.5、至此，自定义 Gradle 插件就已经写完，现在可以在 Android Studio 的右边栏找到 Gradle 中点击 uploadArchives，执行 plugin 的部署任务;</p>
<p>2.6、构建成功之后，在 Project 的根目录下将会出现一个 asm_lifecycle_repo目录，里面存放的就是我们的插件目标文件。</p>
<h4 id="测试-asm-lifecycle-plugin"><a href="#测试-asm-lifecycle-plugin" class="headerlink" title="测试 asm_lifecycle_plugin"></a>测试 asm_lifecycle_plugin</h4><p>为了测试自定义的 Gradle 插件是否可用，可以在 app module 中的 build.gradle 中引用此插件。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></span><br><span class="line"><span class="comment">// add start</span></span><br><span class="line"><span class="comment">//自定义 Gradle 插件中 properties 的文件名</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'danny.asm.lifecycle'</span></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        <span class="comment">//自定义插件maven地址</span></span><br><span class="line">        maven &#123; url <span class="string">'../asm_lifecycle_repo'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        <span class="comment">//加载自定义插件 group + module + version</span></span><br><span class="line">        classpath <span class="string">'com.hopechart.plugin:asm_lifecycle_plugin:1.0.0'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// add end</span></span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在命令行中使用 gradlew 执行构建命令，如果打印出我们自定义插件里的 log，则说明自定义 Gradle 插件可以使用</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
