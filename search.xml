<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AndroidR Input子系统总结</title>
    <url>/2023/10/16/AndroidR%20Input%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="Input子系统的启动"><a href="#Input子系统的启动" class="headerlink" title="Input子系统的启动"></a>Input子系统的启动</h4><ol>
<li><p>SystemServer创建InputManagerService这个系统服务。</p>
</li>
<li><p>InputManagerService构造方法中创建”android.display”线程，调用nativeInit函数，将”android.display”线程的Looper对应的MessageQueue传递到native层。</p>
</li>
<li><p>nativeInit函数中创建NativeInputManager对象，并将其指针返回到java层mPtr保存。</p>
</li>
<li><p>NativeInputManager构造函数中创建InputManager对象，并将其注册到ServiceManager，其服务名称为：“inputflinger”，InputManager构造函数中创建三个重要对象：InputDispatcher，InputClassifier，InputReader，比较重要的是在构造InputReader是创建了EventHub对象。</p>
</li>
<li><p>EventHub构造函数中通过inotify和epoll机制对目录”/dev/input”监听，主要监听此目录下文件的创建和删除，到此nativeInit函数完毕。</p>
</li>
<li><p>SystemServer中会接着调用InputManagerService的start方法，此方法中调用nativeStart作进一步初始化，nativeStart函数中调用InputManager的start函数。</p>
</li>
<li><p>InputManager的start函数中分别调用了InputDispatcher和InputReader的start函数，即分别启动了其内部线程InputThreadImpl，InputDispatcher内部线程（名字：“InputDispatcher”）启动调用了自己的dispatchOnce()函数，InputReader内部线程（名字：“InputReader”）启动调用了自己的loopOnce()函数。</p>
</li>
</ol>
<h4 id="InputReader线程读取输入事件"><a href="#InputReader线程读取输入事件" class="headerlink" title="InputReader线程读取输入事件"></a>InputReader线程读取输入事件</h4><p>InputReader对input事件处理过程大致可以分为三大步：</p>
<ol>
<li>EventHub通过INotify与Epoll监听/dev/input下的事件，在读取到事件之后放入mEventBuffer，此步骤将input_event转换为了RawEvent。</li>
<li>拿到原始事件RawEvent之后调用processEventsLocked对事件进行加工，不同事件类型有不同的加工厂（InputMapper），此步骤将RawEvent转换为了NotifyKeyArgs。</li>
<li>通过QueuedListener的flush函数将事件发送到InputDispatcher线程。</li>
</ol>
<h4 id="InputDispatcher线程分发输入事件"><a href="#InputDispatcher线程分发输入事件" class="headerlink" title="InputDispatcher线程分发输入事件"></a>InputDispatcher线程分发输入事件</h4><p>InputDispatcher对事件的分发流程是相当复杂的，仅对最简单的按键类型事件进行分析，同时分析过程省略了相当对细节的处理，我们做的是把握整体架构，现在就对这个过程做一个总结：</p>
<ol>
<li>InputReader线程将驱动获取的原始输入事件封装为NotifyKeyArgs传递给了InputDispatcher线程，在放入InputDispatcher线程mInboundQueue队列之前会先将事件传递到java层PhoneWindowManager，没有被拦截的情况下才会将NotifyKeyArgs转换为KeyEntry并放入mInboundQueue队列，接着会唤醒InputDispatcher线程。</li>
<li>InputDispatcher线程启动后就陷入了Looper死循环，等待输入事件的发生，被唤醒之后调用函数dispatchOnceInnerLocked处理事件，此函数在一些列判断之后没有丢弃事件则会进一步调用dispatchKeyLocked函数。</li>
<li>dispatchKeyLocked函数在分发之前又会首先将按键事件传到java层PhoneWindowManager的interceptKeyBeforeDispatching中给个提前拦截的机会，如果没有被拦截则会通过findFocusedWindowTargetsLocked找到目标焦点窗口。</li>
<li>findFocusedWindowTargetsLocked函数会从两个容器mFocusedWindowHandlesByDisplay和mFocusedApplicationHandlesByDisplay获得当前的焦点窗口和焦点应用，并且会对可能出现ANR的情况进行ANR timeout即ANR发生窗口的标记。</li>
<li>如果findFocusedWindowTargetsLocked函数返回结果为成功分发，则调用dispatchEventLocked函数继续分发输入事件，接着会将KeyEntry再转换为DispatchEntry，并存入目标窗口连接connection的outboundQueue队列，然后调用publishKeyEvent继续分发。</li>
<li>publishKeyEvent函数中构造描述输入事件信息的InputMessage并通过InputChannel向”server”端socket写入数据以唤醒APP进程的socket”client”端，自此输入事件成功从InputDispatcher发送到了APP。</li>
<li>最后将DispatchEntry从目标窗口连接connection的outboundQueue队列中移除，并转移到目标窗口连接connection的waitQueue队列中。</li>
</ol>
<p>整个过程中有三个重要队列，mInboundQueue，outboundQueue，waitQueue。<br>mInboundQueue位于InputDispatcher线程，代表即将分发的输入事件，outboundQueue位于目标窗口的connection，代表即将要分发给目标窗口的输入事件，waitQueue位于目标窗口的connection，代表等待目标窗口处理的输入事件。</p>
<h3 id="InputChannel注册，建立APP和InputDispatcher的连接"><a href="#InputChannel注册，建立APP和InputDispatcher的连接" class="headerlink" title="InputChannel注册，建立APP和InputDispatcher的连接"></a>InputChannel注册，建立APP和InputDispatcher的连接</h3><ol>
<li><p>首先当一个APP启动时，会将自己的Window添加到WMS，并传递一个空InputChannel过去。</p>
</li>
<li><p>WMS端，通过openInputChannel方法会创建一对InputChannel，是在native层完成的，这对InputChannel被分为“client”端和“server”端，其内部又会创建一对socket，和这对InputChannel一一对应。</p>
</li>
<li><p>“server”端InputChannel会被注册到InputDispatcher中去，注册的原理就是将InputChannel内部的socket添加到其Looper进行监听，注册过程中还会创建一个Connection对象，Connection用来描述InputDispatcher与此次注册InputChannel的窗口的连接。</p>
</li>
<li><p>“client”端InputChannel会被设置到APP进程中，接着通过InputEventReceiver注册到APP UI线程，同样是将InputChannel内部的socket添加到UI线程的Looper进行监听。</p>
</li>
<li><p>对于InputDispatcher线程，在接收到”client”端socket的消息时会回调其handleReceiveCallback函数，对于APP UI线程，在接收到”server”端socket的消息时会回调InputEventReceiver对应的native层对象NativeInputEventReceiver的handleEvent函数。</p>
</li>
</ol>
<h4 id="UI线程对Input事件的分发与结束处理"><a href="#UI线程对Input事件的分发与结束处理" class="headerlink" title="UI线程对Input事件的分发与结束处理"></a>UI线程对Input事件的分发与结束处理</h4><ol>
<li><p>首先InputDispatcher通过server端InputChannel将输入事件发送给应用程序的client端。</p>
</li>
<li><p>client端收到输入事件，会在UI线程中调用向Looper注册的回调handleEvent，handleEvent主要是通过consumeEvents进一步处理事件。</p>
</li>
<li><p>输入事件在native层被转换为KeyEvent或者MotionEvent后会发送到java层InputEventReceiver的dispatchInputEvent方法，实际上最终是送到其子类WindowInputEventReceiver的onInputEvent方法来处理。</p>
</li>
<li><p>ViewRootImpl作为Android上层事件分发的起点，其中定义了多种InputStage来将事件分类处理，采用责任链模式，将每个InputStage实现类通过mNext变量连接起来，InputStage通过deliver分发事件，通过onProcess处理事件，通过forward向mNext传递事件.</p>
</li>
<li><p>当mNext指向null时则会调用finishInputEvent结束事件，之后会调到native层的InputConsumer的sendFinishedSignal函数，最终还是通过client端InputChannel的sendMessage通知InputDispatcher事件已经处理完成。</p>
</li>
<li><p>InputDispatcher这边的收尾工作主要就是将此事件从waitQueue移除并重置ANR时间。</p>
</li>
</ol>
<h4 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h4><p>对于View来说主要使用<code>ViewPostImeInputStage</code>这种类型的<code>InputStage</code>来处理触摸事件。</p>
<p>输入事件从native层到<code>ViewRootImpl</code>之后会经过：<code>DecorView</code>-&gt;<code>Activity</code>-&gt;<code>PhoneWindow</code>-&gt;<code>DecorView</code>-&gt;<code>ViewGroup</code>的流程</p>
<p>ViewGroup的<code>dispatchTouchEvent</code>方法进行总结：</p>
<ol>
<li><p>首先会调用onFilterTouchEventForSecurity方法对此次事件进行初步判断，判断的是ViewGroup是否被遮挡或者隐藏。</p>
</li>
<li><p>步骤1的条件判断通过之后，接着对于ACTION_DOWN事件会清空上一个事件序列（一个事件序列通常由一个ACTION_DOWN，N个ACTION_MOVE，一个ACTION_UP组成）留下的各种状态，最主要是清空TouchTarget链表。</p>
</li>
<li><p>接着会有两个条件来判断是否走ViewGroup的拦截机制，条件1：此次事件是否为ACTION_DOWN，条件2：mFirstTouchTarget是否为空，这两个条件的意思是对于一个事件序列的ACTION_DOWN事件一定会走ViewGroup的拦截机制，并且同一事件序列的一个事件如果被拦截了，那么后续事件默认都会被拦截而不会再走拦截方法onInterceptTouchEvent，子View可以通过requestDisallowInterceptTouchEvent方法请求父View不要拦截。</p>
</li>
<li><p>接着又会两个条件来判断事件事件继续分发，canceled和intercepted，事件被取消和被拦截，其实canceled多半是因为intercepted导致的，这个后面再说。</p>
</li>
<li><p>对于没有被取消且没有被拦截，且是ACTION_DOWN的事件就要开始遍历View树找到真正消费事件的子View了，这里为何会单独对ACTION_DOWN进行判断呢？这是因为一个事件序列可能包含多个触摸事件，而触摸事件寻找消费的子View是通过递归遍历View树，为了性能考虑，Android的设计为：当接收到ACTION_DOWN时开始对View树进行遍历，找到最终消费事件的子View之后将其保存，同一事件序列的后续ACTION_MOVE，ACTION_UP则不再需要遍历，直接将事件发送给保存好的子View就行了，对子View的保存就用到了TouchTarget，这是一种链表结构，后面再说。</p>
</li>
<li><p>对于目标子View的寻找就比较简单了，首先将当前ViewGroup的所有子View以Z-order的顺序进行重建，保存在一个list中，然后遍历list，从Z-order最大的子View开始，遍历条件有两个：当前遍历的子View可以接收事件，并且触摸区域落在当前子View之内则说明成功找到子View，然后调用dispatchTransformedTouchEvent执行子View事件处理流程，如果事件成功处理则会为此子View构建TouchTarget，并赋值给mFirstTouchTarget。</p>
</li>
<li><p>接着对于mFirstTouchTarget不为空的情况会遍历链表，其目的是步骤6已经找到接收事件的目标子View并且保存到了TouchTarget链表，对于一个事件序列的后续事件只需要遍历链表分发事件就行了。</p>
</li>
<li><p>对于没有找到消费事件的子View即mFirstTouchTarget为空，以及事件被取消的情况会做一些收尾工作。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统源码</tag>
      </tags>
  </entry>
  <entry>
    <title>添加系统服务及SEAndroid总结</title>
    <url>/2023/09/22/FW%20%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%8F%8ASEAndroid%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Android</category>
        <category>系统源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 13 WMS总结</title>
    <url>/2023/09/20/FW%20WMS%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h5 id="窗口层级相关"><a href="#窗口层级相关" class="headerlink" title="窗口层级相关"></a>窗口层级相关</h5><p><strong>WindowContainer</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/wm/WindowContainer.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Defines common functionality for classes that can hold windows directly or through their</span></span><br><span class="line"><span class="comment"> * children in a hierarchy form.</span></span><br><span class="line"><span class="comment"> * The test class is &#123;<span class="doctag">@link</span> WindowContainerTests&#125; which must be kept up-to-date and ran anytime</span></span><br><span class="line"><span class="comment"> * changes are made to this class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowContainer</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">WindowContainer</span>&gt; <span class="keyword">extends</span> <span class="title">ConfigurationContainer</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">WindowContainer</span>&gt;, <span class="title">Animatable</span>, <span class="title">SurfaceFreezer</span>.<span class="title">Freezable</span>,</span></span><br><span class="line"><span class="class">        <span class="title">InsetsControlTarget</span> </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The parent of this window container.</span></span><br><span class="line"><span class="comment">     * For removing or setting new parent &#123;<span class="doctag">@link</span> #setParent&#125; should be used, because it also</span></span><br><span class="line"><span class="comment">     * performs configuration updates based on new parent's settings.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> WindowContainer&lt;WindowContainer&gt; mParent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// List of children for this window container. List is in z-order as the children 	appear on</span></span><br><span class="line">    <span class="comment">// screen with the top-most window container at the tail of the list.</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> WindowList&lt;E&gt; mChildren = <span class="keyword">new</span> WindowList&lt;E&gt;();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>给可以直接持有窗口的自己或它的孩子定义了一些公共的方法和属性，RootWindowContainer、DisplayContent、DisplayArea、DisplayArea.Tokens、TaskDisplayArea、Task、ActivityRecord、WindowToken、WindowState都是直接或间接的继承该类。</p>
<p>主要的成员变量就是mParent和mChildren，一个代表父节点一个代表子节点，而且子节点的list顺序代表就是z轴的层级显示顺序，list尾巴在比list的头的z轴层级要高。</p>
<ul>
<li><p>RootWindowContainer：根窗口容器，树的根是它。通过它遍历寻找，可以找到窗口树上的窗口。它的孩子是DisplayContent。</p>
</li>
<li><p>DisplayContent：该类是对应着显示屏幕的，Android是支持多屏幕的，所以可能存在多个DisplayContent对象。</p>
</li>
<li><p>DisplayArea：该类是对应着显示屏幕下面的，代表一组窗口合集,具有多个子类，如Tokens，TaskDisplayArea等</p>
</li>
<li><p>TaskDisplayArea：它为DisplayContent的孩子，对应着窗口层次的第2层。第2层作为应用层，看它的定义：int APPLICATION_LAYER = 2，应用层的窗口是处于第2层。TaskDisplayArea的孩子是Task类，其实它的孩子类型也可以是TaskDisplayArea。而Task的孩子则可以是ActivityRecord，也可以是Task。</p>
</li>
<li><p>Tokens：代表专门包含WindowTokens的容器，它的孩子是WindowToken，而WindowToken的孩子则为WindowState对象。WindowState是对应着一个窗口的。</p>
</li>
<li><p>ImeContainer：它是输入法窗口的容器，它的孩子是WindowToken类型。WindowToken的孩子为WindowState类型，而WindowState类型则对应着输入法窗口。</p>
</li>
<li><p>Task：任务，它的孩子可以是Task，也可以是ActivityRecord类型。</p>
</li>
<li><p>ActivityRecord：是对应着应用进程中的Activity的。ActivityRecord是继承WindowToken的，它的孩子类型为WindowState。</p>
</li>
<li><p>WindowState：WindowState是对应着一个窗口的。</p>
</li>
</ul>
<p>用dumpsys命令来看看层级结构相关的输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys activity containers</span><br></pre></td></tr></table></figure>

<p>对应的输出结构树如下</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB6cc95a97e35ae4012992ce03150323fc?method=download&shareKey=2c9942b48cce0294715a3d0d2af7df72" alt=""></p>
<p>每个显示屏幕的窗口层级分为37层，0-36层。每层可以放置多个窗口，上层窗口覆盖下面的，这个树中每个点一般这样格式：<br>名字：层级开始数 ：层级结束数</p>
<p>0-36个图层每个图层都有对应节点进行占领，有的一个节点占领一层，如Leaf:36:36 ，有的一个节点可能占领多层如：Leaf:3:12</p>
<p>常用窗口挂载层级：</p>
<ul>
<li>Wallpaper处于0-1层</li>
<li>Activity处于DefaultTaskDisplayArea第2层  后续挂载节点Task-&gt;ActivityRecord -&gt;WindowState</li>
<li>InputMethod处于13-14层</li>
<li>StatusBar处于15层</li>
<li>NotificationShade处于17层</li>
<li>NavigationBar0处于24-25层</li>
</ul>
<h5 id="结构树构建的源码"><a href="#结构树构建的源码" class="headerlink" title="结构树构建的源码"></a>结构树构建的源码</h5><p><strong>DisplayContent中启动层级树的构建</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create new &#123;<span class="doctag">@link</span> DisplayContent&#125; instance, add itself to the root window container and</span></span><br><span class="line"><span class="comment"> * initialize direct children.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> display May not be null.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root &#123;<span class="doctag">@link</span> RootWindowContainer&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DisplayContent(Display display, RootWindowContainer root) &#123;</span><br><span class="line">    <span class="keyword">super</span>(root.mWindowManager, <span class="string">"DisplayContent"</span>, FEATURE_ROOT);</span><br><span class="line"> 	...</span><br><span class="line">    <span class="keyword">final</span> InputChannel inputChannel = mWmService.mInputManager.monitorInput(</span><br><span class="line">            <span class="string">"PointerEventDispatcher"</span> + mDisplayId, mDisplayId);</span><br><span class="line">    mPointerEventDispatcher = <span class="keyword">new</span> PointerEventDispatcher(inputChannel);</span><br><span class="line">	<span class="comment">//调用surface相关图层配置，因为显示东西需要Surfaceflinger</span></span><br><span class="line">    <span class="keyword">final</span> Transaction pendingTransaction = getPendingTransaction();</span><br><span class="line">    configureSurfaces(pendingTransaction);</span><br><span class="line">    pendingTransaction.apply();</span><br><span class="line">    <span class="comment">// Sets the display content for the children.</span></span><br><span class="line">    onDisplayChanged(<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureSurfaces</span><span class="params">(Transaction transaction)</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">    <span class="keyword">if</span> (mDisplayAreaPolicy == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Setup the policy and build the display area hierarchy.</span></span><br><span class="line">        <span class="comment">// Build the hierarchy only after creating the surface so it is reparented correctly</span></span><br><span class="line">        <span class="comment">//进行DisplayArea构建</span></span><br><span class="line">        mDisplayAreaPolicy = mWmService.getDisplayAreaPolicyProvider().instantiate(</span><br><span class="line">                mWmService, <span class="keyword">this</span> <span class="comment">/* content */</span>, <span class="keyword">this</span> <span class="comment">/* root */</span>,</span><br><span class="line">                mImeWindowsContainer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来调用DisplayAreaPolicy中内部类DefaultProvider的instantiate方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/wm/DisplayAreaPolicy.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DisplayAreaPolicy <span class="title">instantiate</span><span class="params">(WindowManagerService wmService,</span></span></span><br><span class="line"><span class="function"><span class="params">                DisplayContent content, RootDisplayArea root,</span></span></span><br><span class="line"><span class="function"><span class="params">                DisplayArea.Tokens imeContainer)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//创建特殊的TaskDisplayArea，专门来装Activity相关的容器</span></span><br><span class="line">            <span class="keyword">final</span> TaskDisplayArea defaultTaskDisplayArea = <span class="keyword">new</span> TaskDisplayArea(content, wmService,</span><br><span class="line">                    <span class="string">"DefaultTaskDisplayArea"</span>, FEATURE_DEFAULT_TASK_CONTAINER);</span><br><span class="line">            <span class="keyword">final</span> List&lt;TaskDisplayArea&gt; tdaList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            tdaList.add(defaultTaskDisplayArea);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Define the features that will be supported under the root of the whole logical</span></span><br><span class="line">            <span class="comment">// display. The policy will build the DisplayArea hierarchy based on this.</span></span><br><span class="line">    		<span class="comment">//构建HierarchyBuilder对象</span></span><br><span class="line">            <span class="keyword">final</span> HierarchyBuilder rootHierarchy = <span class="keyword">new</span> HierarchyBuilder(root);</span><br><span class="line">            <span class="comment">// Set the essential containers (even if the display doesn't support IME).</span></span><br><span class="line"> 			<span class="comment">//setImeContainer进行输入法直接容器设置           </span></span><br><span class="line"> 			rootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList);</span><br><span class="line">            <span class="keyword">if</span> (content.isTrusted()) &#123;<span class="comment">//构成层级关键</span></span><br><span class="line">                <span class="comment">// Only trusted display can have system decorations.</span></span><br><span class="line">                configureTrustedHierarchyBuilder(rootHierarchy, wmService, content);</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> DisplayAreaPolicyBuilder().setRootHierarchy(rootHierarchy).build(wmService);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>先看下configureTrustedHierarchyBuilder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureTrustedHierarchyBuilder</span><span class="params">(HierarchyBuilder rootHierarchy,</span></span></span><br><span class="line"><span class="function"><span class="params">                WindowManagerService wmService, DisplayContent content)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// WindowedMagnification should be on the top so that there is only one surface</span></span><br><span class="line">            <span class="comment">// to be magnified.</span></span><br><span class="line">            rootHierarchy.addFeature(<span class="keyword">new</span> Feature.Builder(wmService.mPolicy, <span class="string">"WindowedMagnification"</span>,</span><br><span class="line">                    FEATURE_WINDOWED_MAGNIFICATION)</span><br><span class="line">                    .upTo(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)</span><br><span class="line">                    .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)</span><br><span class="line">                    <span class="comment">// Make the DA dimmable so that the magnify window also mirrors the dim layer.</span></span><br><span class="line">                    .setNewDisplayAreaSupplier(DisplayArea.Dimmable::<span class="keyword">new</span>)</span><br><span class="line">                    .build());</span><br><span class="line">            <span class="keyword">if</span> (content.isDefaultDisplay) &#123;</span><br><span class="line">                <span class="comment">// Only default display can have cutout.</span></span><br><span class="line">                <span class="comment">// See LocalDisplayAdapter.LocalDisplayDevice#getDisplayDeviceInfoLocked.</span></span><br><span class="line">                rootHierarchy.addFeature(<span class="keyword">new</span> Feature.Builder(wmService.mPolicy, <span class="string">"HideDisplayCutout"</span>,</span><br><span class="line">                        FEATURE_HIDE_DISPLAY_CUTOUT)</span><br><span class="line">                        .all()</span><br><span class="line">                        .except(TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL, TYPE_STATUS_BAR,</span><br><span class="line">                                TYPE_NOTIFICATION_SHADE)</span><br><span class="line">                        .build())</span><br><span class="line">                        .addFeature(<span class="keyword">new</span> Feature.Builder(wmService.mPolicy, <span class="string">"OneHanded"</span>,</span><br><span class="line">                                FEATURE_ONE_HANDED)</span><br><span class="line">                                .all()</span><br><span class="line">                                .except(TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL,</span><br><span class="line">                                        TYPE_SECURE_SYSTEM_OVERLAY)</span><br><span class="line">                                .build());</span><br><span class="line">            &#125;</span><br><span class="line">            rootHierarchy</span><br><span class="line">                    .addFeature(<span class="keyword">new</span> Feature.Builder(wmService.mPolicy, <span class="string">"FullscreenMagnification"</span>,</span><br><span class="line">                            FEATURE_FULLSCREEN_MAGNIFICATION)</span><br><span class="line">                            .all()</span><br><span class="line">                            .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY, TYPE_INPUT_METHOD,</span><br><span class="line">                                    TYPE_INPUT_METHOD_DIALOG, TYPE_MAGNIFICATION_OVERLAY,</span><br><span class="line">                                    TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL)</span><br><span class="line">                            .build())</span><br><span class="line">                    .addFeature(<span class="keyword">new</span> Feature.Builder(wmService.mPolicy, <span class="string">"ImePlaceholder"</span>,</span><br><span class="line">                            FEATURE_IME_PLACEHOLDER)</span><br><span class="line">                            .and(TYPE_INPUT_METHOD, TYPE_INPUT_METHOD_DIALOG)</span><br><span class="line">                            .build());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>设置的这些Feature名字,Feature代表的是DisplayArea的一个特征，可以根据Feature来对不同的DisplayArea进行划分。Feature类中成员变量如下：</p>
<ul>
<li>mName：这个Feature的名字，如上面的“WindowedMagnification”，“HideDisplayCutout”之类的，后续DisplayArea层级结构建立起来后，每个DisplayArea的名字用的就是当前DisplayArea对应的那个Feature的名字。</li>
<li>mId：Feature的ID，如上面的FEATURE_WINDOWED_MAGNIFICATION和FEATURE_HIDE_DISPLAY_CUTOUT，虽说是Feature的ID，因为Feature又是DisplayArea的特征</li>
<li>mWindowLayers：代表了这个DisplayArea可以包含哪些层级对应的窗口</li>
</ul>
<p>其中一个Feature：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> rootHierarchy.addFeature(<span class="keyword">new</span> Feature.Builder(wmService.mPolicy, <span class="string">"WindowedMagnification"</span>,</span><br><span class="line">                    FEATURE_WINDOWED_MAGNIFICATION)</span><br><span class="line">                    .upTo(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)</span><br><span class="line">                    .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)</span><br><span class="line">                    <span class="comment">// Make the DA dimmable so that the magnify window also mirrors the dim layer.</span></span><br><span class="line">                    .setNewDisplayAreaSupplier(DisplayArea.Dimmable::<span class="keyword">new</span>)</span><br><span class="line">                    .build());</span><br><span class="line"><span class="comment">//typeInclusive代表一个windowType，一般可以通过windowType获取对应的windowLayer，</span></span><br><span class="line"><span class="comment">//获取方法layerFromType，upTo代表逻辑就是把层级范围到typeInclusive</span></span><br><span class="line">  <span class="function">Builder <span class="title">upTo</span><span class="params">(<span class="keyword">int</span> typeInclusive)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> max = layerFromType(typeInclusive, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">                    mLayers[i] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                set(typeInclusive, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Set that the feature does not apply to the given window types.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">             <span class="comment">//排除types</span></span><br><span class="line">            <span class="function">Builder <span class="title">except</span><span class="params">(<span class="keyword">int</span>... types)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> type = types[i];</span><br><span class="line">                    set(type, <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//留下types</span></span><br><span class="line">             <span class="function">Builder <span class="title">and</span><span class="params">(<span class="keyword">int</span>... types)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> type = types[i];</span><br><span class="line">                    set(type, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">layerFromType</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">boolean</span> internalWindows)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mPolicy.getWindowLayerFromTypeLw(type, internalWindows);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>这里调用了getWindowLayerFromTypeLw来实现窗口类型到层级数的转化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getWindowLayerFromTypeLw</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">boolean</span> canAddInternalSystemWindow,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">boolean</span> roundedCornerOverlay)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Always put the rounded corner layer to the top most.</span></span><br><span class="line">       <span class="keyword">if</span> (roundedCornerOverlay &amp;&amp; canAddInternalSystemWindow) &#123;</span><br><span class="line">           <span class="keyword">return</span> getMaxWindowLayer();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (type &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; type &lt;= LAST_APPLICATION_WINDOW) &#123;</span><br><span class="line">           <span class="keyword">return</span> APPLICATION_LAYER;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">           <span class="keyword">case</span> TYPE_WALLPAPER:</span><br><span class="line">               <span class="comment">// wallpaper is at the bottom, though the window manager may move it.</span></span><br><span class="line">               <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_PRESENTATION:</span><br><span class="line">           <span class="keyword">case</span> TYPE_PRIVATE_PRESENTATION:</span><br><span class="line">           <span class="keyword">case</span> TYPE_DOCK_DIVIDER:</span><br><span class="line">           <span class="keyword">case</span> TYPE_QS_DIALOG:</span><br><span class="line">           <span class="keyword">case</span> TYPE_PHONE:</span><br><span class="line">               <span class="keyword">return</span>  <span class="number">3</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_SEARCH_BAR:</span><br><span class="line">               <span class="keyword">return</span>  <span class="number">4</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_INPUT_CONSUMER:</span><br><span class="line">               <span class="keyword">return</span>  <span class="number">5</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_SYSTEM_DIALOG:</span><br><span class="line">               <span class="keyword">return</span>  <span class="number">6</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_TOAST:</span><br><span class="line">               <span class="comment">// toasts and the plugged-in battery thing</span></span><br><span class="line">               <span class="keyword">return</span>  <span class="number">7</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_PRIORITY_PHONE:</span><br><span class="line">               <span class="comment">// SIM errors and unlock.  Not sure if this really should be in a high layer.</span></span><br><span class="line">               <span class="keyword">return</span>  <span class="number">8</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_SYSTEM_ALERT:</span><br><span class="line">               <span class="comment">// like the ANR / app crashed dialogs</span></span><br><span class="line">               <span class="comment">// Type is deprecated for non-system apps. For system apps, this type should be</span></span><br><span class="line">               <span class="comment">// in a higher layer than TYPE_APPLICATION_OVERLAY.</span></span><br><span class="line">               <span class="keyword">return</span>  canAddInternalSystemWindow ? <span class="number">12</span> : <span class="number">9</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_APPLICATION_OVERLAY:</span><br><span class="line">               <span class="keyword">return</span>  <span class="number">11</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_INPUT_METHOD:</span><br><span class="line">               <span class="comment">// on-screen keyboards and other such input method user interfaces go here.</span></span><br><span class="line">               <span class="keyword">return</span>  <span class="number">13</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_INPUT_METHOD_DIALOG:</span><br><span class="line">               <span class="comment">// on-screen keyboards and other such input method user interfaces go here.</span></span><br><span class="line">               <span class="keyword">return</span>  <span class="number">14</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_STATUS_BAR:</span><br><span class="line">               <span class="keyword">return</span>  <span class="number">15</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_STATUS_BAR_ADDITIONAL:</span><br><span class="line">               <span class="keyword">return</span>  <span class="number">16</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_NOTIFICATION_SHADE:</span><br><span class="line">               <span class="keyword">return</span>  <span class="number">17</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_STATUS_BAR_SUB_PANEL:</span><br><span class="line">               <span class="keyword">return</span>  <span class="number">18</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_KEYGUARD_DIALOG:</span><br><span class="line">               <span class="keyword">return</span>  <span class="number">19</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_VOICE_INTERACTION_STARTING:</span><br><span class="line">               <span class="keyword">return</span>  <span class="number">20</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_VOICE_INTERACTION:</span><br><span class="line">               <span class="comment">// voice interaction layer should show above the lock screen.</span></span><br><span class="line">               <span class="keyword">return</span>  <span class="number">21</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_VOLUME_OVERLAY:</span><br><span class="line">               <span class="comment">// the on-screen volume indicator and controller shown when the user</span></span><br><span class="line">               <span class="comment">// changes the device volume</span></span><br><span class="line">               <span class="keyword">return</span>  <span class="number">22</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_SYSTEM_OVERLAY:</span><br><span class="line">               <span class="comment">// the on-screen volume indicator and controller shown when the user</span></span><br><span class="line">               <span class="comment">// changes the device volume</span></span><br><span class="line">               <span class="keyword">return</span>  canAddInternalSystemWindow ? <span class="number">23</span> : <span class="number">10</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_NAVIGATION_BAR:</span><br><span class="line">               <span class="comment">// the navigation bar, if available, shows atop most things</span></span><br><span class="line">               <span class="keyword">return</span>  <span class="number">24</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_NAVIGATION_BAR_PANEL:</span><br><span class="line">               <span class="comment">// some panels (e.g. search) need to show on top of the navigation bar</span></span><br><span class="line">               <span class="keyword">return</span>  <span class="number">25</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_SCREENSHOT:</span><br><span class="line">               <span class="comment">// screenshot selection layer shouldn't go above system error, but it should cover</span></span><br><span class="line">               <span class="comment">// navigation bars at the very least.</span></span><br><span class="line">               <span class="keyword">return</span>  <span class="number">26</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_SYSTEM_ERROR:</span><br><span class="line">               <span class="comment">// system-level error dialogs</span></span><br><span class="line">               <span class="keyword">return</span>  canAddInternalSystemWindow ? <span class="number">27</span> : <span class="number">9</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_MAGNIFICATION_OVERLAY:</span><br><span class="line">               <span class="comment">// used to highlight the magnified portion of a display</span></span><br><span class="line">               <span class="keyword">return</span>  <span class="number">28</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_DISPLAY_OVERLAY:</span><br><span class="line">               <span class="comment">// used to simulate secondary display devices</span></span><br><span class="line">               <span class="keyword">return</span>  <span class="number">29</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_DRAG:</span><br><span class="line">               <span class="comment">// the drag layer: input for drag-and-drop is associated with this window,</span></span><br><span class="line">               <span class="comment">// which sits above all other focusable windows</span></span><br><span class="line">               <span class="keyword">return</span>  <span class="number">30</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_ACCESSIBILITY_OVERLAY:</span><br><span class="line">               <span class="comment">// overlay put by accessibility services to intercept user interaction</span></span><br><span class="line">               <span class="keyword">return</span>  <span class="number">31</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY:</span><br><span class="line">               <span class="keyword">return</span> <span class="number">32</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_SECURE_SYSTEM_OVERLAY:</span><br><span class="line">               <span class="keyword">return</span>  <span class="number">33</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_BOOT_PROGRESS:</span><br><span class="line">               <span class="keyword">return</span>  <span class="number">34</span>;</span><br><span class="line">           <span class="keyword">case</span> TYPE_POINTER:</span><br><span class="line">               <span class="comment">// the (mouse) pointer layer</span></span><br><span class="line">               <span class="keyword">return</span>  <span class="number">35</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               Slog.e(<span class="string">"WindowManager"</span>, <span class="string">"Unknown window type: "</span> + type);</span><br><span class="line">               <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>上面是应用常用的窗口类型，如TYPE_WALLPAPER，TYPE_NAVIGATION_BAR等，其实他们都是有固定的一个层级的。即windowType的值并不是真正层级数目，都是需要通过这个方法进行转化才是真正层级数。</p>
<p>再回到addFeature部分，通过以上的层级获取及相关upTo方法后我们可以得出各个Feature的一个层级情况</p>
<table>
<thead>
<tr>
<th>Feature名字</th>
<th>层级情况</th>
</tr>
</thead>
<tbody><tr>
<td>WindowedMagnification</td>
<td>0-31</td>
</tr>
<tr>
<td>HideDisplayCutout</td>
<td>0-14 16 18-23 26-35</td>
</tr>
<tr>
<td>OneHanded</td>
<td>0-23 26-32 34-35</td>
</tr>
<tr>
<td>FullscreenMagnification</td>
<td>0-12 15-23 26-27 29-31 33-35</td>
</tr>
<tr>
<td>ImePlaceholder</td>
<td>13-14</td>
</tr>
</tbody></table>
<p>每个Feature对应层级已经清楚了，再接下来就要进入正式的树构建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/wm/DisplayAreaPolicyBuilder.java</span></span><br><span class="line">   <span class="function">Result <span class="title">build</span><span class="params">(WindowManagerService wmService)</span> </span>&#123;</span><br><span class="line">        validate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Attach DA group roots to screen hierarchy before adding windows to group hierarchies.</span></span><br><span class="line">        mRootHierarchyBuilder.build(mDisplayAreaGroupHierarchyBuilders);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(wmService, mRootHierarchyBuilder.mRoot, displayAreaGroupRoots,</span><br><span class="line">                mSelectRootForWindowFunc, mSelectTaskDisplayAreaFunc);</span><br><span class="line">    &#125;</span><br><span class="line">		 <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Builds the &#123;<span class="doctag">@link</span> DisplayArea&#125; hierarchy below root. And adds the roots of those</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> HierarchyBuilder&#125; as children.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(@Nullable List&lt;HierarchyBuilder&gt; displayAreaGroupHierarchyBuilders)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            PendingArea[] areaForLayer = <span class="keyword">new</span> PendingArea[maxWindowLayerCount];</span><br><span class="line">            <span class="comment">//PendingArea作为root部分</span></span><br><span class="line">            <span class="keyword">final</span> PendingArea root = <span class="keyword">new</span> PendingArea(<span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>); </span><br><span class="line">            <span class="comment">//给areaForLayer填满都是默认new PendingArea(null, 0, null); </span></span><br><span class="line">            Arrays.fill(areaForLayer, root);</span><br><span class="line">		    <span class="comment">//1、创建feature相关的树</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> size = mFeatures.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="comment">// Traverse the features with the order they are defined, so that the early defined</span></span><br><span class="line">                <span class="comment">// feature will be on the top in the hierarchy.</span></span><br><span class="line">                <span class="keyword">final</span> Feature feature = mFeatures.get(i);</span><br><span class="line">                PendingArea featureArea = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> layer = <span class="number">0</span>; layer &lt; maxWindowLayerCount; layer++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (feature.mWindowLayers[layer]) &#123;</span><br><span class="line">                        <span class="comment">// This feature will be applied to this window layer.</span></span><br><span class="line">                        <span class="comment">// We need to find a DisplayArea for it:</span></span><br><span class="line">                        <span class="comment">// We can reuse the existing one if it was created for this feature for the</span></span><br><span class="line">                        <span class="comment">// previous layer AND the last feature that applied to the previous layer is</span></span><br><span class="line">                        <span class="comment">// the same as the feature that applied to the current layer (so they are ok</span></span><br><span class="line">                        <span class="comment">// to share the same parent DisplayArea).</span></span><br><span class="line">                        <span class="comment">//如果featureArea为空，一般每个Feature第一次进入都为null</span></span><br><span class="line">                        <span class="comment">//如果featureArea不为空，featureArea的父节点不一样，即如果兄弟层级featureArea的父节点是						    //同一个那就不需要新创建</span></span><br><span class="line">                        <span class="keyword">if</span> (featureArea == <span class="keyword">null</span> || featureArea.mParent != areaForLayer[layer]) &#123;</span><br><span class="line">                            <span class="comment">// No suitable DisplayArea:</span></span><br><span class="line">                            <span class="comment">// Create a new one under the previous area (as parent) for this layer.</span></span><br><span class="line">                            <span class="comment">//以areaForLayer[layer]为父节点创建一个新的节点</span></span><br><span class="line">                            featureArea = <span class="keyword">new</span> PendingArea(feature, layer, areaForLayer[layer]);</span><br><span class="line">                            <span class="comment">//老容器节点添加新节点</span></span><br><span class="line">                            areaForLayer[layer].mChildren.add(featureArea);</span><br><span class="line">                        &#125;</span><br><span class="line">                        areaForLayer[layer] = featureArea;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// This feature won't be applied to this window layer. If it needs to be</span></span><br><span class="line">                        <span class="comment">// applied to the next layer, we will need to create a new DisplayArea for</span></span><br><span class="line">                        <span class="comment">// that.</span></span><br><span class="line">                        <span class="comment">//如果这一层不支持显示，那么就把featureArea设置为null</span></span><br><span class="line">                        featureArea = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//2、创建叶子相关</span></span><br><span class="line">            <span class="comment">// Create Tokens as leaf for every layer.</span></span><br><span class="line">            PendingArea leafArea = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> leafType = LEAF_TYPE_TOKENS;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> layer = <span class="number">0</span>; layer &lt; maxWindowLayerCount; layer++) &#123;<span class="comment">//遍历36层</span></span><br><span class="line">                <span class="keyword">int</span> type = typeOfLayer(policy, layer);</span><br><span class="line">                <span class="comment">// Check whether we can reuse the same Tokens with the previous layer. This happens</span></span><br><span class="line">                <span class="comment">// if the previous layer is the same type as the current layer AND there is no</span></span><br><span class="line">                <span class="comment">// feature that applies to only one of them.</span></span><br><span class="line">                <span class="comment">//leafArea空，或者leafArea本身不和这个layer共用一个父节点</span></span><br><span class="line">                <span class="keyword">if</span> (leafArea == <span class="keyword">null</span> || leafArea.mParent != areaForLayer[layer]</span><br><span class="line">                        || type != leafType) &#123;</span><br><span class="line">                    <span class="comment">// Create a new Tokens for this layer.</span></span><br><span class="line">                    leafArea = <span class="keyword">new</span> PendingArea(<span class="keyword">null</span> <span class="comment">/* feature */</span>, layer, areaForLayer[layer]);</span><br><span class="line">                    areaForLayer[layer].mChildren.add(leafArea);</span><br><span class="line">                    leafType = type;</span><br><span class="line">                    <span class="comment">//针对属于TYPE_INPUT_METHOD  APPLICATION_LAYER特殊处理</span></span><br><span class="line">                    <span class="keyword">if</span> (leafType == LEAF_TYPE_TASK_CONTAINERS) &#123;</span><br><span class="line">                        <span class="comment">// We use the passed in TaskDisplayAreas for task container type of layer.</span></span><br><span class="line">                        <span class="comment">// Skip creating Tokens even if there is no TDA.</span></span><br><span class="line">                        <span class="comment">///APPLICATION_LAYER单独处理，就是前面设置过的TaskDisplayArea</span></span><br><span class="line">                        <span class="comment">//设置本身已经设置过的TaskDisplayArea单独处理</span></span><br><span class="line">                        addTaskDisplayAreasToApplicationLayer(areaForLayer[layer]);</span><br><span class="line">                        addDisplayAreaGroupsToApplicationLayer(areaForLayer[layer],</span><br><span class="line">                                displayAreaGroupHierarchyBuilders);</span><br><span class="line">                        <span class="comment">//设置跳过</span></span><br><span class="line">                        leafArea.mSkipTokens = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leafType == LEAF_TYPE_IME_CONTAINERS) &#123;</span><br><span class="line">                        <span class="comment">// We use the passed in ImeContainer for ime container type of layer.</span></span><br><span class="line">                        <span class="comment">// Skip creating Tokens even if there is no ime container.</span></span><br><span class="line">                        leafArea.mExisting = mImeContainer;</span><br><span class="line">                        leafArea.mSkipTokens = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                leafArea.mMaxLayer = layer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算出每个节点最大layer值</span></span><br><span class="line">            root.computeMaxLayer();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We built a tree of PendingAreas above with all the necessary info to represent the</span></span><br><span class="line">            <span class="comment">// hierarchy, now create and attach real DisplayAreas to the root.</span></span><br><span class="line">            <span class="comment">//把PendingArea生成DisplayArea，这里的参数mRoot就是我们的DisplayContent，Root：0：0这个PendingArea</span></span><br><span class="line">            root.instantiateChildren(mRoot, displayAreaForLayer, <span class="number">0</span>, featureAreas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Notify the root that we have finished attaching all the DisplayAreas. Cache all the</span></span><br><span class="line">            <span class="comment">// feature related collections there for fast access.</span></span><br><span class="line">            mRoot.onHierarchyBuilt(mFeatures, displayAreaForLayer, featureAreas);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>大概步骤如下：</p>
<ol>
<li>创建PendingArea作为root部分</li>
<li>根据之前的几个Feature的配置进行树图构造</li>
<li>根据窗口层级0~36层，每一层进行遍历，挂载一个新的叶子TOKENS节点，规则和前面Feature一样，如果同一个父亲则不需要新生成，针对TYPE_INPUT_METHOD和APPLICATION_LAYER需要进行特殊处理</li>
<li>把PendingArea生成DisplayArea</li>
</ol>
<h5 id="添加层级树"><a href="#添加层级树" class="headerlink" title="添加层级树"></a>添加层级树</h5><p>1、Task、ActivityRecord的添加<br>2、普通WindowToken的添加</p>
<p><strong>Task的添加</strong></p>
<p>DefaultTaskDisplayArea -&gt; Task -&gt;ActivityRecord</p>
<p>在WindowContainer添加堆栈打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addChild</span><span class="params">(E child, Comparator&lt;E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(child <span class="keyword">instanceof</span> Task || child <span class="keyword">instanceof</span> ActivityRecord || child <span class="keyword">instanceof</span> WindowState)&#123;</span><br><span class="line">            android.util.Log.i(<span class="string">"WMSWtf"</span>,<span class="keyword">this</span> + <span class="string">" addChild Comparator c="</span> + child,<span class="keyword">new</span> Exception());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addChild</span><span class="params">(E child, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(child <span class="keyword">instanceof</span> Task || child <span class="keyword">instanceof</span> ActivityRecord || child <span class="keyword">instanceof</span> WindowState)&#123;</span><br><span class="line">            android.util.Log.i(<span class="string">"WMSWtf"</span>,<span class="keyword">this</span> + <span class="string">" addChild index c="</span> + child,<span class="keyword">new</span> Exception());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开电话应用堆栈日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DefaultTaskDisplayArea@171686050 addChild index c&#x3D;Task&#123;56a0fdb #208 type&#x3D;standard ?? U&#x3D;0 visible&#x3D;false visibleRequested&#x3D;false mode&#x3D;undefined translucent&#x3D;true sz&#x3D;0&#125;</span><br><span class="line">	at com.android.server.wm.WindowContainer.addChild(WindowContainer.java:727)</span><br><span class="line">	at com.android.server.wm.TaskDisplayArea.addChildTask(TaskDisplayArea.java:334)</span><br><span class="line">	at com.android.server.wm.TaskDisplayArea.addChild(TaskDisplayArea.java:320)</span><br><span class="line">	at com.android.server.wm.Task$Builder.build(Task.java:6551)</span><br><span class="line">	at com.android.server.wm.TaskDisplayArea.getOrCreateRootTask(TaskDisplayArea.java:1005)</span><br><span class="line">	at com.android.server.wm.TaskDisplayArea.getOrCreateRootTask(TaskDisplayArea.java:1030)</span><br><span class="line">	at com.android.server.wm.RootWindowContainer.getOrCreateRootTask(RootWindowContainer.java:2838)</span><br><span class="line">	at com.android.server.wm.ActivityStarter.getOrCreateRootTask(ActivityStarter.java:3017)</span><br><span class="line">	at com.android.server.wm.ActivityStarter.startActivityInner(ActivityStarter.java:1858)</span><br><span class="line">	at com.android.server.wm.ActivityStarter.startActivityUnchecked(ActivityStarter.java:1661)</span><br><span class="line">	at com.android.server.wm.ActivityStarter.executeRequest(ActivityStarter.java:1216)</span><br><span class="line">	at com.android.server.wm.ActivityStarter.execute(ActivityStarter.java:702)</span><br><span class="line">	at  		com.android.server.wm.ActivityTaskManagerService.startActivityAsUser(ActivityTaskManagerService.java:1240)</span><br><span class="line">	at com.android.server.wm.ActivityTaskManagerService.startActivityAsUser(ActivityTaskManagerService.java:1203)</span><br><span class="line">	at com.android.server.wm.ActivityTaskManagerService.startActivity(ActivityTaskManagerService.java:1178)</span><br><span class="line">	at android.app.IActivityTaskManager$Stub.onTransact(IActivityTaskManager.java:893)</span><br><span class="line">	at com.android.server.wm.ActivityTaskManagerService.onTransact(ActivityTaskManagerService.java:5183)</span><br><span class="line">	at android.os.Binder.execTransactInternal(Binder.java:1280)</span><br><span class="line">	at android.os.Binder.execTransact(Binder.java:1244)</span><br><span class="line">	</span><br><span class="line">Task&#123;56a0fdb #208 type&#x3D;standard A&#x3D;10075:com.android.dialer U&#x3D;0 visible&#x3D;false visibleRequested&#x3D;false mode&#x3D;fullscreen translucent&#x3D;true sz&#x3D;0&#125; addChild index c&#x3D;ActivityRecord&#123;87c5551 u0</span><br><span class="line">	at com.android.server.wm.WindowContainer.addChild(WindowContainer.java:727)</span><br><span class="line">	at com.android.server.wm.TaskFragment.addChild(TaskFragment.java:1835)</span><br><span class="line">	at com.android.server.wm.Task.addChild(Task.java:1429)</span><br><span class="line">	at com.android.server.wm.ActivityStarter.addOrReparentStartingActivity(ActivityStarter.java:2927)</span><br><span class="line">	at com.android.server.wm.ActivityStarter.setNewTask(ActivityStarter.java:2877)</span><br><span class="line">	at com.android.server.wm.ActivityStarter.startActivityInner(ActivityStarter.java:1864)</span><br><span class="line">	at com.android.server.wm.ActivityStarter.startActivityUnchecked(ActivityStarter.java:1661)</span><br><span class="line">	at com.android.server.wm.ActivityStarter.executeRequest(ActivityStarter.java:1216)</span><br><span class="line">	at com.android.server.wm.ActivityStarter.execute(ActivityStarter.java:702)</span><br><span class="line">	at com.android.server.wm.ActivityTaskManagerService.startActivityAsUser(ActivityTaskManagerService.java:1240)</span><br><span class="line">	at com.android.server.wm.ActivityTaskManagerService.startActivityAsUser(ActivityTaskManagerService.java:1203)</span><br><span class="line">	at com.android.server.wm.ActivityTaskManagerService.startActivity(ActivityTaskManagerService.java:1178)</span><br><span class="line">	at android.app.IActivityTaskManager$Stub.onTransact(IActivityTaskManager.java:893)</span><br><span class="line">	at com.android.server.wm.ActivityTaskManagerService.onTransact(ActivityTaskManagerService.java:5183)</span><br><span class="line">	at android.os.Binder.execTransactInternal(Binder.java:1280)</span><br><span class="line">	at android.os.Binder.execTransact(Binder.java:1244)</span><br><span class="line">	</span><br><span class="line">ActivityRecord&#123;87c5551 u0 com.android.dialer&#x2F;.main.impl.MainActivity&#125; t208&#125; addChild Comparator c&#x3D;Window&#123;736e5ab u0 com.android.dialer&#x2F;com.android.dialer.main.impl.MainActivity&#125;</span><br><span class="line">	at com.android.server.wm.WindowContainer.addChild(WindowContainer.java:694)</span><br><span class="line">	at com.android.server.wm.WindowToken.addWindow(WindowToken.java:302)</span><br><span class="line">	at com.android.server.wm.ActivityRecord.addWindow(ActivityRecord.java:4212)</span><br><span class="line">	at com.android.server.wm.WindowManagerService.addWindow(WindowManagerService.java:1773)</span><br><span class="line">	at com.android.server.wm.Session.addToDisplayAsUser(Session.java:209)</span><br><span class="line">	at android.view.IWindowSession$Stub.onTransact(IWindowSession.java:652)</span><br><span class="line">	at com.android.server.wm.Session.onTransact(Session.java:175)</span><br><span class="line">	at android.os.Binder.execTransactInternal(Binder.java:1285)</span><br><span class="line">	at android.os.Binder.execTransact(Binder.java:1244)</span><br></pre></td></tr></table></figure>

<p><strong>普通WindowToken的添加</strong></p>
<p>Leaf容器加入StatusBar的WindowToken对应堆栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Leaf:15:15@65133355 addChild Comparator child &#x3D; WindowToken&#123;9dd676f type&#x3D;2000 android.os.BinderProxy@ce5e149&#125;</span><br><span class="line">at com.android.server.wm.WindowContainer.addChild</span><br><span class="line">at com.android.server.wm.WindowManagerService.addWindow</span><br><span class="line">at com.android.server.wm.Session.addToDisplayAsUser</span><br></pre></td></tr></table></figure>

<p>WindowToken加入对应的StatusBar 的WindowState</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WindowToken&#123;9dd676f type&#x3D;2000 android.os.BinderProxy@ce5e149&#125; addChild Comparator child &#x3D; Window&#123;b94d567 u0 StatusBar&#125;</span><br><span class="line">at com.android.server.wm.WindowContainer.addChild</span><br><span class="line">at com.android.server.wm.WindowToken.addWindow</span><br><span class="line">at com.android.server.wm.WindowManagerService.addWindow</span><br><span class="line">at com.android.server.wm.Session.addToDisplayAsUser</span><br></pre></td></tr></table></figure>


<h5 id="添加Window操作"><a href="#添加Window操作" class="headerlink" title="添加Window操作"></a>添加Window操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, LayoutParams attrs, <span class="keyword">int</span> viewVisibility,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> displayId, <span class="keyword">int</span> requestUserId, InsetsVisibilities requestedVisibilities,</span></span></span><br><span class="line"><span class="function"><span class="params">            InputChannel outInputChannel, InsetsState outInsetsState,</span></span></span><br><span class="line"><span class="function"><span class="params">            InsetsSourceControl[] outActiveControls)</span> </span>&#123;</span><br><span class="line">       		...</span><br><span class="line">            ActivityRecord activity = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> hasParent = parentWindow != <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// Use existing parent window token for child windows since they go in the same token</span></span><br><span class="line">            <span class="comment">// as there parent window so we can apply the same policy on them.</span></span><br><span class="line">            WindowToken token = displayContent.getWindowToken(</span><br><span class="line">                    hasParent ? parentWindow.mAttrs.token : attrs.token);</span><br><span class="line">            <span class="comment">// If this is a child window, we want to apply the same type checking rules as the</span></span><br><span class="line">            <span class="comment">// parent window type.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> rootType = hasParent ? parentWindow.mAttrs.type : type;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> addToastWindowRequiresToken = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> IBinder windowContextToken = attrs.mWindowContextToken;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;<span class="comment">//系统窗口我们在app层面没有设置对应的token故为null</span></span><br><span class="line">                <span class="keyword">if</span> (!unprivilegedAppCanCreateTokenWith(parentWindow, callingUid, type,</span><br><span class="line">                        rootType, attrs.token, attrs.packageName)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (hasParent) &#123;</span><br><span class="line">                ...</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mWindowContextListenerController.hasListener(windowContextToken)) &#123;</span><br><span class="line">                 ...</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//最后进入这里</span></span><br><span class="line">                    <span class="keyword">final</span> IBinder binder = attrs.token != <span class="keyword">null</span> ? attrs.token : client.asBinder();</span><br><span class="line">                    token = <span class="keyword">new</span> WindowToken.Builder(<span class="keyword">this</span>, binder, type)<span class="comment">//构造对应的WindowToken容器</span></span><br><span class="line">                            .setDisplayContent(displayContent)</span><br><span class="line">                            .setOwnerCanManageAppTokens(session.mCanAddInternalSystemWindow)</span><br><span class="line">                            .setRoundedCornerOverlay(isRoundedCornerOverlay)</span><br><span class="line">                            .build();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">             ...</span><br><span class="line">             <span class="comment">//基于token构造对应WindowState</span></span><br><span class="line">            <span class="keyword">final</span> WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token, parentWindow,</span><br><span class="line">                    appOp[<span class="number">0</span>], attrs, viewVisibility, session.mUid, userId,</span><br><span class="line">                    session.mCanAddInternalSystemWindow);</span><br><span class="line">          </span><br><span class="line">            <span class="comment">//校验一些策略</span></span><br><span class="line">            <span class="keyword">final</span> DisplayPolicy displayPolicy = displayContent.getDisplayPolicy();</span><br><span class="line">            displayPolicy.adjustWindowParamsLw(win, win.mAttrs);</span><br><span class="line">            attrs.flags = sanitizeFlagSlippery(attrs.flags, win.getName(), callingUid, callingPid);</span><br><span class="line">            attrs.inputFeatures = sanitizeSpyWindow(attrs.inputFeatures, win.getName(), callingUid,</span><br><span class="line">                    callingPid);</span><br><span class="line">            win.setRequestedVisibilities(requestedVisibilities);</span><br><span class="line">            <span class="comment">//检验是否有权限加入</span></span><br><span class="line">            res = displayPolicy.validateAddingWindowLw(attrs, callingPid, callingUid);</span><br><span class="line">            <span class="keyword">if</span> (res != ADD_OKAY) &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//开启与InputDispatcher通信的Socketpair</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> openInputChannels = (outInputChannel != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>  (openInputChannels) &#123;</span><br><span class="line">                win.openInputChannel(outInputChannel);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            win.attach();</span><br><span class="line">            <span class="comment">//装入容器，后面可以根据binder直接获取winstate</span></span><br><span class="line">            mWindowMap.put(client.asBinder(), win);</span><br><span class="line">            win.initAppOpsState();</span><br><span class="line">   			...</span><br><span class="line"></span><br><span class="line">            win.mToken.addWindow(win);</span><br><span class="line">            displayPolicy.addWindowLw(win, attrs);</span><br><span class="line">            displayPolicy.setDropInputModePolicy(win, win.mAttrs);</span><br><span class="line">            ...     </span><br><span class="line">        &#125;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>总结addWindow主要干了以下几件事：</p>
<ol>
<li>创建WindowToken并挂载到对应的节点层级</li>
<li>WindowState初始化和相关变量设置校验</li>
<li>开启与InputDispatcher通信的Socketpair</li>
<li>WindowState挂载到WindowToken</li>
</ol>
<h5 id="relayout操作"><a href="#relayout操作" class="headerlink" title="relayout操作"></a>relayout操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(Session session, IWindow client, LayoutParams attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">            ClientWindowFrames outFrames, MergedConfiguration mergedConfiguration,</span></span></span><br><span class="line"><span class="function"><span class="params">            SurfaceControl outSurfaceControl, InsetsState outInsetsState,</span></span></span><br><span class="line"><span class="function"><span class="params">            InsetsSourceControl[] outActiveControls, Bundle outSyncIdBundle)</span> </span>&#123;</span><br><span class="line">   			<span class="comment">//根据client找到对应的WindowState </span></span><br><span class="line">            <span class="keyword">final</span> WindowState win = windowForClientLocked(session, client, <span class="keyword">false</span>);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// Create surfaceControl before surface placement otherwise layout will be skipped</span></span><br><span class="line">            <span class="comment">// (because WS.isGoneForLayout() is true when there is no surface.</span></span><br><span class="line">            <span class="keyword">if</span> (shouldRelayout) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//创建对应的window需要的SurfaceControl，传递回应用，应用用他进行绘制</span></span><br><span class="line">                    result = createSurfaceControl(outSurfaceControl, result, win, winAnimator);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//调用最核心的performSurfacePlacement进行相关的layout操作</span></span><br><span class="line">            <span class="comment">// We may be deferring layout passes at the moment, but since the client is interested</span></span><br><span class="line">            <span class="comment">// in the new out values right now we need to force a layout.</span></span><br><span class="line">            mWindowPlacerLocked.performSurfacePlacement(<span class="keyword">true</span> <span class="comment">/* force */</span>);</span><br><span class="line">			...</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> (!win.isGoneForLayout()) &#123;</span><br><span class="line">                win.mResizedWhileGone = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> 			<span class="comment">//把相关config数据填回去</span></span><br><span class="line">            win.fillClientWindowFramesAndConfiguration(outFrames, mergedConfiguration,</span><br><span class="line">                    <span class="keyword">false</span> <span class="comment">/* useLatestConfig */</span>, shouldRelayout);</span><br><span class="line">            <span class="comment">//把相关inset数据设置回去</span></span><br><span class="line">            outInsetsState.set(win.getCompatInsetsState(), win.isClientLocal());</span><br><span class="line">            ...</span><br><span class="line">            getInsetsSourceControls(win, outActiveControls);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>主要就有2个最关键步骤：<br>1、创建对应Window的SurfaceControl<br>2、计算出对应的window区域等，把inset和config传递回去</p>
<h5 id="窗口动画"><a href="#窗口动画" class="headerlink" title="窗口动画"></a>窗口动画</h5><p>Animator 对SurfaceA进行动画控制Matrix(放大缩小位移)alpha圆角等</p>
<ul>
<li>LocalAnimation：systemserver自己在WindowAnimator类进行动画播放控制</li>
<li>RemoteAnimation：systemserver负责提供对应的SurfaceControl给远端进程让远端进行动画播放控制</li>
</ul>
<p>窗口动画执行执行过程中会在窗口层级树中窗口节点和父节点中间插入一个leash节点对窗口进行控制，播放结束移除节点</p>
<h5 id="Activity添加显示过程"><a href="#Activity添加显示过程" class="headerlink" title="Activity添加显示过程"></a>Activity添加显示过程</h5><ol>
<li><p>Activity#attach()方法之内PhoneWindow被创建，并同时创建一WindowManagerImpl负责维护PhoneWindow内的内容。  </p>
</li>
<li><p>在Activity#onCreate()中调用setContentView()方法，这个方法内部创建一个DecorView实例作为PhoneWindow的实体内容。                 </p>
</li>
<li><p>WindowManagerImpl决定管理DecorView，并创建一个ViewRootImpl实例,将ViewRootImpl与View树进行关联，这样ViewRootImpl就可以指挥View树的具体工作。</p>
</li>
<li><p>Activity resume时调用WindowManagerImpl.addView然后一步步调用WMS中的Window添加。</p>
</li>
</ol>
<p>DecorView是FrameLayout的子类，它可以被认为是Android视图树的根节点视图。</p>
<p>在Activity的生命周期onCreate方法里面，是会设置好布局内容通过setContentView(布局id)的方式，这里是通过xml解析器转化为一个View，这个View会被添加到ContentView中去，成为唯一的子View。</p>
<p>WindowManagerGlobal是一个单例类，一个进程只有一个实例。它管理者所有Window的ViewRootImpl、DecorView、LayoutParams。</p>
<p>ViewRootImpl是View树的树根，但它却又不是View，实现了View与WindowManager之间的通信协议，在WindowManagerGloble中的addView中被建立，是顶层DecorView的ViewParent</p>
<ul>
<li><p>View树的树根并管理View树</p>
</li>
<li><p>触发View的测量、布局和绘制</p>
</li>
<li><p>输入响应的中转站</p>
</li>
<li><p>负责与WMS进行进程间通信。</p>
</li>
</ul>
<p>WMS是窗口的管理者，它负责窗口的启动、添加和删除，窗口动画。另外窗口的大小和层级也是由WMS进行管理的。WMS中对应的窗口在SurfaceFlinger中都有对应的layer对应，后续有机会看SurfaceFlinger代码再具体分析，还有窗口相关的事件分发处理。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统源码</tag>
      </tags>
  </entry>
  <entry>
    <title>AMS及Activity启动总结</title>
    <url>/2023/09/19/FW%20AMS%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>ActivityManagerService是Android系统中一个特别重要的系统服务，由SytemServer启动，运行在SytemServer进程。也是上层APP打交道最多的系统服务之一。ActivityManagerService（以下简称AMS） 主要负责<strong>四大组件的启动、切换、调度以及应用进程的管理和调度工作</strong>。所有的APP应用都需要与AMS打交道。</p>
<p>Activity Manager的组成主要分为以下几个部分：</p>
<ol>
<li>服务代理：由ActivityManagerProxy实现，用于与Server端提供的系统服务进行进程间通信</li>
<li>服务中枢：ActivityManagerNative继承自Binder并实现IActivityManager，它提供了服务接口和Binder接口的相互转化功能，并在内部存储服务代理对像，并提供了getDefault方法返回服务代理</li>
<li>Client：由ActivityManager封装一部分服务接口供Client调用。ActivityManager内部通过调用ActivityManagerNative的getDefault方法，可以得到一个ActivityManagerProxy对像的引用，进而通过该代理对像调用远程服务的方法</li>
<li>Server:由ActivityManagerService实现，提供Server端的系统服务</li>
</ol>
<h4 id="AMS的启动过程"><a href="#AMS的启动过程" class="headerlink" title="AMS的启动过程"></a>AMS的启动过程</h4><p>AMS是在SystemServer中被添加的， 所以先到SystemServer中查看初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    createSystemContext();</span><br><span class="line">    <span class="comment">// Create the system service manager.</span></span><br><span class="line">    mSystemServiceManager = <span class="keyword">new</span> </span><br><span class="line">	SystemServiceManager(mSystemContext);</span><br><span class="line">    mSystemServiceManager.setStartInfo(mRuntimeRestart,</span><br><span class="line">                    mRuntimeStartElapsedTime, mRuntimeStartUptime);</span><br><span class="line">    LocalServices.addService(SystemServiceManager<span class="class">.<span class="keyword">class</span>, <span class="title">mSystemServiceManager</span>)</span>;</span><br><span class="line">    startBootstrapServices();</span><br><span class="line">    startCoreServices();</span><br><span class="line">    startOtherServices();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在SystemServer中，在startBootstrapServices()中去启动了AMS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Installer installer = mSystemServiceManager.startService(Installer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    mSystemServiceManager.startService(PowerStatsService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// Activity manager runs the show.</span></span><br><span class="line">     t.traceBegin(<span class="string">"StartActivityManager"</span>);</span><br><span class="line">    <span class="comment">//启动ATMS和AMS</span></span><br><span class="line">     ActivityTaskManagerService atm = mSystemServiceManager.startService(</span><br><span class="line">                ActivityTaskManagerService.Lifecycle<span class="class">.<span class="keyword">class</span>).<span class="title">getService</span>()</span>;</span><br><span class="line">     mActivityManagerService = ActivityManagerService.Lifecycle.startService(</span><br><span class="line">                mSystemServiceManager, atm);</span><br><span class="line">     mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">     mActivityManagerService.setInstaller(installer);</span><br><span class="line">     mWindowManagerGlobalLock = atm.getGlobalLock();</span><br><span class="line">        t.traceEnd();</span><br><span class="line">     <span class="comment">// Set up the Application instance for the system process and get started.</span></span><br><span class="line">     t.traceBegin(<span class="string">"SetSystemProcess"</span>);</span><br><span class="line">     mActivityManagerService.setSystemProcess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AMS是通过SystemServiceManager.startService去启动的，参数是ActivityManagerService.Lifecycle.class， 首先看看startService方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">frameworks/base/services/core/java/com/android/server/SystemServiceManager.java</span><br><span class="line"> <span class="keyword">public</span> &lt;T extends SystemService&gt; <span class="function">T <span class="title">startService</span><span class="params">(Class&lt;T&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">    Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    service = constructor.newInstance(mContext);</span><br><span class="line">    startService(service);</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startService</span><span class="params">(@NonNull <span class="keyword">final</span> SystemService service)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Check if already started</span></span><br><span class="line">        String className = service.getClass().getName();</span><br><span class="line">        mServiceClassnames.add(className);</span><br><span class="line">        <span class="comment">// Register it.</span></span><br><span class="line">        mServices.add(service);</span><br><span class="line">        service.onStart();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>startService方法很简单，是通过传进来的class然后反射创建对应的service服务。所以此处创建的是Lifecycle的实例， 然后通过startService启动了AMS服务，那再去看看ActivityManagerService.Lifecycle这个类的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> ActivityManagerService mService;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Lifecycle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">super</span>(context);</span><br><span class="line">           mService = <span class="keyword">new</span> ActivityManagerService(context);</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           mService.start();</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> ActivityManagerService <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> mService;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>再来看下AMS初始化做了什么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ActivityManagerService</span><span class="params">(Context systemContext)</span> </span>&#123;</span><br><span class="line">        LockGuard.installLock(<span class="keyword">this</span>, LockGuard.INDEX_ACTIVITY);</span><br><span class="line">        mInjector = <span class="keyword">new</span> Injector();</span><br><span class="line">        mContext = systemContext;<span class="comment">//赋值mContext</span></span><br><span class="line">        mFactoryTest = FactoryTest.getMode();</span><br><span class="line">        mSystemThread = ActivityThread.currentActivityThread();<span class="comment">//获取当前的ActivityThread</span></span><br><span class="line">        mUiContext = mSystemThread.getSystemUiContext();<span class="comment">//赋值mUiContext</span></span><br><span class="line">	<span class="comment">//创建Handler线程，用来处理handler消息</span></span><br><span class="line">        mHandlerThread = <span class="keyword">new</span> ServiceThread(TAG,</span><br><span class="line">                THREAD_PRIORITY_FOREGROUND, <span class="keyword">false</span> <span class="comment">/*allowIo*/</span>);</span><br><span class="line">        mHandlerThread.start();</span><br><span class="line">        mHandler = <span class="keyword">new</span> MainHandler(mHandlerThread.getLooper());</span><br><span class="line">        mUiHandler = mInjector.getUiHandler(<span class="keyword">this</span>);<span class="comment">//处理ui相关msg的Handler</span></span><br><span class="line"></span><br><span class="line">        mProcStartHandlerThread = <span class="keyword">new</span> ServiceThread(TAG + <span class="string">":procStart"</span>,</span><br><span class="line">                THREAD_PRIORITY_FOREGROUND, <span class="keyword">false</span> <span class="comment">/* allowIo */</span>);</span><br><span class="line">        mProcStartHandlerThread.start();</span><br><span class="line">        mProcStartHandler = <span class="keyword">new</span> Handler(mProcStartHandlerThread.getLooper());</span><br><span class="line"><span class="comment">//管理AMS的一些常量，厂商定制系统就可能修改此处</span></span><br><span class="line">        mConstants = <span class="keyword">new</span> ActivityManagerConstants(<span class="keyword">this</span>, mHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* static; one-time init here */</span></span><br><span class="line">        <span class="keyword">if</span> (sKillHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sKillThread = <span class="keyword">new</span> ServiceThread(TAG + <span class="string">":kill"</span>,</span><br><span class="line">                    THREAD_PRIORITY_BACKGROUND, <span class="keyword">true</span> <span class="comment">/* allowIo */</span>);</span><br><span class="line">            sKillThread.start();</span><br><span class="line">            sKillHandler = <span class="keyword">new</span> KillHandler(sKillThread.getLooper());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//初始化管理前台、后台广播的队列， 系统会优先遍历发送前台广播</span></span><br><span class="line">        mFgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">                <span class="string">"foreground"</span>, BROADCAST_FG_TIMEOUT, <span class="keyword">false</span>);</span><br><span class="line">        mBgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">                <span class="string">"background"</span>, BROADCAST_BG_TIMEOUT, <span class="keyword">true</span>);</span><br><span class="line">        mBroadcastQueues[<span class="number">0</span>] = mFgBroadcastQueue;</span><br><span class="line">        mBroadcastQueues[<span class="number">1</span>] = mBgBroadcastQueue;</span><br><span class="line"><span class="comment">//初始化管理Service的 ActiveServices对象</span></span><br><span class="line">        mServices = <span class="keyword">new</span> ActiveServices(<span class="keyword">this</span>);</span><br><span class="line">        mProviderMap = <span class="keyword">new</span> ProviderMap(<span class="keyword">this</span>);<span class="comment">//初始化Provider的管理者</span></span><br><span class="line">        mAppErrors = <span class="keyword">new</span> AppErrors(mUiContext, <span class="keyword">this</span>);<span class="comment">//初始化APP错误日志的打印器</span></span><br><span class="line">	<span class="comment">//创建电池统计服务， 并输出到指定目录</span></span><br><span class="line">        File dataDir = Environment.getDataDirectory();</span><br><span class="line">        File systemDir = <span class="keyword">new</span> File(dataDir, <span class="string">"system"</span>);</span><br><span class="line">        systemDir.mkdirs();</span><br><span class="line">      mAppWarnings = <span class="keyword">new</span> AppWarnings(<span class="keyword">this</span>, mUiContext, mHandler, mUiHandler, systemDir);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Move creation of battery stats service outside of activity manager service.</span></span><br><span class="line">        mBatteryStatsService = <span class="keyword">new</span> BatteryStatsService(systemContext, systemDir, mHandler);</span><br><span class="line">        mBatteryStatsService.getActiveStatistics().readLocked();</span><br><span class="line">        mBatteryStatsService.scheduleWriteToDisk();</span><br><span class="line">        mOnBattery = DEBUG_POWER ? <span class="keyword">true</span></span><br><span class="line">         <span class="comment">//创建进程统计分析服务，追踪统计哪些进程有滥用或不良行为       : </span></span><br><span class="line">mBatteryStatsService.getActiveStatistics().getIsOnBattery();</span><br><span class="line">        mBatteryStatsService.getActiveStatistics().setCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        mProcessStats = <span class="keyword">new</span> ProcessStatsService(<span class="keyword">this</span>, <span class="keyword">new</span> File(systemDir, <span class="string">"procstats"</span>));</span><br><span class="line"></span><br><span class="line">        mAppOpsService = mInjector.getAppOpsService(<span class="keyword">new</span> File(systemDir, <span class="string">"appops.xml"</span>), mHandler);</span><br><span class="line"><span class="comment">//加载Uri的授权文件</span></span><br><span class="line">        mGrantFile = <span class="keyword">new</span> AtomicFile(<span class="keyword">new</span> File(systemDir, <span class="string">"urigrants.xml"</span>), <span class="string">"uri-grants"</span>);</span><br><span class="line"><span class="comment">//负责管理多用户</span></span><br><span class="line">        mUserController = <span class="keyword">new</span> UserController(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//vr功能的控制器</span></span><br><span class="line">        mVrController = <span class="keyword">new</span> VrController(<span class="keyword">this</span>);</span><br><span class="line">  	<span class="comment">//初始化OpenGL版本号</span></span><br><span class="line">        GL_ES_VERSION = SystemProperties.getInt(<span class="string">"ro.opengles.version"</span>,</span><br><span class="line">            ConfigurationInfo.GL_ES_VERSION_UNDEFINED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SystemProperties.getInt(<span class="string">"sys.use_fifo_ui"</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            mUseFifoUiScheduling = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mTrackingAssociations = <span class="string">"1"</span>.equals(SystemProperties.get(<span class="string">"debug.track-associations"</span>));</span><br><span class="line">        mTempConfig.setToDefaults();</span><br><span class="line">        mTempConfig.setLocales(LocaleList.getDefault());</span><br><span class="line">        mConfigurationSeq = mTempConfig.seq = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//管理ActivityStack的重要类，这里面记录着activity状态信息，是AMS中的核心类</span></span><br><span class="line">        mStackSupervisor = createStackSupervisor();</span><br><span class="line">        mStackSupervisor.onConfigurationChanged(mTempConfig);</span><br><span class="line">        <span class="comment">//根据当前可见的Activity类型，控制Keyguard遮挡，关闭和转换。 Keyguard就是我们的锁屏相关页面    </span></span><br><span class="line">        mKeyguardController = mStackSupervisor.getKeyguardController();</span><br><span class="line">        <span class="comment">//管理APK的兼容性配置解析/data/system/packages-compat.xml文件，该文件用于存储那些需要考虑屏幕尺寸的APK信息，</span></span><br><span class="line">        mCompatModePackages = <span class="keyword">new</span> CompatModePackages(<span class="keyword">this</span>, systemDir, mHandler);</span><br><span class="line">        <span class="comment">//Intent防火墙，Google定义了一组规则，来过滤intent，如果触发了，则intent会被系统丢弃，且不会告知发送者</span></span><br><span class="line">        mIntentFirewall = <span class="keyword">new</span> IntentFirewall(<span class="keyword">new</span> IntentFirewallInterface(), mHandler);</span><br><span class="line">        mTaskChangeNotificationController =</span><br><span class="line">                         <span class="keyword">new</span> TaskChangeNotificationController(<span class="keyword">this</span>, mStackSupervisor, mHandler);</span><br><span class="line">        <span class="comment">//这是activity启动的处理类，这里管理者activity启动中用到的intent信息和flag标识，也和stack和task有重要的联系     </span></span><br><span class="line">        mActivityStartController = <span class="keyword">new</span> ActivityStartController(<span class="keyword">this</span>);</span><br><span class="line">        mRecentTasks = createRecentTasks();</span><br><span class="line">        mStackSupervisor.setRecentTasks(mRecentTasks);</span><br><span class="line">        mLockTaskController = <span class="keyword">new</span> LockTaskController(mContext, mStackSupervisor, mHandler);</span><br><span class="line">        mLifecycleManager = <span class="keyword">new</span> ClientLifecycleManager();</span><br><span class="line">  	<span class="comment">//启动一个线程专门跟进cpu当前状态信息，AMS对当前cpu状态了如指掌，可以更加高效的安排其他工作</span></span><br><span class="line">        mProcessCpuThread = <span class="keyword">new</span> Thread(<span class="string">"CpuTracker"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mProcessCpuTracker) &#123;</span><br><span class="line">                    mProcessCpuInitLatch.countDown();</span><br><span class="line">                    mProcessCpuTracker.init();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    updateCpuStatsNow();</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        mHiddenApiBlacklist = <span class="keyword">new</span> HiddenApiSettings(mHandler, mContext);</span><br><span class="line"><span class="comment">//看门狗，监听进程。这个类每分钟调用一次监视器。 如果进程没有任何返回就杀掉</span></span><br><span class="line">        Watchdog.getInstance().addMonitor(<span class="keyword">this</span>);</span><br><span class="line">        Watchdog.getInstance().addThread(mHandler);</span><br><span class="line">      <span class="comment">//更新进程优先级，根据当前内存状态和优先级判断是否需要kill掉进程</span></span><br><span class="line">      updateOomAdjLocked();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        removeAllProcessGroups();</span><br><span class="line">        mProcessCpuThread.start();</span><br><span class="line">        mBatteryStatsService.publish();</span><br><span class="line">        mAppOpsService.publish(mContext);</span><br><span class="line">        Slog.d(<span class="string">"AppOps"</span>, <span class="string">"AppOpsService published"</span>);</span><br><span class="line">        LocalServices.addService(ActivityManagerInternal<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">LocalService</span>())</span>;</span><br><span class="line">        <span class="comment">// Wait for the synchronized block started in mProcessCpuThread,</span></span><br><span class="line">        <span class="comment">// so that any other acccess to mProcessCpuTracker from main thread</span></span><br><span class="line">        <span class="comment">// will be blocked during mProcessCpuTracker initialization.</span></span><br><span class="line">         <span class="comment">//等待mProcessCpuThread完成初始化后， 释放锁，初始化期间禁止访问</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mProcessCpuInitLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">"Interrupted wait during start"</span>, e);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再看下setSystemProcess 干了什么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSystemProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           ServiceManager.addService(Context.ACTIVITY_SERVICE, <span class="keyword">this</span>, <span class="comment">/* allowIsolated= */</span> <span class="keyword">true</span>,</span><br><span class="line">                   DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PRIORITY_NORMAL | DUMP_FLAG_PROTO);</span><br><span class="line">           ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);</span><br><span class="line">           ServiceManager.addService(<span class="string">"meminfo"</span>, <span class="keyword">new</span> MemBinder(<span class="keyword">this</span>), <span class="comment">/* allowIsolated= */</span> <span class="keyword">false</span>,</span><br><span class="line">                   DUMP_FLAG_PRIORITY_HIGH);</span><br><span class="line">           ServiceManager.addService(<span class="string">"gfxinfo"</span>, <span class="keyword">new</span> GraphicsBinder(<span class="keyword">this</span>));</span><br><span class="line">           ServiceManager.addService(<span class="string">"dbinfo"</span>, <span class="keyword">new</span> DbBinder(<span class="keyword">this</span>));</span><br><span class="line">           <span class="keyword">if</span> (MONITOR_CPU_USAGE) &#123;</span><br><span class="line">               ServiceManager.addService(<span class="string">"cpuinfo"</span>, <span class="keyword">new</span> CpuBinder(<span class="keyword">this</span>)<span class="comment">/* allowIsolated= */</span> <span class="keyword">false</span>, </span><br><span class="line">							DUMP_FLAG_PRIORITY_CRITICAL);</span><br><span class="line">    		&#125;</span><br><span class="line">           ServiceManager.addService(<span class="string">"permission"</span>, <span class="keyword">new</span> PermissionController(<span class="keyword">this</span>));</span><br><span class="line">           ServiceManager.addService(<span class="string">"processinfo"</span>, <span class="keyword">new</span> ProcessInfoService(<span class="keyword">this</span>));</span><br><span class="line">           ApplicationInfo info = mContext.getPackageManager().getApplicationInfo(</span><br><span class="line">                   <span class="string">"android"</span>, STOCK_PM_FLAGS | MATCH_SYSTEM_ONLY);</span><br><span class="line">           mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());</span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">               ProcessRecord app = newProcessRecordLocked(info, info.processName, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">               app.persistent = <span class="keyword">true</span>;</span><br><span class="line">               app.pid = MY_PID;</span><br><span class="line">               app.maxAdj = ProcessList.SYSTEM_ADJ;</span><br><span class="line">               app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);</span><br><span class="line">               <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">                   mPidsSelfLocked.put(app.pid, app);</span><br><span class="line">               &#125;</span><br><span class="line">               updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">               updateOomAdjLocked();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                   <span class="string">"Unable to find android system package"</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// Start watching app ops after we and the package manager are up and running.</span></span><br><span class="line">       mAppOpsService.startWatchingMode(AppOpsManager.OP_RUN_IN_BACKGROUND, <span class="keyword">null</span>,</span><br><span class="line">               <span class="keyword">new</span> IAppOpsCallback.Stub() &#123;</span><br><span class="line">                   <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">opChanged</span><span class="params">(<span class="keyword">int</span> op, <span class="keyword">int</span> uid, String packageName)</span> </span>&#123;</span><br><span class="line">                       <span class="keyword">if</span> (op == AppOpsManager.OP_RUN_IN_BACKGROUND &amp;&amp; packageName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (mAppOpsService.checkOperation(op, uid, packageName)</span><br><span class="line">                                  != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                               runInBackgroundDisabled(uid);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>注册服务。首先将ActivityManagerService注册到ServiceManager中，其次将几个与系统性能调试相关的服务注册到ServiceManager。</p>
<p>查询并处理ApplicationInfo。首先调用PackageManagerService的接口，查询包名为android的应用程序的ApplicationInfo信息，对应于framework-res.apk。然后以该信息为参数调用ActivityThread上的installSystemApplicationInfo方法。</p>
<p>创建并处理ProcessRecord。调用ActivityManagerService上的newProcessRecordLocked，创建一个 ProcessRecord类型的对象，并保存该对象的信息。</p>
<h4 id="AMS是什么"><a href="#AMS是什么" class="headerlink" title="AMS是什么"></a>AMS是什么</h4><ol>
<li>从java角度来看，AMS就是一个java对象，实现了Ibinder接口，所以它是一个用于进程之间通信的 接口，这个对象初始化是在systemServer.java 的run()方法里面。</li>
<li>AMS是一个服务，ActivityManagerService从名字就可以看出，它是一个服务，用来管理Activity，而且是一个系统服务</li>
<li>AMS是一个Binder，AMS实现了Ibinder接口，所以它是一个Binder，这意味着他不但可以用于进程间通信，还是一个线程，因为一个Binder就是一个线程。</li>
</ol>
<h4 id="AMS相关重要类介绍"><a href="#AMS相关重要类介绍" class="headerlink" title="AMS相关重要类介绍"></a>AMS相关重要类介绍</h4><h5 id="ProcessRecord"><a href="#ProcessRecord" class="headerlink" title="ProcessRecord"></a>ProcessRecord</h5><p><strong>第一类数据：描述身份的数据</strong></p>
<ol>
<li>ApplicationInfo info：AndroidManifest.xml中定义的Application信息 </li>
<li>boolean isolated：是不是isolated进程 </li>
<li>int uid：进程uid </li>
<li>int userId：这个是android做的多用户系统id，就像windows可以登录很多用户一样，android 也希望可以实现类似的多用户 </li>
<li>String processName：进程名字，默认情况下是包名 </li>
<li>UidRecord uidRecord：记录已经使用的uid </li>
<li>IApplicationThread thread：这个很重要，它是ApplicationThread的客户端，AMS就是通过这个对象给apk进程发送异步消息的（管理四大组件的消息），所以只有这个对象不为空的情况下， 才代表apk进程可是使用了 </li>
<li>int pid：进程的pid </li>
<li>String procStatFile：proc目录下每一个进程都有一个以pid命名的目录文件，这个目录下记载着 进程的详细信息，这个目录及目录下的文件是内核创建的， proc是内核文件系统，proc就是 process的缩写，涉及的目的就是导出进程内核信息 </li>
<li>int[] gids：gid组 </li>
<li>CompatibilityInfo compat : 兼容性信息 </li>
<li>String requiredAbi : abi信息 </li>
<li>String instructionSet : 指令集信息</li>
</ol>
<p><strong>第二类数据：描述进程中组件的数据</strong></p>
<ol>
<li>pkgList：进程中运行的包 </li>
<li>ArraySet pkgDeps：进程运行依赖的包 </li>
<li>ArrayList activities：进程启动的所有的activity组件记录表 </li>
<li>ArraySet services：进程启动的所有的service组件记录表 </li>
<li>ArraySet executingServices：正在运行（executing）是怎么定义的？首先需要明确的是系统是怎么控制组件的？发送消息给apk进程，apk进程处理消息，上报消息完成，这被定义为一个完整的执行过程，因此正在执行（executing）被定义为发送消息到上报完成这段时间 </li>
<li>ArraySet connections：绑定service的客户端记录表 </li>
<li>ArraySet receivers：广播接收器的记录表 </li>
<li>ContentProviderRecord pubProviders：pub是publish（发布）的意思，ContentProvider需要 安装然后把自己发布到系统（AMS）中后，才能使用，安装指的是apk进程加载ContentProvider 子类、初始化、创建数据库等过程，发布是将ContentProvider的binder客户端注册到AMS中 </li>
<li>ArrayList conProviders：使用ContentProvider的客户端记录表 </li>
<li>BroadcastRecord curReceiver：当前进程正在执行的广播</li>
</ol>
<p><strong>第三类数据：描述进程状态的数据</strong></p>
<ol>
<li>int maxAdj：进程的adj上限（adjustment） </li>
<li>int curRawAdj：当前正在计算的adj，这个值有可能大于maxAdj </li>
<li>int setRawAdj：上次计算的curRawAdj设置到lowmemorykiller系统后的adj </li>
<li>int curAdj：当前正在计算的adj，这是curRawAdj被maxAdj削平的值 </li>
<li>int setAdj：上次计算的curAdj设置到lowmemorykiller系统后的adj </li>
<li>int verifiedAdj：setAdj校验后的值 </li>
<li>int curSchedGroup：正在计算的调度组 </li>
<li>int setSchedGroup：保存上次计算的调度组 </li>
<li>int curProcState：正在计算的进程状态 </li>
<li>int repProcState：发送给apk进程的状态 </li>
<li>int setProcState：保存上次计算的进程状态 </li>
<li>int pssProcState：pss进程状态 </li>
<li>ProcessState baseProcessTracker：进程状态监测器 </li>
<li>int adjSeq：计算adj的序列数 </li>
<li>int lruSeq：lru序列数 </li>
<li>IBinder forcingToForeground:强制将进程的状态设置为前台运行的IBinder，IBinder代表的是 组件的ID，这个是整个android系统唯一</li>
</ol>
<p><strong>第四类数据：和pss相关的数据</strong></p>
<ol>
<li>long initialIdlePss：初始化pss </li>
<li>long lastPss：上次pss </li>
<li>long lastSwapPss：上次SwapPss数据</li>
<li>long lastCachedPss：上次CachedPss数据 </li>
<li>long lastCachedSwapPss：上次CachedSwapPss数据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VSS- Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）</span><br><span class="line">RSS- Resident Set Size 实际使用物理内存（包含共享库占用的内存）</span><br><span class="line">PSS- Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存）</span><br><span class="line">USS- Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存）</span><br><span class="line">一般来说内存占用大小有如下规律：VSS &gt;&#x3D; RSS &gt;&#x3D; PSS &gt;&#x3D; USS</span><br></pre></td></tr></table></figure>

<p><strong>第五类数据：和时间相关的数据</strong></p>
<ol>
<li>long lastActivityTime：上次使用时间</li>
<li>long lastPssTime：上次计算pss的时间 </li>
<li>long nextPssTime：下次计算pss的时间 </li>
<li>long lastStateTime：上次设置进程状态的时间</li>
<li>long lastWakeTime：持有wakelock的时长</li>
<li>long lastCpuTime：上次计算占用cpu的时长 </li>
<li>long curCpuTime：当前最新占用cpu的时长 </li>
<li>long lastRequestedGc：上次发送gc命令给apk进程的时间 </li>
<li>long lastLowMemory：上次发送低内存消息给apk进程的时间 </li>
<li>long lastProviderTime：上次进程中ContentProvider被使用的时间 </li>
<li>long interactionEventTime：上次发送交互时间时间 </li>
<li>long fgInteractionTime：变成前台的时间</li>
</ol>
<p><strong>第六类数据：crash和anr相关的数据</strong></p>
<ol>
<li>IBinder.DeathRecipient deathRecipient：apk进程退出运行的话，会触发这个对象的 binderDied()方法，来回收系统资源 </li>
<li>boolean crashing：进程已经crash</li>
<li>Dialog crashDialog：crash对话框 </li>
<li>boolean forceCrashReport：强制crash对话框显示 </li>
<li>boolean notResponding：是否处于anr状态</li>
<li>Dialog anrDialog：anr显示对话框 </li>
<li>Runnable crashHandler：crash回调</li>
<li>ActivityManager.ProcessErrorStateInfo crashingReport:crash报告的进程状态</li>
<li>ActivityManager.ProcessErrorStateInfo notRespondingReport:anr报告的进程状态</li>
<li>String waitingToKill:后台进程被kill原因 </li>
<li>ComponentName errorReportReceiver:接收error信息的组件</li>
</ol>
<p><strong>第七类数据：和instrumentation相关的数据</strong></p>
<p>instrumentation 也可以说是apk的一个组件，如果提供的话，系统会默认使用 Instrumentation.java类，按照我们一般的理解，UI 线程控制activity的生命周期，是直接调用Activity 类的方法，实际是，UI线程调用的是instrumentation的方法，由它在调用Activity涉及生命周期的方法，所有如果我们覆写了instrumentation的这些方法，就可以了解所有的Activity的生命周期了。</p>
<ol>
<li>ComponentName instrumentationClass：AndroidManifest.xml中定义的instrumentation信 息 </li>
<li>ApplicationInfo instrumentationInfo：instrumentation应用信息 </li>
<li>String instrumentationProfileFile：instrumentation配置文件 </li>
<li>IInstrumentationWatcher instrumentationWatcher：instrumentation监测器 </li>
<li>IUiAutomationConnection instrumentationUiAutomationConnection：UiAutomation连接器</li>
<li>ComponentName instrumentationResultClass：返回结果组件</li>
</ol>
<p><strong>第八类数据：电源信息和调试信息</strong></p>
<ol>
<li>BatteryStatsImpl mBatteryStats:电量信息 </li>
<li>BatteryStatsImpl.Uid.Proc curProcBatteryStats：当前进程电量信息 </li>
<li>boolean debugging:处于调试中</li>
<li>boolean waitedForDebugger:等待调试 </li>
<li>Dialog waitDialog:等待对话框 </li>
<li>String adjType:adj类型（或者说标示） </li>
<li>int adjTypeCode:adj类型码（也是一种标示）</li>
<li>Object adjSource:改变adj的组件记录表 </li>
<li>int adjSourceProcState:影响adj的进程状态 </li>
<li>Object adjTarget：改变adj的组件 </li>
<li>String shortStringName：进程记录表的字符串显示 </li>
<li>String stringName：进程记录表的字符串显示</li>
</ol>
<p><strong>第九类数据：一堆boolean类型的值</strong></p>
<p><strong>进程声明周期相关的</strong></p>
<p>a.boolean starting:进程正在启动 </p>
<p>b.boolean removed:进程系统资源已经清理 </p>
<p>c.boolean killedByAm:进程被AMS主动kill掉 </p>
<p>d.boolean killed:进程被kill掉了 </p>
<p>e:boolean persistent:常驻内存进程</p>
<p><strong>组件状态影响进程行为的</strong></p>
<p>a.boolean empty:空进程，不含有任何组件的进程 </p>
<p>b.boolean cached:缓存进程 </p>
<p>c.boolean bad:60s内连续crash两次的进程被定义为bad进程 </p>
<p>d.boolean hasClientActivities:进程有Activity绑定其他Service </p>
<p>e.boolean hasStartedServices:进程中包含启动了的Service </p>
<p>f.boolean foregroundServices:进程中包含前台运行的Service </p>
<p>g.boolean foregroundActivities:进程中包含前台运行的Activity </p>
<p>h.boolean repForegroundActivities: </p>
<p>i.boolean systemNoUi:系统进程，没有显示UI </p>
<p>j.boolean hasShownUi:重进程启动开始，是否已经显示UI </p>
<p>k.boolean pendingUiClean: </p>
<p>l.boolean hasAboveClient:进程中有组件使用BIND_ABOVE_CLIENT标志绑定其他Service </p>
<p>m.boolean treatLikeActivity:进程中有组件使用BIND_TREAT_LIKE_ACTIVITY标志绑定其他 Service </p>
<p>n.boolean execServicesFg:前台执行Service </p>
<p>o.boolean setIsForeground:设置运行前台UI</p>
<p>还有一些其他的。</p>
<h5 id="ProcessRecord容器"><a href="#ProcessRecord容器" class="headerlink" title="ProcessRecord容器"></a>ProcessRecord容器</h5><p><strong>永久性容器</strong></p>
<ol>
<li>mProcessNames：根据进程名字检索进程记录表 </li>
<li>mPidsSelfLocked：根据进程pid检索进程记录表 </li>
<li>mLruProcesses：lru进程记录表容器，这个容器使用的是最近最少使用算法对进程记录表进行排 序，越是处于上层的越是最近使用的，对于系统来说就是最重要的，在内存吃紧回收进程时，越不 容易被回收，实现起来也很简单</li>
</ol>
<p><strong>临时性容器</strong></p>
<ol>
<li>mPersistentStartingProcesses：常驻内存进程启动时容器 </li>
<li>mProcessesOnHold：进程启动挂起容器 </li>
<li>mProcessesToGc：将要执行gc回收的进程容器 </li>
<li>mPendingPssProcesses：将要计算Pss数据的进程容器</li>
</ol>
<p>mRemovedProcesses：已经移除的进程</p>
<h5 id="内部四大组件记录表的容器"><a href="#内部四大组件记录表的容器" class="headerlink" title="内部四大组件记录表的容器"></a>内部四大组件记录表的容器</h5><p>组件运行才是进程存在的意义，由于android系统进程间的无缝结合，所以系统需要控制到组件级别， 所有的组件信息都需要映射到系统，</p>
<p>一个ActivityRecord记录对应一个Activity的信息</p>
<p>一个 ServiceRecord记录对应一个Service的信息</p>
<p>一个ConnectionRecord记录对应一个bind service的客户端信息</p>
<p>一个ReceiverList对应处理同一事件的一组广播</p>
<p>一个ContentProviderRecord记录对应一个 ContentProvider信息</p>
<p>一个ContentProviderConnection对应一个进程中的所有ContentProvider客户端</p>
<p><strong>activity记录</strong></p>
<p>  activities：ActivityRecord的容器，进程启动的所有的activity组件记录表</p>
<p><strong>service记录</strong></p>
<p>services：ServiceRecord的容器，进程启动的所有的service组件记录表</p>
<p>executingServices：正在运行（executing）的ServiceRecord是怎么定义的？首先需要明确的是 系统是怎么控制组件的？发送消息给apk进程，apk进程处理消息，上报消息完成，这被定义为一 个完整的执行过程，因此正在执行（executing）被定义为发送消息到上报完成这段时间</p>
<p>connections：ConnectionRecord容器，绑定service的客户端记录表</p>
<p><strong>广播接收器记录</strong></p>
<p>receivers：ReceiverList容器，广播接收器的记录表</p>
<p><strong>ContentProvider记录</strong></p>
<p>pubProviders：名字到ContentProviderRecord的映射容器，pub是publish（发布）的意思， ContentProvider需要安装然后把自己发布到系统（AMS）中后，才能使用，安装指的是apk进程 加载ContentProvider子类、初始化、创建数据库等过程，发布是将ContentProvider的binder客户端注册到AMS中</p>
<p>conProviders：ContentProviderConnection容器，使用ContentProvider的客户端记录表</p>
<h4 id="与Activity管理有关的数据结构"><a href="#与Activity管理有关的数据结构" class="headerlink" title="与Activity管理有关的数据结构"></a>与Activity管理有关的数据结构</h4><h5 id="ActivityRecord"><a href="#ActivityRecord" class="headerlink" title="ActivityRecord"></a><strong>ActivityRecord</strong></h5><p>ActivityRecord，源码中的注释介绍：An entry in the history stack, representing an activity. 翻译：历史栈中的一个条目，代表一个activity。</p>
<p>ActivityRecord中存在着大量的成员变量，包含了一个Activity的所有信息。 ActivityRecord中的成员变量task表示其所在的TaskRecord，由此ActivityRecord与 TaskRecord建立了联系。</p>
<h5 id="TaskRecord"><a href="#TaskRecord" class="headerlink" title="TaskRecord"></a><strong>TaskRecord</strong></h5><p>TaskRecord，内部维护一个ArrayList用来保存ActivityRecord，TaskRecord中的mStack表示其所在的ActivityStack。 startActivity()时也会创建一个TaskRecord</p>
<h5 id="ActivityStack"><a href="#ActivityStack" class="headerlink" title="ActivityStack"></a><strong>ActivityStack</strong></h5><p>ActivityStack,内部维护了一个ArrayList，用来管理TaskRecord，ActivityStack中还持有ActivityStackSupervisor对象，这个是用来管理ActivityStacks的。 ActivityStack是由ActivityStackSupervisor来创建的，实际ActivityStackSupervisor就是用来管理 ActivityStack的</p>
<h5 id="ActivityStackSupervisor"><a href="#ActivityStackSupervisor" class="headerlink" title="ActivityStackSupervisor"></a><strong>ActivityStackSupervisor</strong></h5><p>ActivityStackSupervisor内部有两个不同的ActivityStack对象：mHomeStack、mFocusedStack，用来管理不同的任务。 ActivityStackSupervisor内部包含了创建ActivityStack对象的方法。 AMS初始化时会创建一个ActivityStackSupervisor对象。</p>
<h4 id="Activity启动流程相关"><a href="#Activity启动流程相关" class="headerlink" title="Activity启动流程相关"></a>Activity启动流程相关</h4><p>整体流程</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB62d1c2c390d165de0619802e5cb17dca?method=download&shareKey=ec2c8cca3887831b1da957242a1488e2" alt=""></p>
<p>以Launcher打开应用为例，整体流程如下：</p>
<p>1、Launcher通过ActivityTaskManger向ATMS请求打开应用</p>
<p>2、ATMS内部判断进程是否存在，不存在通知Zygote fork一个新的进程</p>
<p>3、Zygote fork新的进程启动后，把ApplicationThread attach到AMS</p>
<p>4、AMS绑定后执行Activity的启动，ATMS执行启动流程，向APP发生启动事件</p>
<p>5、APP处理启动事件,执行Activity的生命周期。</p>
<p>打开应用，进程存在的情况下，Activity启动流程都是一样的，不同的是目标进程是否存在的情况下，下面先看下进程不存在的情况下，进程创建的流程，就是上面总体流程图中的2，3，4三步。</p>
<p><strong>AMS通知Zygote fork新进程的过程</strong></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBaa1c4fe17c224e325639f885fef52660?method=download&shareKey=e60495f3493124e547d4073e9bd30511" alt="img"></p>
<p><strong>Application进程启动后，attach过程</strong></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc82c8db12fd026588095950d7958cabc?method=download&shareKey=5951bef4ed57d94231108c59251e2a4e" alt=""></p>
<p>上面的两个时序图是Zygote fork新进程启动后，然后把app的IBinder绑定到了AMS的过程。ApplicationThread实现了IApplicationThread.Stub，是y一个Ibinder类，就是这个类在负责接收AMS的消息。</p>
<p>进程已经存在后面再梳理下Activity是如何启动的。大流程可以分为下面五步：</p>
<p>1、启动Activity端，准备启动参数阶段，Intent处理，前置条件判断</p>
<p>2、AMS端,处理ActivityStack阶段，产生ClientTransaction</p>
<p>3、跨进程传递生命周期触发器ClientTransaction阶段，传递给目标Activity端</p>
<p>4、目标Activity端生命周期触发器ClientTransaction触发执行阶段</p>
<p>5、启动Activity端的Activity stop阶段</p>
<p><strong>1、准备启动参数阶段</strong></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB1f25ca857b41066914721815deba3909?method=download&shareKey=399142ee47825577e78e20757ed74070" alt=""></p>
<p><strong>2、处理ActivityStack阶段</strong></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB52d9a565b86fd421dc0d62973d8f7638?method=download&shareKey=d09ce60f49af3f816b28316dd7baab9c" alt=""></p>
<p><strong>3、跨进程传递生命周期触发器</strong></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB05c68ed2c089fe91b6d1f1d4b40203d5?method=download&shareKey=8ac5d63585e331d8863a8d6723410194" alt=""></p>
<p><strong>4、ClientTransaction触发执行阶段</strong></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB062f6b846da88d8d20fcbb9dbc40c0ed?method=download&shareKey=6883431c750163c5741e584c9e0e0321" alt=""></p>
<p><strong>5、Activity stop阶段</strong></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBfb6b0c62016f88e889ed0cbf33fe1a26?method=download&shareKey=388d461e03c6ee69a1d4d71d6c8e2ece" alt=""></p>
<p>方法很多，具体细节可以按照上面的时序图结合代码去过一遍。</p>
<p>adb shell dumpsys activity activities | sed -En -e ‘/Stack #/p’ -e ‘/Running activities/,/Run #0/p’</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统源码</tag>
      </tags>
  </entry>
  <entry>
    <title>init进程及系统进程启动总结</title>
    <url>/2023/09/18/FW%20Init%E8%BF%9B%E7%A8%8B%E5%8F%8A%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="Android系统启动的大概流程"><a href="#Android系统启动的大概流程" class="headerlink" title="Android系统启动的大概流程"></a>Android系统启动的大概流程</h4><p><strong>第一步： 启动电源以及系统启动</strong> </p>
<p>当电源按下，引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序到RAM，然后执行 </p>
<p><strong>第二步：引导程序</strong> </p>
<p>引导程序是在Android操作系统开始运行前的一个小程序。引导程序是运行的第一个程序，因此它是针对特定的主板与芯片的。设备制造商要么使用很受欢迎的引导程序比如redboot、uboot、qi  bootloader或者开发自己的引导程序，它不是Android操作系统的一部分。引导程序是OEM厂商或者运营商加锁和限制的地方。 </p>
<p>引导程序分两个阶段执行。</p>
<p>第一个阶段，检测外部的RAM以及加载对第二阶段有用的程序； </p>
<p>第二阶段，引导程序设置网络、内存等等。这些对于运行内核是必要的，为了达到特殊的目标，引导程序可以根据配置参数或者输入数据设置内核。</p>
<p>Android引导程序可以在\bootable\bootloader\legacy\usbloader找到。传统的加载器包含两个文件， 需要在这里说明： </p>
<p>init.s初始化堆栈，清零BBS段，调用main.c的_main()函数； </p>
<p>main.c初始化硬件（闹钟、主板、键盘、控制台），创建linux标签 </p>
<p><strong>第三步：内核</strong> </p>
<p>Android内核与桌面linux内核启动的方式差不多。内核启动时，设置缓存、被保护存储器、计划列表， 加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init”文件，然后启动root进程或者系统的第 一个进程 </p>
<p><strong>第四步：init进程</strong></p>
<p> init进程是Linux系统中用户空间的第一个进程，进程号固定为1。Kernel启动后，在用户空间启动init进 程，并调用init中的main()方法执行init进程的职责。 </p>
<p><strong>第五步：启动系统服务，Lancher App</strong></p>
<h4 id="init进程分析"><a href="#init进程分析" class="headerlink" title="init进程分析"></a>init进程分析</h4><p>其中init进程是Android系统中及其重要的第一个进程，接下来看下init进程主要做了些什么 </p>
<ol>
<li>创建和挂载启动所需要的文件目录</li>
<li>初始化和启动属性服务 </li>
<li>解析init.rc配置文件并启动Zygote进程</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \system\core\init\init.cpp main()</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 1.C++中主函数有两个参数，第一个参数argc表示参数个数，第二个参数是参数列表，也就是具体的参数</span></span><br><span class="line"><span class="comment">  * 2.init的main函数有两个其它入口，一是参数中有ueventd，进入ueventd_main,二是参数中有watchdogd，进入watchdogd_main</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 1.strcmp是String的一个函数，比较字符串，相等返回0</span></span><br><span class="line"><span class="comment">  * 2.C++中0也可以表示false</span></span><br><span class="line"><span class="comment">  * 3.basename是C库中的一个函数，得到特定的路径中的最后一个'/'后面的内容，</span></span><br><span class="line"><span class="comment">  * 比如/sdcard/miui_recovery/backup，得到的结果是backup</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> 	<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">"ueventd"</span>)) &#123;<span class="comment">//当argv[0]的内容为ueventd时，strcmp的值为0,！strcmp为1</span></span><br><span class="line">  		<span class="comment">//1表示true，也就执行ueventd_main,ueventd主要是负责设备节点的创建、权限设定等一些列工作</span></span><br><span class="line">        <span class="keyword">return</span> ueventd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">"watchdogd"</span>)) &#123;<span class="comment">//watchdogd看门狗，用于系统出问题时重启系统</span></span><br><span class="line">        <span class="keyword">return</span> watchdogd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line">     ...</span><br><span class="line">     property_init();<span class="comment">//初始化属性系统，并从指定文件读取属性</span></span><br><span class="line">     LoadBootScripts(am, sm);<span class="comment">//解析xxx.rc   </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="init-rc解析"><a href="#init-rc解析" class="headerlink" title="init.rc解析"></a>init.rc解析</h4><p>init.rc是一个非常重要的配置文件，它是由Android初始化语言（Android Init Language）编写的脚 本，它主要包含五种类型语句：Action（Action中包含了一系列的Command）、Commands（init语言 中的命令）、Services（由init进程启动的服务）、Options（对服务进行配置的选项）和Import（引入 其他配置文件）。init.rc的配置代码如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># \system\core\rootdir\init.rc</span><br><span class="line"><span class="keyword">import</span> /system/etc/init/hw/init.$&#123;ro.zygote&#125;.rc</span><br><span class="line">on early-init &amp;&amp; property:ro.product.cpu.abilist32=*</span><br><span class="line">    exec_start boringssl_self_test32</span><br><span class="line">on init</span><br><span class="line">    start servicemanager</span><br><span class="line">    start hwservicemanager</span><br><span class="line">    </span><br><span class="line">on zygote-start &amp;&amp; property:ro.crypto.state=encrypted &amp;&amp; property:ro.crypto.type=file</span><br><span class="line">    wait_for_prop odsign.verification.done <span class="number">1</span></span><br><span class="line">    # A/B update verifier that marks a successful boot.</span><br><span class="line">    exec_start update_verifier_nonencrypted</span><br><span class="line">    start statsd</span><br><span class="line">    start netd</span><br><span class="line">    start zygote</span><br><span class="line">    start zygote_secondary</span><br><span class="line">    </span><br><span class="line">on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]* <span class="comment">//设置触发器</span></span><br><span class="line">     &lt;command&gt;</span><br><span class="line">     &lt;command&gt; <span class="comment">//动作触发之后要执行的命令</span></span><br><span class="line">    </span><br><span class="line">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]* <span class="comment">//&lt;service的名字&gt;&lt;执行程序路径&gt;&lt;传递参数&gt;</span></span><br><span class="line">     &lt;option&gt;  <span class="comment">//Options是Services的参数配置. 它们影响Service如何运行及运行时机</span></span><br><span class="line">     group &lt;groupname&gt; [ &lt;groupname&gt;\* ] </span><br><span class="line">    <span class="comment">//在启动Service前将group改为第一个groupname,第一个groupname是必须有的，默认值为root（或许默认值是无），第二个     		//groupname可以不设置，用于追加组（通过setgroups）</span></span><br><span class="line">     priority &lt;priority&gt; <span class="comment">//设置进程优先级. 在-20～19之间，默认值是0,通过setpriority实现</span></span><br><span class="line">     socket &lt;name&gt; &lt;type&gt; &lt;perm&gt; [ &lt;user&gt; [ &lt;group&gt; [ &lt;seclabel&gt; ] ] ]</span><br><span class="line">    <span class="comment">//创建一个unix域的socket,名字叫/dev/socket/name, 并将fd返回给Service. type 只能是"dgram", "stream" or 			//"seqpacket".</span></span><br><span class="line">       ...</span><br></pre></td></tr></table></figure>

<p><strong>Action</strong>  </p>
<p>Action： 通过触发器trigger，即以on开头的语句来决定执行相应的service的时机，具体有如下时机： </p>
<ul>
<li>on early-init; 在初始化早期阶段触发； </li>
<li>on init; 在初始化阶段触发； </li>
<li>on late-init; 在初始化晚期阶段触发； </li>
<li>on boot/charger： 当系统启动/充电时触发，还包含其他情况； </li>
<li>on property:=: 当属性值满足条件时触发</li>
</ul>
<p><strong>Service</strong>  </p>
<p>服务Service，以 service开头，由init进程启动，一般运行在init的一个子进程，所以启动service前需要判断对应的可执行文件是否存在。init生成的子进程，定义在rc文件，其中每一个service在启动时会通过 fork方式生成子进程。</p>
<p>例如： service servicemanager /system/bin/servicemanager代表的是服务名为 servicemanager，服务执行的路径为/system/bin/servicemanager。</p>
<p><strong>Command</strong>  </p>
<p> 常用的命令 </p>
<ul>
<li>class_start ： 启动属于同一个class的所有服务； </li>
<li>start ： 启动指定的服务，若已启动则跳过； </li>
<li>stop ： 停止正在运行的服务 </li>
<li>setprop  ：设置属性值 </li>
<li>mkdir ：创建指定目录 </li>
<li>symlink  ： 创建连接到的符号链接； </li>
<li>write  ： 向文件path中写入字符串；</li>
<li>exec： fork并执行，会阻塞init进程直到程序完毕； </li>
<li>exprot  ：设定环境变量； </li>
<li>loglevel ：设置log级别</li>
</ul>
<p><strong>Options</strong></p>
<p>Options是Service的可选项，与service配合使用</p>
<ul>
<li>disabled: 不随class自动启动，只有根据service名才启动； </li>
<li>oneshot: service退出后不再重启； </li>
<li>user/group： 设置执行服务的用户/用户组，默认都是root； </li>
<li>class：设置所属的类名，当所属类启动/退出时，服务也启动/停止，默认为default； </li>
<li>onrestart:当服务重启时执行相应命令； </li>
<li>socket: 创建名为/dev/socket/的socket </li>
<li>critical: 在规定时间内该service不断重启，则系统会重启并进入恢复模式 </li>
</ul>
<p>default: 意味着disabled=false，oneshot=false，critical=false。</p>
<h4 id="service解析流程"><a href="#service解析流程" class="headerlink" title="service解析流程"></a>service解析流程</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \system\core\init\init.cpp LoadBootScripts()</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadBootScripts</span><span class="params">(ActionManager&amp; action_manager, ServiceList&amp; </span></span></span><br><span class="line"><span class="function"><span class="params">service_list)</span> </span>&#123;</span><br><span class="line">    Parser parser = CreateParser(action_manager, service_list);<span class="comment">//创建解析器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bootscript = GetProperty(<span class="string">"ro.boot.init_rc"</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span> (bootscript.empty()) &#123;</span><br><span class="line">        parser.ParseConfig(<span class="string">"/init.rc"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">"/system/etc/init"</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">"/system/etc/init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">"/product/etc/init"</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">"/product/etc/init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">"/odm/etc/init"</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">"/odm/etc/init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">"/vendor/etc/init"</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">"/vendor/etc/init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parser.ParseConfig(bootscript);<span class="comment">//开始解析</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function">Parser <span class="title">CreateParser</span><span class="params">(ActionManager&amp; action_manager, ServiceList&amp; </span></span></span><br><span class="line"><span class="function"><span class="params">service_list)</span> </span>&#123;</span><br><span class="line">    Parser parser;</span><br><span class="line">    parser.AddSectionParser(<span class="string">"service"</span>, <span class="built_in">std</span>::make_unique&lt;ServiceParser&gt;</span><br><span class="line"> (&amp;service_list, subcontexts));<span class="comment">//service解析</span></span><br><span class="line">    parser.AddSectionParser(<span class="string">"on"</span>, <span class="built_in">std</span>::make_unique&lt;ActionParser&gt;</span><br><span class="line"> (&amp;action_manager, subcontexts));</span><br><span class="line">    parser.AddSectionParser(<span class="string">"import"</span>, <span class="built_in">std</span>::make_unique&lt;ImportParser&gt;</span><br><span class="line"> (&amp;parser));</span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">Parser.ParseConfig() -&gt; Parser::ParseData() -&gt; ServiceParser::ParseSection()...-&gt;ServiceList::AddService()</span><br></pre></td></tr></table></figure>

<p>解析完成后，接下来就是启动Service,以启动Zygote来分析</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> # \system\core\rootdir\init.rc</span><br><span class="line"> on nonencrypted</span><br><span class="line">    class_start main <span class="comment">//class_start是一个命令，通过do_class_start函数处理</span></span><br><span class="line">    class_start late_start</span><br><span class="line">     </span><br><span class="line"><span class="comment">// \system\core\init\builtins.cpp do_class_start()</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> Result&lt;Success&gt; <span class="title">do_class_start</span><span class="params">(<span class="keyword">const</span> BuiltinArguments&amp; args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Starting a class does not start services which are explicitly disabled.</span></span><br><span class="line">    <span class="comment">// They must  be started individually.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; service : ServiceList::GetInstance()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (service-&gt;classnames().count(args[<span class="number">1</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> result = service-&gt;StartIfNotDisabled(); !result) &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">"Could not start service '"</span> &lt;&lt; service-&gt;name()</span><br><span class="line">                           &lt;&lt; <span class="string">"' as part of class '"</span> &lt;&lt; args[<span class="number">1</span>] &lt;&lt; <span class="string">"': "</span> &lt;&lt; </span><br><span class="line">							result.error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Success();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// \system\core\init\service.cpp Service::StartIfNotDisabled() -&gt; Service::Start() </span></span><br><span class="line"><span class="function">Result&lt;Success&gt; <span class="title">Service::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//如果子进程没有启动，则调用fork函数创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (namespace_flags_) &#123;</span><br><span class="line">        pid = clone(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, namespace_flags_ | SIGCHLD, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">//当期代码逻辑在子进程中运行</span></span><br><span class="line">        umask(<span class="number">077</span>);</span><br><span class="line">      </span><br><span class="line">  		<span class="comment">//调用execv函数，启动sevice子进程</span></span><br><span class="line">        <span class="keyword">if</span> (!ExpandArgsAndExecv(args_)) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; <span class="string">"cannot execve('"</span> &lt;&lt; args_[<span class="number">0</span>] &lt;&lt; <span class="string">"')"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _exit(<span class="number">127</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Success()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Zygote"><a href="#Zygote" class="headerlink" title="Zygote"></a>Zygote</h4><p>主要用于孵化子进程。在Android系统中有以下两种程序：</p>
<ul>
<li>java应用程序，主要基于ART虚拟机，所有的应用程序apk都属于这类</li>
<li>native程序，也就是利用C或C++语 言开发的程序，如bootanimation。</li>
</ul>
<p>所有的Java应用程序进程及系统服务SystemServer进程都由Zygote 进程通过Linux的fork()函数孵化出来的，这也就是为什么把它称为Zygote的原因。</p>
<p>Zygote进程最初的名字不是“zygote”而是 “app_process”，这个名字是在Android.mk文件中定义的 </p>
<p>Zgyote是Android中的第一个art虚拟机，他通过socket的方式与其他进程进行通信。这里的“其他进程” 其实主要是系统进程——SystemServer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Zygote是一个C&#x2F;S模型，Zygote进程作为服务端，它主要负责创建Java虚拟机，加载系统资源，启 动SystemServer进程，以及在后续运行过程中启动普通的应用程序，其他进程作为客户端向它发 出“孵化”请求，而Zygote接收到这个请求后就“孵化”出一个新的进程。比如，当点击Launcher里的 应用程序图标去启动一个新的应用程序进程时，这个请求会到达框架层的核心服务 ActivityManagerService中，当AMS收到这个请求后，它通过调用Process类发出一个“孵化”子进 程的Socket请求，而Zygote监听到这个请求后就立刻fork一个新的进程出来。</span><br></pre></td></tr></table></figure>

<h4 id="Zygote触发过程"><a href="#Zygote触发过程" class="headerlink" title="Zygote触发过程"></a>Zygote触发过程</h4><p>1、init zygote</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#x2F;init.$&#123;ro.zygote&#125;.rc</span><br></pre></td></tr></table></figure>

<p>init.zygoteXX.rc  ${ro.zygote} 会被替换成 ro.zyogte 的属性值，这个是由不同的硬件厂商自己定制的， 有四个值， </p>
<ul>
<li>zygote32： zygote 进程对应的执行程序是 app_process (纯 32bit 模式) </li>
<li>zygote64： zygote 进程对应的执行程序是 app_process64 (纯 64bit 模式) </li>
<li>zygote32_64： 启动两个 zygote 进程 (名为 zygote 和 zygote_secondary)，对应的执行程序分别 是 app_process32 (主模式) </li>
<li>zygote64_32：  启动两个 zygote 进程 (名为 zygote 和 zygote_secondary)，对应的执行程序分别 是 app_process64 (主模式)、app_process32</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//\system\core\rootdir\init.zygote64.rc</span></span><br><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">main</span></span></span><br><span class="line"><span class="class">    <span class="title">priority</span> -20</span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">root</span></span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">root</span> <span class="title">readproc</span> <span class="title">reserved_disk</span></span></span><br><span class="line"><span class="class">    <span class="title">socket</span> <span class="title">zygote</span> <span class="title">stream</span> 660 <span class="title">root</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">socket</span> <span class="title">usap_pool_primary</span> <span class="title">stream</span> 660 <span class="title">root</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">exec_background</span> - <span class="title">system</span> <span class="title">system</span> -- /<span class="title">system</span>/<span class="title">bin</span>/<span class="title">vdc</span> <span class="title">volume</span> <span class="title">abort_fuse</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">write</span> /<span class="title">sys</span>/<span class="title">power</span>/<span class="title">state</span> <span class="title">on</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">audioserver</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">cameraserver</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">media</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">media</span>.<span class="title">tuner</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">netd</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">wificond</span></span></span><br><span class="line"><span class="class">    <span class="title">task_profiles</span> <span class="title">ProcessCapacityHigh</span></span></span><br><span class="line"><span class="class">    <span class="title">critical</span> <span class="title">window</span>=$&#123;</span>zygote.critical_window.minute:-off&#125; target=zygote-fatal</span><br></pre></td></tr></table></figure>

<p>2、start zygote 位置：system\core\rootdir\init.rc </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;encrypted &amp;&amp; property:ro.crypto.type&#x3D;file</span><br><span class="line">    # A&#x2F;B update verifier that marks a successful boot.</span><br><span class="line">    exec_start update_verifier_nonencrypted</span><br><span class="line">    start netd</span><br><span class="line">    start zygote</span><br><span class="line">    start zygote_secondary</span><br><span class="line"></span><br><span class="line">on late-init</span><br><span class="line">    trigger early-fs</span><br><span class="line">	...</span><br><span class="line">    # Now we can start zygote for devices with file based encryption</span><br><span class="line">    trigger zygote-start</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \system\core\init\init.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SecondStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Don't mount filesystems or start core system services in charger mode.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bootmode = GetProperty(<span class="string">"ro.bootmode"</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span> (bootmode == <span class="string">"charger"</span>) &#123;</span><br><span class="line">        am.QueueEventTrigger(<span class="string">"charger"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        am.QueueEventTrigger(<span class="string">"late-init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、app_processXX 位置\frameworks\base\cmds\app_process\</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app_process_src_files :&#x3D; \</span><br><span class="line">   app_main.cpp \</span><br><span class="line">LOCAL_SRC_FILES:&#x3D; $(app_process_src_files)</span><br><span class="line">...</span><br><span class="line">LOCAL_MODULE:&#x3D; app_process</span><br><span class="line">LOCAL_MULTILIB :&#x3D; both</span><br><span class="line">LOCAL_MODULE_STEM_32 :&#x3D; app_process32</span><br><span class="line">LOCAL_MODULE_STEM_64 :&#x3D; app_process64</span><br></pre></td></tr></table></figure>

<h4 id="Zygote启动过程"><a href="#Zygote启动过程" class="headerlink" title="Zygote启动过程"></a>Zygote启动过程</h4><p>位置\frameworks\base\cmds\app_process\app_main.cpp</p>
<p> 在app_main.cpp的main函数中，主要做的事情就是参数解析. 这个函数有两种启动模式：</p>
<ol>
<li>一种是zygote模式，也就是初始化zygote进程，传递的参数有–start-system-server –socket name=zygote，前者表示启动SystemServer，后者指定socket的名称 </li>
<li>一种是application模式，也就是启动普通应用程序，传递的参数有class名字以及class带的参数 两者最终都是调用AppRuntime对象的start函数，加载ZygoteInit或RuntimeInit两个Java类，并将之前整理的参数传入进去</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line"> A[&quot;app_main.main()&quot;] </span><br><span class="line"> --&gt; B[&quot;AndroidRuntime.start()&quot;] --&gt; C[&quot;AndroidRuntime startVm() startReg()&quot;] --&gt; E[&quot;ZygoteInit.main()&quot;]</span><br><span class="line"> --&gt; F[&quot;registerZygoteSocket()&quot;] --&gt; G[&quot;preload()&quot;]--&gt; H[&quot;startSystemServer()&quot;] --&gt; I[&quot;runSelectLoop()&quot;]</span><br></pre></td></tr></table></figure>

<p>app_process</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \frameworks\base\cmds\app_process\app_main.cpp main()</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--zygote"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"> zygote = <span class="literal">true</span>;</span><br><span class="line"> niceName = ZYGOTE_NICE_NAME;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--start-system-server"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"> startSystemServer = <span class="literal">true</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--application"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">           application = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// L349       </span></span><br><span class="line"> <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">       <span class="comment">//这些Java的应用都是通过 AppRuntime.start（className)开始的</span></span><br><span class="line">       <span class="comment">//其实AppRuntime是AndroidRuntime的子类，它主要实现了几个回调函数，而start()方法是实现在AndroidRuntime这个方法类里</span></span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>, args, zygote);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>app_process 里面定义了三种应用程序类型： </p>
<ol>
<li>Zygote:  com.android.internal.os.ZygoteInit </li>
<li>System Server, 不单独启动，而是由Zygote启动 </li>
<li>其他指定类名的Java 程序</li>
</ol>
<h4 id="什么是Runtime"><a href="#什么是Runtime" class="headerlink" title="什么是Runtime"></a>什么是Runtime</h4><p>Runtime 是支撑程序运行的基础库，它是与语言绑定在一起的。比如：</p>
<p>C Runtime：就是C standard lib, 也就是常说的libc。</p>
<p>Java Runtime: 包括Java 的支撑类库 （.jar). </p>
<p>AndroidRuntime:  为Android应用运行所需的运行时环境。这个环境包括以下内容：</p>
<ol>
<li>Dalvik/ART VM: Android的Java VM, 解释运行Dex格式Java程序。每个进程运行一个虚拟机。 </li>
<li>Android的Java 类库, 开源的Java API 实现，如 java.lang,  java.util, java.net. 但去除了AWT, Swing 等部件。</li>
<li>JNI: C和Java互调的接口。</li>
<li>Libc: Android也有很多C代码，自然少不了libc，注意的是，Android的libc叫 bionic C</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \frameworks\base\core\jni\androidRuntime.cpp start()</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; </span></span></span><br><span class="line"><span class="function"><span class="params">options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="comment">//JNI_CreateJavaVM </span></span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    onVmCreated(env);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Register android functions</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"> <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p> Java虚拟机的启动大致做了以下一些事情：</p>
<ol>
<li><p>从property读取一系列启动参数。 </p>
</li>
<li><p>创建和初始化结构体全局对象（每个进程）gDVM，及对应与JavaVM和JNIEnv的内部结构体  JavaVMExt, JNIEnvExt. </p>
</li>
<li><p>初始化java虚拟机，并创建虚拟机线程 </p>
</li>
<li><p>注册系统的JNI，Java程序通过这些JNI接口来访问底层的资源。 （”javacore”, “nativehelper”)  </p>
</li>
<li><p>为Zygote的启动做最后的准备，包括设置SID/UID, 以及mount 文件系统</p>
</li>
<li><p>返回JavaVM 给Native代码，这样它就可以向上访问Java的接口</p>
</li>
</ol>
<p>除了系统的JNI接口（”javacore”, “nativehelper”), android framework 还有大量的Native实现， Android将所有这些接口一次性的通过start_reg()来完成</p>
<h4 id="ZygotInit"><a href="#ZygotInit" class="headerlink" title="ZygotInit"></a>ZygotInit</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \frameworks\base\core\java\com\android\internal\os\ZygotInit.java main()</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">        ZygoteServer zygoteServer = <span class="keyword">new</span> ZygoteServer(); <span class="comment">//新建Zygote服务器端</span></span><br><span class="line">      ...</span><br><span class="line">        <span class="keyword">final</span> Runnable caller;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">            String socketName = <span class="string">"zygote"</span>;Dalvik VM进程系统</span><br><span class="line">            String abiList = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> enableLazyPreload = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">                <span class="comment">//app_main.cpp中传的start-system-server参数，在这里用到</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"start-system-server"</span>.equals(argv[i])) &#123;</span><br><span class="line">                    startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"--enable-lazy-preload"</span>.equals(argv[i])) &#123;</span><br><span class="line">                    enableLazyPreload = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                    abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                    socketName = argv[i].substring(SOCKET_NAME_ARG.length())</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unknown command line argument: "</span> + argv[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            zygoteServer.registerServerSocketFromEnv(socketName);<span class="comment">//注册Socket</span></span><br><span class="line">            <span class="comment">// In some configurations, we avoid preloading resources and classes eagerly.</span></span><br><span class="line">            <span class="comment">// In such cases, we will preload things prior to our first fork.</span></span><br><span class="line">             <span class="comment">// 在有些情况下我们需要在第一个fork之前进行预加载资源</span></span><br><span class="line">            <span class="keyword">if</span> (!enableLazyPreload) &#123;</span><br><span class="line">                preload(bootTimingsTraceLog);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Zygote.resetNicePriority();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Do an initial gc to clean up after startup</span></span><br><span class="line">            bootTimingsTraceLog.traceBegin(<span class="string">"PostZygoteInitGC"</span>);</span><br><span class="line">            <span class="comment">//主动进行一次资源GC 。gc()必须在fork之前完成（接下来的StartSystemServer就会有fork操作），</span></span><br><span class="line">            <span class="comment">//这样将来被复制出来的子进程才能有尽可能少的垃圾内存</span></span><br><span class="line">            gcAndFinalize();</span><br><span class="line">            Zygote.nativeSecurityInit();</span><br><span class="line">            <span class="comment">// Zygote process unmounts root storage spaces.</span></span><br><span class="line">            Zygote.nativeUnmountStorageOnInit();</span><br><span class="line">            ZygoteHooks.stopZygoteNoThreadCreation();</span><br><span class="line">            <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">                Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">                <span class="comment">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span></span><br><span class="line">                <span class="comment">// child (system_server) process.</span></span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Log.i(TAG, <span class="string">"Accepting command socket connections"</span>)      </span><br><span class="line">            <span class="comment">// The select loop returns early in the child process after a fork and</span></span><br><span class="line">            <span class="comment">// loops forever in the zygote.</span></span><br><span class="line">            caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"System zygote died with exception"</span>, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We're in the child process and have exited the select loop. Proceed to execute the command.</span></span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            caller.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>preload() 的作用就是提前将需要的资源加载到VM中，比如class、resource等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \frameworks\base\core\java\com\android\internal\os\ZygotInit.java preload()</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preload</span><span class="params">(TimingsTraceLog bootTimingsTraceLog)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"begin preload"</span>);</span><br><span class="line">        <span class="comment">//加载指定的类到内存并且初始化，使用的Class.forName(class, true, null);方式</span></span><br><span class="line">        preloadClasses();</span><br><span class="line">        bootTimingsTraceLog.traceEnd(); <span class="comment">// PreloadClasses</span></span><br><span class="line">        bootTimingsTraceLog.traceBegin(<span class="string">"PreloadResources"</span>);</span><br><span class="line">        <span class="comment">//加载Android通用的资源，比如drawable、color...</span></span><br><span class="line">        preloadResources();</span><br><span class="line">        bootTimingsTraceLog.traceEnd(); <span class="comment">// PreloadResources</span></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, <span class="string">"PreloadAppProcessHALs"</span>);</span><br><span class="line">        nativePreloadAppProcessHALs();</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, <span class="string">"PreloadOpenGL"</span>);</span><br><span class="line">        <span class="comment">//加载OpenGL...</span></span><br><span class="line">        preloadOpenGL();</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);</span><br><span class="line">        <span class="comment">//加载共用的Library</span></span><br><span class="line">        preloadSharedLibraries();</span><br><span class="line">        <span class="comment">//加载Text资源，字体等</span></span><br><span class="line">        preloadTextResources();</span><br><span class="line">        <span class="comment">// Ask the WebViewFactory to do any initialization that must run in the zygote process,</span></span><br><span class="line">        <span class="comment">// for memory sharing purposes.</span></span><br><span class="line">        <span class="comment">// 为了内存共享，WebViewFactory进行任何初始化都要在Zygote进程中</span></span><br><span class="line">        WebViewFactory.prepareWebViewInZygote();</span><br><span class="line">        endIcuCachePinning();</span><br><span class="line">        warmUpJcaProviders();</span><br><span class="line">        Log.d(TAG, <span class="string">"end preload"</span>);</span><br><span class="line">        sPreloadComplete = <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>preloadClassess 将framework.jar里的preloaded-classes 定义的所有class load到内存里， preloaded-classes 编译Android后可以在framework/base下找到。</p>
<p>preloadResources 将系统的 Resource(不是在用户apk里定义的resource）load到内存。资源preload到Zygoted的进程地址空间， 所有fork的子进程将共享这份空间而无需重新load, 这大大减少了应用程序的启动时间，但反过来增加了 系统的启动时间。通过对preload 类和资源数目进行调整可以加快系统启动。Preload也是Android启动 最耗时的部分之一。</p>
<p>ZygoteInit.forkSystemServer() 方法fork 出一个新的进程，这个进程就是SystemServer进程。fork出来 的子进程在handleSystemServerProcess 里开始初始化工作，主要工作分为： </p>
<ol>
<li>prepareSystemServerProfile（）方法中将SYSTEMSERVERCLASSPATH中的AppInfo加载到VM 中。 </li>
<li>判断fork args中是否有invokWith参数，如果有则进行WrapperInit.execApplication，如果没有则调用调用ZygoteInit.zygoteInit</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> \frameworks\base\core\java\com\android\internal\os\ZygotInit.java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, <span class="keyword">long</span>[] disabledCompatChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">            String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ZygoteInit"</span>);</span><br><span class="line">        RuntimeInit.redirectLogStreams();</span><br><span class="line">        RuntimeInit.commonInit();</span><br><span class="line">        ZygoteInit.nativeZygoteInit();</span><br><span class="line">        <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv,</span><br><span class="line">                classLoader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \frameworks\base\core\java\com\android\internal\os\RuntimeInit.java applicationInit()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv,ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Remaining arguments are passed to the start class's static main</span></span><br><span class="line">        <span class="comment">//findStaticMain来运行args的startClass的main方法</span></span><br><span class="line">        <span class="keyword">return</span> findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">findStaticMain</span><span class="params">(String className, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">            ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; cl;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Missing class when invoking static main "</span> + className,</span><br><span class="line">                    ex);</span><br><span class="line">        &#125;</span><br><span class="line">        Method m;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[]<span class="class">.<span class="keyword">class</span> &#125;)</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Missing static main on "</span> + className, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Problem getting static main on "</span> + className, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodAndArgsCaller(m, argv);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接着在MethodAndArgsCaller的run方法中执行SystemServer的main方法。</p>
<h4 id="System-Server-启动流程"><a href="#System-Server-启动流程" class="headerlink" title="System Server 启动流程"></a>System Server 启动流程</h4><p>System Server是Zygote fork 的第一个Java 进程， 这个进程非常重要，因为他们有很多的系统线程， 提供所有核心的系统服务。还有很多“Binder-x”的线程，它们是各个Service为了响应应用程序远程调用请求而创建的。除此之外，还有很多内部的线程，比如 ”UI thread”, “InputReader”, “InputDispatch” 等等，现在只关心System Server是如何创建起来的。 SystemServer的main() 函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  SystemServer run方法的初始化流程:</p>
<ul>
<li>初始化必要的SystemServer环境参数，比如系统时间、默认时区、语言、load一些Library等等，</li>
<li>初始化Looper，我们在主线程中使用到的looper就是在SystemServer中进行初始化的 </li>
<li>初始化Context，只有初始化一个Context才能进行启动Service等操作</li>
<li>初始化SystemServiceManager,用来管理启动service，SystemServiceManager中封装了启动Service的 startService方法启动系统必要的Service，启动service的流程</li>
</ul>
<p><strong>初始化Context</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createSystemContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     ActivityThread activityThread = ActivityThread.systemMain();</span><br><span class="line">     mSystemContext = activityThread.getSystemContext();</span><br><span class="line">     mSystemContext.setTheme(DEFAULT_SYSTEM_THEME);</span><br><span class="line">     <span class="keyword">final</span> Context systemUiContext = activityThread.getSystemUiContext();</span><br><span class="line">     systemUiContext.setTheme(DEFAULT_SYSTEM_THEME);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//ActivityThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ContextImpl <span class="title">getSystemContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (mSystemContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">          mSystemContext = ContextImpl.createSystemContext(<span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> mSystemContext;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>初始化SystemServiceManager</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SystemServer Start services.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    traceBeginAndSlog(<span class="string">"StartServices"</span>);</span><br><span class="line">    startBootstrapServices();</span><br><span class="line">    startCoreServices();</span><br><span class="line">    startOtherServices();</span><br><span class="line">    SystemServerInitThreadPool.shutdown();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    traceEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>启动BootstrapServices,就是系统必须需要的服务，这些服务直接耦合性很高，所以干脆就放在一个方 法里面一起启动，比如PowerManagerService、RecoverySystemService、DisplayManagerService、 ActivityManagerService等</li>
<li>启动以基本的核心Service，比如BatteryService、 UsageStatsService、WebViewUpdateService等</li>
<li>启动其它需要用到的Service，比如 NetworkScoreService、AlarmManagerService等</li>
</ul>
<p>最后Zygote会监控System  Server是否挂掉了，如果挂掉会将其回收，然后将自己杀掉，重新开始，这段实现在代码 ：dalvik/vm/native/dalvik_system_zygote.cpp   Dalvik_dalvik_system_Zygote_forkSystemServer中。</p>
<h4 id="Zygote和SystemServer-总结"><a href="#Zygote和SystemServer-总结" class="headerlink" title="Zygote和SystemServer 总结"></a>Zygote和SystemServer 总结</h4><ol>
<li>init 根据init.rc 运行 app_process, 并携带‘–zygote’ 和 ’–startSystemServer’ 参数。 </li>
<li>AndroidRuntime.cpp::start() 里将启动JavaVM，并且注册所有framework相关的系统JNI接口。 </li>
<li>第一次进入Java世界，运行ZygoteInit.java::main() 函数初始化Zygote. Zygote 并创建Socket的 server 端。 </li>
<li>然后fork一个新的进程并在新进程里初始化SystemServer. Fork之前，Zygote是preload常用的 Java类库，以及系统的resources，同时GC（）清理内存空间，为子进程省去重复的工作。</li>
<li>SystemServer 里将所有的系统Service初始化，包括ActivityManager 和 WindowManager, 他们 是应用程序运行起来的前提。</li>
<li>于此同时，Zygote监听服务端Socket，等待新的应用启动请求。</li>
<li>ActivityManager ready 之后寻找系统的“Startup” Application, 将请求发给Zygote。</li>
<li>Zygote收到请求后，fork出一个新的进程。</li>
<li>Zygote监听并处理SystemServer 的 SIGCHID 信号，一旦System Server崩溃，立即将自己杀死。 init会重启Zygote。</li>
</ol>
<h4 id="什么情况下Zygote进程会重启呢？"><a href="#什么情况下Zygote进程会重启呢？" class="headerlink" title="什么情况下Zygote进程会重启呢？"></a>什么情况下Zygote进程会重启呢？</h4><ul>
<li>servicemanager进程被杀;  </li>
<li>(onresart)surfaceflinger进程被杀; </li>
<li>(onresart)Zygote进程自己被杀;</li>
<li>(oneshot=false)system_server进程被杀; (waitpid）</li>
</ul>
<h4 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h4><p>使用 f ork() 函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空间：包括进程上下文（进程执行活动全过程的静态描述）、进程堆栈、打开的文件描述符、信号控 制设定、进程优先级、进程组号等。子进程所独有的只有它的进程号，计时器等（只有小量信 息）。因此，使用  fork() 函数的代价是很大的。</p>
<p><strong>子进程与父进程的区别</strong>  </p>
<ol>
<li>除了文件锁以外,其他的锁都会被继承</li>
<li>各自的进程ID和父进程ID不同</li>
<li>子进程的未决告警被清除；</li>
<li>子进程的未决信号集设置为空集。</li>
</ol>
<p><strong>写时拷贝 (copy- on-write)</strong></p>
<p>Linux 的  fork() 使用是通过写时拷贝 (copy- on-write) 实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</p>
<p><strong>孤儿进程、僵尸进程</strong>  </p>
<p>fork系统调用之后，父子进程将交替执行，执行顺序不定。如果父进程先退出，子进程还没退出那么子进程的父进程将变为init进程（托孤给了init进程）。（注：任何一个进程都必须有父进程）如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵进程（僵尸进程：只保留一些退出信息供父进程查询）。</p>
<p><strong>多线程进程的Fork调用</strong></p>
<p>在 POSIX 标准中，fork 的行为是这样的：复制整个用户空间的数据（通常使用 copy-on-write 的策略， 所以可以实现的速度很快）以及所有系统对象，然后仅复制当前线程到子进程。这里：所有父进程中别的线程，到了子进程中都是突然蒸发掉的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设这么一个环境，在 fork 之前，有一个子线程 lock 了某个锁，获得了对锁的所有权。fork 以后，在子进程中，所有的额外线程都人间蒸发了。而锁却被正常复制了，在子进程看来，这个锁没有主人，所以没有任何人可以对它解锁。当子进程想lock这个锁时，不再有任何手段可以解开了。程序发生死锁。</span><br></pre></td></tr></table></figure>

<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p>Q：你了解 Android 系统启动流程吗？</p>
<p>A：当按电源键触发开机，首先会从 ROM 中预定义的地方加载引导程序 BootLoader 到 RAM 中，并执 行 BootLoader 程序启动 Linux Kernel，然后启动用户级别的第一个进程：init 进程。init 进程会解析  init.rc 脚本做一些初始化工作，包括挂载文件系统、创建工作目录以及启动系统服务进程等，其中系统服务进程包括 Zygote、service manager、media 等。在 Zygote 中会进一步去启动 system_server 进 程，然后在 system_server 进程中会启动 AMS、WMS、PMS 等服务，等这些服务启动之后，AMS 中就 会打开 Launcher 应用的 home Activity，最终就看到了手机的 “桌面”。 </p>
<p>Q：system_server为什么要在 Zygote 中启动，而不是由 init 直接启动呢？</p>
<p> A：Zygote作为一个孵化器，可以提前加载一些资源，这样fork() 时基于 Copy-On-Write 机制创建的其他进程就能直接使用这些资源，而不用重新加载。比如 system_server 就可以直接使用 Zygote 中的 JNI  函数、共享库、常用的类、以及主题资源。 </p>
<p>Q：为什么要专门使用 Zygote 进程去孵化应用进程，而不是让system_server去孵化呢？</p>
<p>A：首先 system_server相比 Zygote 多运行了 AMS、WMS 等服务，这些对一个应用程序来说是不需要的。另外进程的 fork() 对多线程不友好，仅会将发起调用的线程拷贝到子进程，这可能会导致死锁，而 system_server 中肯定是有很多线程的。 </p>
<p>Q：能说说具体是怎么导致死锁的吗？</p>
<p>A：在 POSIX 标准中，fork 的行为是这样的：复制整个用户空间的数据（通常使用 copy-on-write 的策略， 所以可以实现的速度很快）以及所有系统对象，然后仅复制当前线程到子进程。这里：所有父进程中别 的线程，到了子进程中都是突然蒸发掉的 对于锁来说，从 OS 看，每个锁有一个所有者，即最后一次lock它的线程。假设这么一个环境，在fork之前，有一个子线程lock了某个锁，获得了对锁的所有权。fork 以后，在子进程中，所有的额外线程都 人间蒸发了。而锁却被正常复制了，在子进程看来，这个锁没有主人，所以没有任何人可以对它解锁。当子进程想 lock 这个锁时，不再有任何手段可以解开了。程序发生死锁 </p>
<p>Q：Zygote为什么不采用 Binder 机制进行 IPC 通信？ </p>
<p>A：Binder 机制中存在 Binder 线程池，是多线程的，如果 Zygote 采用 Binder 的话就存在上面说的fork() 与 多线程的问题了。其实严格来说，Binder机制不一定要多线程，所谓的 Binder 线程只不过是在循环读取 Binder 驱动的消息而已，只注册一个 Binder 线程也是可以工作的，比如 service manager就是这样的。实际上 Zygote 尽管没有采取 Binder 机制，它也不是单线程的，但它在 fork() 前主动停止 了其他线程，fork() 后重新启动了。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Binder总结</title>
    <url>/2023/09/17/FW%20Binder%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于 Linux的动态内核可加载模块（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译， 但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。</p>
<p> 在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 Binder驱 动（Binder Dirver）。</p>
<p> 那么在 Android 系统中用户进程之间是如何通过这个内核模块（Binder 驱动）来实现通信的呢？难道是和前面说的 传统 IPC 机制一样，先将数据从发送方进程拷贝到内核缓存区，然后再将数据从内核缓存区拷贝到接收方进程，通过 两次拷贝来实现吗？显然不是。</p>
<p> 这就涉及到Linux 下的另一个概念：<strong>内存映射</strong>。 </p>
<p>Binder IPC 机制中涉及到的内存映射通过 <strong>mmap()</strong> 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。</p>
<p>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</p>
<p> <strong>Binder IPC 正是基于内存映射（mmap）来实现的，但是 mmap() 通常是用在有物理介质的文件系统上的。</strong> </p>
<p>比如进程中的用户区域是不能直接和物理设备打交道的，如果想要把磁盘上的数据读取到进程的用户区域，需要两次 拷贝（磁盘–&gt;内核空间–&gt;用户空间）；通常在这种场景下 mmap() 就能发挥作用，通过在物理介质和用户空间之间 建立映射，减少数据的拷贝次数，用内存读写取代I/O读写，提高文件读取效率。 </p>
<p>而 Binder 并不存在物理介质，因此 Binder 驱动使用 mmap() 并不是为了在物理介质和用户空间之间建立映射，而是在内核空间创建数据接收的缓存空间。</p>
<p> 一次完整的 Binder IPC 通信过程通常是这样：</p>
<ol>
<li>首先 Binder 驱动在内核空间创建一个数据接收缓存区</li>
<li>接着在内核空间开辟一块内核缓存区，建立内核缓存区和内核中数据接收缓存区之间的映射关系，以及内核中数据接收缓存区和接收进程用户空间地址的映射关系；发送方进程通过系统调用 </li>
<li>copyfromuser() 将数据 copy 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB05a2be2615b8aafb64509e6b80d27c9c?method=download&shareKey=ae7691508872565960006bd052486f4f" alt=""></p>
<p><strong>性能</strong><br>首先说说性能上的优势。Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。<br><strong>稳定性</strong><br>再说说稳定性，Binder 基于 C/S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。<br><strong>安全性</strong> </p>
<p>另一方面就是安全性。Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于Android 平台而言极其重要。作为用户当然不希望我们下载的 APP 偷偷读取我的通信录，上传我的隐私数据，后台偷跑流量、消耗手机电量。传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。首先传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。<br>基于上述原因，Android 需要建立一套新的 IPC 机制来满足系统对稳定性、传输性能和安全性方面的要求，这就是Binder。</p>
<h4 id="Binder何时初始化"><a href="#Binder何时初始化" class="headerlink" title="Binder何时初始化"></a>Binder何时初始化</h4><p>Binder初始化一般是指binder驱动的初始化，在使用binder的过程中，从来没有执行过new Binder的方式来实现Binder初始化，原因很简单：binder初始化有它自身独立的特点。</p>
<p>每一个应用进程启动的时候，都是通过zygote fork产生的，所以，当fork产生进程后app进程的代码就开始执行，开始运行的地方如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, </span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">long</span>[] disabledCompatChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">		RuntimeInit.redirectLogStreams();</span><br><span class="line">        RuntimeInit.commonInit();<span class="comment">//初始化运行环境 </span></span><br><span class="line">        ZygoteInit.nativeZygoteInit();<span class="comment">//启动Binder ，方法在 androidRuntime.cpp中注册</span></span><br><span class="line">        <span class="comment">// 通过反射创建程序入口函数的 Method 对象，并返回 Runnable 对象</span></span><br><span class="line">        <span class="comment">//ActivityThread.main();</span></span><br><span class="line">        <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv,</span><br><span class="line">                classLoader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，会执行ZygoteInit.nativeZygoteInit()函数，而nativeZygoteInit函数执行appRuntime的onZygoteInit<br>代码，也就是App_main.cpp中的 onZygoteInit()函数，函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onZygoteInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">    proc-&gt;startThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ProcessState的self函数里面就会初始化ProcessState（），而这个初始化的一个非常重要的动作就是启动binder驱动和并构建binder的Map映射。具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ProcessState::ProcessState(<span class="keyword">const</span> <span class="keyword">char</span> *driver)</span><br><span class="line">    : mDriverName(String8(driver))</span><br><span class="line">    , mDriverFD(open_driver(driver)) <span class="comment">//打开binder的虚拟驱动</span></span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(<span class="number">0</span>)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , mStarvationStartTimeMs(<span class="number">0</span>)</span><br><span class="line">    , mBinderContextCheckFunc(<span class="literal">nullptr</span>)</span><br><span class="line">    , mBinderContextUserData(<span class="literal">nullptr</span>)</span><br><span class="line">    , mThreadPoolStarted(<span class="literal">false</span>)</span><br><span class="line">    , mThreadPoolSeq(<span class="number">1</span>)</span><br><span class="line">    , mCallRestriction(CallRestriction::NONE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//调用mmap接口向Binder驱动中申请内核空间的内存</span></span><br><span class="line">        <span class="comment">// mmap the binder, providing a chunk of virtual address space to receive  transactions.</span></span><br><span class="line">        mVMStart = mmap(<span class="literal">nullptr</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE,mDriverFD, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mVMStart == MAP_FAILED) &#123;</span><br><span class="line">            <span class="built_in">close</span>(mDriverFD);</span><br><span class="line">            mDriverFD = <span class="number">-1</span>;</span><br><span class="line">            mDriverName.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，总的来说，Binder的初始化是在进程已创建就完成了。创建进程后会第一时间为这个进程打开一个binder驱动，并调用mmap接口向Binder驱动中申请内核空间的内存。</p>
<h4 id="Binder通信的流程"><a href="#Binder通信的流程" class="headerlink" title="Binder通信的流程"></a>Binder通信的流程</h4><ol>
<li><p>首先，一个进程使用 BINDERSETCONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager，Binder的引用在所有Client中都固定为0；</p>
</li>
<li><p>Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。</p>
</li>
<li><p>Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用。</p>
</li>
<li><p>通过这个Binder实体引用，Client实现和 Server 进程的通信。</p>
</li>
</ol>
<h4 id="aidl通信的基本步骤"><a href="#aidl通信的基本步骤" class="headerlink" title="aidl通信的基本步骤"></a>aidl通信的基本步骤</h4><ol>
<li><p>Client通过ServiceConnection获取到Server的Binder，并且封装成一个Proxy。 </p>
</li>
<li><p>通过Proxy来同步调用IPC方法（xxxFunction），同时通过Parcel将参数传给Binder，最终触发Binder的 transact方法。</p>
</li>
<li><p>Binder的transact方法最终会触发到Server上Stub的onTransact方法。 </p>
</li>
<li><p>Server上Stub的onTransact方法中，会先从Parcel中解析中参数，然后将参数带入真正的方法中执行，然后将 结果写入Parcel后传回。 </p>
</li>
<li><p>请注意：Client的Ipc方法中，执行Binder的transact时，是阻塞等待的，一直到Server逻辑执行结束后才会继 续执行。当然，如果IPC方法是oneWay的方式，那么就是非阻塞的等待。 </p>
</li>
<li><p>当Server返回结果后，Client从Parcel中取出返回值，于是实现了一次IPC调用。</p>
<h4 id="bindService的全流程"><a href="#bindService的全流程" class="headerlink" title="bindService的全流程"></a>bindService的全流程</h4><p>将Server端的Binder对象发送给Client端</p>
</li>
<li><p>Activity作为Client发起bindService，最终会调度到AMS 去执行bindService。在这个过程中，Client要去调用 AMS的代码，所以此时就会涉及到跨进程调度，基于第三章的Binder通信模型我们不难知道，Client会先和 ServiceManager通信，从ServiceManager中拿到AMS的IBinder。 </p>
</li>
<li><p>Activity拿到AMS的IBinder后，跨进程执行AMS的BindService函数； </p>
</li>
<li><p>由于AMS管理所有的应用进程，因此AMS中持有了应用进程的Binder，所以此时AMS可以发起第4步也就是跨进 程调度scheduleBindService(); </p>
</li>
<li><p>Server端会在收到AMS的bindService的请求后，会将自己的IBinder发送给client，但是Server必须通过AMS才能 将Binder对象传过去，所以此时需要跨进程从ServiceManager中去拿到AMS的binder； </p>
</li>
<li><p>Server端通过AMS的binder直接调用AMS的代码publishService(),将service的Binder发送给AMS； </p>
</li>
<li><p>经过层层调用，最终AMS讲Server端的binder通过回调connect函数传递给了Client端的Activity；</p>
</li>
</ol>
<h4 id="Java与Native-通信的基本流程"><a href="#Java与Native-通信的基本流程" class="headerlink" title="Java与Native 通信的基本流程"></a>Java与Native 通信的基本流程</h4><p><img src="https://note.youdao.com/yws/api/personal/file/WEB952bd9647a30851bd833b99e2e0597b6?method=download&shareKey=78cc7149cb6cf7706498543e988d821b" alt=""></p>
<ol>
<li>Client端通过ServiceManager 拿到Server端服务的Binder 代理，也就是BinderProxy(是Server端Binder的一个代理)；</li>
<li>这个BinderProxy的访问需要经过JNI层的Android_util_binder类将请求转交给native的BpBinder（p代表代理的意思）；</li>
<li>BpBinder会通过ioctl将请求转交给Binder驱动设备；</li>
<li>在服务端注册了一个监听请求的回调函数，一旦驱动层收到BpBinder 的调用，就会回调BBInder注册的回调函数，于是，就将请求转给了BBinder；</li>
<li>BBinder拿到请求后，会进行一些数据的处理，然后通过JNI将请求转交给了java类；</li>
<li>java层会通过aidl中的函数将请求发送给Server端的实现者，由Server端通过stub 去调用相关的执行代码，并将结果通过类似的路径返回。</li>
</ol>
<h4 id="ServcieManager场景"><a href="#ServcieManager场景" class="headerlink" title="ServcieManager场景"></a>ServcieManager场景</h4><p>在跨进程通信过程中，比如与AMS通信，首先需要拿到AMS的binder，然而，AMS的binder往往是通过ServcieManager获取的，因此会有代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServiceManager.getService(Context.ACTIVITY_SERVICE)</span><br></pre></td></tr></table></figure>

<p>j接下来调用Binder.allowBlocking(rawGetService(name))，核心代码在rawGetService中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IBinder <span class="title">rawGetService</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException </span>&#123; </span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">final</span> IBinder binder = getIServiceManager().getService(name); </span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">return</span> binder; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑是，先通过getIServiceManager()获取到IServiceManager对象，然后再通过这个IServiceManager对象获取到一个IBinder。<br>注意，此处有两个IPC：</p>
<ol>
<li><p>获取到IServiceManager</p>
</li>
<li><p>通过IServiceManager获取到该name的Service的Binder的IPC</p>
<p>重在探索java到native的逻辑，先看第一个。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager <span class="title">getIServiceManager</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (sServiceManager != <span class="keyword">null</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> sServiceManager; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// Find the service manager </span></span><br><span class="line"> sServiceManager = ServiceManagerNative </span><br><span class="line"> .asInterface(Binder.allowBlocking(BinderInternal.getContextObject())); </span><br><span class="line"> <span class="keyword">return</span> sServiceManager; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这，可以看到返回的其实是ServiceManagerNative.asInterface()的返回值。<br>对AIDL有所了解就知道，asInterface()的内容大概如下：<br>这个方法属于aidl接口的内部类 Stub。 在同一进程中，就会直接返回Stub，如果在另一个进程中调用，就会返回将这个ibinder封装好的Proxy对象。后面会分析ServiceManagerNative.asInterface 函数。先看一下IBinder的来源，也就BinderInternal.getContextObject()。<br>BinderInternal.getContextObject()代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">native</span> IBinder <span class="title">getContextObject</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>JNI层代码如下：<br>android_util_Binder.android_os_BinderInternal_getContextObject()代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">android_os_BinderInternal_getContextObject</span><span class="params">(JNIEnv* env, jobject clazz)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">return</span> javaObjectForIBinder(env, b); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先通过ProcessState获取到了一个native 层的IBinder强引用，也就是一个BpBinder。 然后将这个native层的IBinder强引用传入javaObjectForIBinder()方法，最终封装成java层的IBinder然后返回。此处先不深究ProcessState的逻辑，整个native层的binder有自己的一整套的逻辑，后面的文章会继续探索。我们可以先稍微看下javaObjectForIBinder()的大概逻辑。 android_util_Binder.javaObjectForIBinder()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将一个BpBinder对象(这是native中的类型)转换成java中的类型 </span></span><br><span class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"> <span class="comment">//JavaBBinder返回true，其他类均返回flase </span></span><br><span class="line">    <span class="keyword">if</span> (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123; </span><br><span class="line">        <span class="comment">// It's a JavaBBinder created by ibinderForJavaObject. Already has Java object. </span></span><br><span class="line">        jobject object = <span class="keyword">static_cast</span>&lt;JavaBBinder*&gt;(val.<span class="built_in">get</span>())-&gt;object(); </span><br><span class="line">        LOGDEATH(<span class="string">"objectForBinder %p: it's our own %p!\n"</span>, val.<span class="built_in">get</span>(), object); </span><br><span class="line">        <span class="keyword">return</span> object; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    BinderProxyNativeData* nativeData = <span class="keyword">new</span> BinderProxyNativeData(); </span><br><span class="line">    nativeData-&gt;mOrgue = <span class="keyword">new</span> DeathRecipientList; </span><br><span class="line">    nativeData-&gt;mObject = val; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 核心代码：运用反射创建一个BinderProxy对象 </span></span><br><span class="line">    jobject object = env-&gt;CallStaticObjectMethod(gBinderProxyOffsets.mClass, </span><br><span class="line">            gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.<span class="built_in">get</span>()); </span><br><span class="line">    <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123; </span><br><span class="line">        <span class="comment">// In the exception case, getInstance still took ownership of nativeData. </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    BinderProxyNativeData* actualNativeData = getBPNativeData(env, object); </span><br><span class="line"> 	<span class="comment">//如果object是刚刚新建出来的BinderProxy </span></span><br><span class="line">    <span class="keyword">if</span> (actualNativeData == nativeData) &#123; </span><br><span class="line"> 		<span class="comment">//处理proxy计数 </span></span><br><span class="line">        <span class="comment">// Created a new Proxy </span></span><br><span class="line">        <span class="keyword">uint32_t</span> numProxies = gNumProxies.fetch_add(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_relaxed); </span><br><span class="line">        <span class="keyword">uint32_t</span> numLastWarned = gProxiesWarned.load(<span class="built_in">std</span>::memory_order_relaxed); </span><br><span class="line">        <span class="keyword">if</span> (numProxies &gt;= numLastWarned + PROXY_WARN_INTERVAL) &#123; </span><br><span class="line">            <span class="comment">// Multiple threads can get here, make sure only one of them gets to </span></span><br><span class="line">            <span class="comment">// update the warn counter. </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (gProxiesWarned.compare_exchange_strong(numLastWarned, </span><br><span class="line">                        numLastWarned + PROXY_WARN_INTERVAL, <span class="built_in">std</span>::memory_order_relaxed)) </span><br><span class="line">            &#123; </span><br><span class="line">                ALOGW(<span class="string">"Unexpectedly many live BinderProxies: %d\n"</span>, numProxies); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">delete</span> nativeData; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> object;  <span class="comment">//object 是反射参数的java的 BinderProxy </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数就是将一个BpBinder对象(这是native中的类型)转换成java中的类型，中间采用了反射技术而已。</p>
<p>核心代码gBinderProxyOffsets</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">binderproxy_offsets_t</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="comment">// Class state. </span></span><br><span class="line">    jclass mClass; </span><br><span class="line">    jmethodID mGetInstance; </span><br><span class="line">    jmethodID mSendDeathNotice; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Object state. </span></span><br><span class="line">    <span class="comment">//指向BinderProxyNativeData的指针 </span></span><br><span class="line">    jfieldID mNativeData;  <span class="comment">// Field holds native pointer to BinderProxyNativeData. </span></span><br><span class="line">&#125; gBinderProxyOffsets; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kBinderProxyPathName = <span class="string">"android/os/BinderProxy"</span>; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">int_register_android_os_BinderProxy</span><span class="params">(JNIEnv* env)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ... </span><br><span class="line">    jclass clazz = FindClassOrDie(env, kBinderProxyPathName); </span><br><span class="line">    gBinderProxyOffsets.mClass = MakeGlobalRefOrDie(env, clazz); </span><br><span class="line">    gBinderProxyOffsets.mGetInstance = GetStaticMethodIDOrDie(env, clazz, <span class="string">"getInstance"</span>, </span><br><span class="line">            <span class="string">"(JJ)Landroid/os/BinderProxy;"</span>); </span><br><span class="line">    gBinderProxyOffsets.mSendDeathNotice = </span><br><span class="line">            GetStaticMethodIDOrDie(env, clazz, <span class="string">"sendDeathNotice"</span>, </span><br><span class="line">                                   <span class="string">"</span></span><br><span class="line"><span class="string">(Landroid/os/IBinder$DeathRecipient;Landroid/os/IBinder;)V"</span>); </span><br><span class="line">    gBinderProxyOffsets.mNativeData = GetFieldIDOrDie(env, clazz, <span class="string">"mNativeData"</span>, <span class="string">"J"</span>); </span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gBinderProxyOffsets实际上是一个用来记录一些java中对应类、方法以及字段的结构体，用于从native层调用java层代码，而通过int_register_android_os_BinderProxy，我们知道，binderproxy_oﬀsets_t中的mClass字段就是 BInderProxy，而mGetInstance 就是BInderProxy.java 中getInstance方法。因此核心代码创建的是一个BinderProxy对象。</p>
<p>具体的执行流程如下图所示：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe8b639edcfbc0ca9f2ce30e8c7ae5dff?method=download&shareKey=ac21ff3e14c9010a0b4976ceea2e6d25" alt=""></p>
<p><strong>第一大步</strong>：为了获取ServcieManager 的IServiceManager，首先要ServcieManager进程创建一个底层的Binder，所<br>以会有android_os_BinderInternal_getContextObject也就是第2步，第2步会在ProcessState::self()中初始化Binder<br>驱动，然后再执行第3步；<br><strong>第二大步</strong>：上图中第3步会调用到第4步，在第4步getStrongProxyForHandle代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getStrongProxyForHandle</span><span class="params">(<span class="keyword">int32_t</span> handle)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    sp&lt;IBinder&gt; result; </span><br><span class="line"> </span><br><span class="line">    AutoMutex _l(mLock); </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//查找或建立handle对应的handle_entry </span></span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123; </span><br><span class="line">        IBinder* b = e-&gt;binder; </span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">nullptr</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) &#123; </span><br><span class="line">            <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123; </span><br><span class="line">			 <span class="comment">//当handle为ServiceManager的特殊情况 </span></span><br><span class="line">			 <span class="comment">//需要确保在创建Binder引用之前，context manager已经被binder注册 </span></span><br><span class="line">			 <span class="comment">//需要先确保ServcieManager活着 </span></span><br><span class="line">                Parcel data; </span><br><span class="line">                <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact( </span><br><span class="line">                        <span class="number">0</span>, IBinder::PING_TRANSACTION, data, <span class="literal">nullptr</span>, <span class="number">0</span>); </span><br><span class="line">                <span class="keyword">if</span> (status == DEAD_OBJECT) </span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line"> 			<span class="comment">//创建BpBinder并保存下来以便后面再次查找 </span></span><br><span class="line">            b = BpBinder::create(handle); </span><br><span class="line">            e-&gt;binder = b; </span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs(); </span><br><span class="line">            result = b; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// This little bit of nastyness is to allow us to add a primary </span></span><br><span class="line">            <span class="comment">// reference to the remote proxy when this team doesn't have one </span></span><br><span class="line">            <span class="comment">// but another team is sending the handle to us. </span></span><br><span class="line">            result.force_set(b); </span><br><span class="line">            e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中会执行一个BpBinder::create(handle)，此处会创建一个BpBinder对象，并且将BpBinder对象赋值给result对象<br>并返回result，也就是返回BpBinder对象。这个BpBinder对象一路返回，最终在android_util_Binder.cpp中的<br>android_os_BinderInternal_getContextObject函数中执行。</p>
<p><strong>第三大步</strong>：BpBinder需要返回给java层Client端使用，所以此时的封装就是将BpBinder封装成为Java层的BinderProxy对象。因此在Client端得到的IServiceManager 其实是BinderProxy类的子类的对象。所以，BinderInternal.getContextObject()，返回的是一个层层封装的类的实例，具体来说，是Native层的BpBinder对象被封装成为BinderProxy对象并返回。</p>
<h4 id="不同类型的Binder"><a href="#不同类型的Binder" class="headerlink" title="不同类型的Binder"></a>不同类型的Binder</h4><h5 id="IBinder"><a href="#IBinder" class="headerlink" title="IBinder"></a>IBinder</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IBinder从Refbase继承而来，一提供强弱指针计数能力 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBinder</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">enum</span> &#123; </span><br><span class="line">        FIRST_CALL_TRANSACTION  = <span class="number">0x00000001</span>, </span><br><span class="line">        LAST_CALL_TRANSACTION   = <span class="number">0x00ffffff</span>, </span><br><span class="line">        PING_TRANSACTION        = B_PACK_CHARS(<span class="string">'_'</span>,<span class="string">'P'</span>,<span class="string">'N'</span>,<span class="string">'G'</span>), </span><br><span class="line">        DUMP_TRANSACTION        = B_PACK_CHARS(<span class="string">'_'</span>,<span class="string">'D'</span>,<span class="string">'M'</span>,<span class="string">'P'</span>), </span><br><span class="line">        INTERFACE_TRANSACTION   = B_PACK_CHARS(<span class="string">'_'</span>, <span class="string">'N'</span>, <span class="string">'T'</span>, <span class="string">'F'</span>), </span><br><span class="line">        SYSPROPS_TRANSACTION    = B_PACK_CHARS(<span class="string">'_'</span>, <span class="string">'S'</span>, <span class="string">'P'</span>, <span class="string">'R'</span>), </span><br><span class="line">        <span class="comment">// Corresponds to TF_ONE_WAY -- an asynchronous call. </span></span><br><span class="line">        FLAG_ONEWAY             = <span class="number">0x00000001</span> </span><br><span class="line">    &#125;; </span><br><span class="line"> 	IBinder(); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 根据descriptor查询相应的IInterface对象 </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IInterface&gt;  <span class="title">queryLocalInterface</span><span class="params">(<span class="keyword">const</span> String16&amp; descriptor)</span></span>; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取descriptor描述符 </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> String16&amp; <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>            <span class="title">isBinderAlive</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span>        <span class="title">pingBinder</span><span class="params">()</span> </span>= <span class="number">0</span>; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span>        <span class="title">dump</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> Vector&lt;String16&gt;&amp; args)</span> </span>= <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// transact binder通信函数 </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span>  <span class="title">transact</span><span class="params">(<span class="keyword">uint32_t</span> code, </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">const</span> Parcel&amp; data, </span></span></span><br><span class="line"><span class="function"><span class="params">                               Parcel* reply, </span></span></span><br><span class="line"><span class="function"><span class="params">							   <span class="keyword">uint32_t</span> flags = <span class="number">0</span>)</span> </span>= <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 死亡通知相应类 </span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DeathRecipient</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase </span><br><span class="line">    &#123; </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">(<span class="keyword">const</span> wp&lt;IBinder&gt;&amp; who)</span> </span>= <span class="number">0</span>; </span><br><span class="line">    &#125;; </span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 如其名，用于注册Binder用的 </span></span><br><span class="line"> 	<span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span>  <span class="title">linkToDeath</span><span class="params">(<span class="keyword">const</span> sp&lt;DeathRecipient&gt;&amp; recipient, </span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">void</span>* cookie = <span class="literal">NULL</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">uint32_t</span> flags = <span class="number">0</span>)</span> </span>= <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 撤销用之前注册的死亡通知函数 </span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span>  <span class="title">unlinkToDeath</span><span class="params">(  <span class="keyword">const</span> wp&lt;DeathRecipient&gt;&amp; recipient, </span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">void</span>* cookie = <span class="literal">NULL</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">uint32_t</span> flags = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">                                            wp&lt;DeathRecipient&gt;* outRecipient = <span class="literal">NULL</span>)</span> </span>= <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">heckSubclass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* subclassID)</span> <span class="keyword">const</span></span>; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*object_cleanup_func)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id, <span class="keyword">void</span>* obj, <span class="keyword">void</span>* cleanupCookie)</span></span>; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">attachObject</span><span class="params">(   <span class="keyword">const</span> <span class="keyword">void</span>* objectID, </span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">void</span>* object, </span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">void</span>* cleanupCookie, </span></span></span><br><span class="line"><span class="function"><span class="params">                                            object_cleanup_func func)</span> </span>= <span class="number">0</span>; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>* <span class="title">findObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* objectID)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>  <span class="title">detachObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* objectID)</span> </span>= <span class="number">0</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 返回服务端的binder引用 </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> BBinder* <span class="title">localBinder</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 放回客户端的binder引用 </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> BpBinder* <span class="title">remoteBinder</span><span class="params">()</span></span>; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line">    <span class="keyword">virtual</span> ~IBinder(); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于IBinder中的方法，基本都是没有实现的，这些方法的实现都交给继承它的子类来实现，那下面直接看BpBinder的内容。</p>
<h5 id="BpBinder-BBinder"><a href="#BpBinder-BBinder" class="headerlink" title="BpBinder,BBinder"></a>BpBinder,BBinder</h5><p>BpBinder和BBinder都是Android中与Binder通信相关的代表，他们都是从IBinder中继承而来的。其中BpBinder是客户端用来与Server交互的代理类，BBinder则是和proxy相对的一端，它是proxy交互的目的端。如果说Proxy代表客户端，那么BBinder就代表这服务端。这里BpBinder和BBinder是一一对应的，即某个BpBinder只能和对应的BBinder交互。</p>
<h5 id="JavaBBinder"><a href="#JavaBBinder" class="headerlink" title="JavaBBinder"></a>JavaBBinder</h5><p>IBinder是BBinder的父类，BBinder是JavaBBinder的父类。<br>java层直接与native层交互的对象有两个——Binder对象与BinderProxy对象。<br>Binder对应“Binder在本进程”的场景，BinderProxy对应“Binder在其他进程”的场景。<br>native层javaBBinder与java层的Binder一一对应。<br>native层的BinderProxyNativeData与java层的BinderProxy一一对应。<br>在native层，gBinderProxyOﬀsets(binderproxy_oﬀsets_t)存储了java层binderProxy的对象与需要调用的方法和属<br>性。gBinderOﬀsets(binderproxy_oﬀsets_t)存储了java层binder的对象与需要调用的方法和属性。<br>ibinderForJavaObject负责通过java的Binder或者BinderProxy对象，找到并返回native层的IBinder对象。</p>
<p>javaObjectForIBinder通过native层的IBinder对象，找到或者封装成java对象返回。</p>
<h4 id="ServiceManager-getService方法"><a href="#ServiceManager-getService方法" class="headerlink" title="ServiceManager.getService方法"></a>ServiceManager.getService方法</h4><p>第一步：先调用IServiceManager.Stub.Proxy的getService方法 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">getService</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> </span></span><br><span class="line"><span class="function">android.os.RemoteException </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain(); </span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain(); </span><br><span class="line">    android.os.IBinder _result; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR); </span><br><span class="line">        _data.writeString(name); </span><br><span class="line">        <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_getService, _data, _reply, </span><br><span class="line">                          <span class="number">0</span>); </span><br><span class="line">        _reply.readException(); </span><br><span class="line">        _result = _reply.readStrongBinder(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">finally</span> &#123; </span><br><span class="line">        _reply.recycle(); </span><br><span class="line">        _data.recycle(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> _result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：接下来会调用mRemote.transact </p>
<p>而mRemote则是BinderProxy对象，所以接下来执行下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> </span></span><br><span class="line"><span class="function">RemoteException </span>&#123; </span><br><span class="line">    <span class="comment">//检查Parcel大小 if (CHECK_PARCEL_SIZE &amp;&amp; parcel.dataSize() &gt;= 800*1024)</span></span><br><span class="line">    Binder.checkParcel(<span class="keyword">this</span>, code, data, <span class="string">"Unreasonably large binder buffer"</span>);</span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">//trace </span></span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">//Binder事务处理回调 </span></span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">//AppOpsManager信息记录 </span></span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> result = transactNative(code, data, reply, flags); </span><br><span class="line">        <span class="keyword">if</span> (reply != <span class="keyword">null</span> &amp;&amp; !warnOnBlocking) &#123; </span><br><span class="line">            reply.addFlags(Parcel.FLAG_IS_REPLY_FROM_BLOCKING_ALLOWED_OBJECT); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> result; </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，系统会通过checkParcel检测数据的格式和大小，Android默认设置了Parcel数据传输不能超过800k,如果超过了的话，便会调用Slog.wtfStack打印日志，需要注意的是，在当前进程不是系统进程并且系统也不是工程版本的情况下，这个方法是会结束进程的，所以在应用开发的时候，我们需要注意跨进程数据传输的大小，避免因此引发crash。</p>
<p>核心函数是调用transactNative方法，这是一个native方法，在frameworks/base/core/jni/android_util_Binder.cpp中实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj, </span></span></span><br><span class="line"><span class="function"><span class="params">        jint code, jobject dataObj, jobject replyObj, jint flags)</span>  </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (dataObj == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        jniThrowNullPointerException(env, <span class="literal">NULL</span>); </span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    Parcel* data = parcelForJavaObject(env, dataObj); </span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE; </span><br><span class="line">    &#125; </span><br><span class="line">    Parcel* reply = parcelForJavaObject(env, replyObj); </span><br><span class="line">    <span class="keyword">if</span> (reply == <span class="literal">NULL</span> &amp;&amp; replyObj != <span class="literal">NULL</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    IBinder* target = getBPNativeData(env, obj)-&gt;mObject.<span class="built_in">get</span>(); </span><br><span class="line">    <span class="keyword">if</span> (target == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>, <span class="string">"Binder has been </span></span><br><span class="line"><span class="string">finalized!"</span>); </span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//log </span></span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">status_t</span> err = target-&gt;transact(code, *data, reply, flags); </span><br><span class="line">    <span class="comment">//log </span></span><br><span class="line">    ... </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123; </span><br><span class="line">        <span class="keyword">return</span> JNI_TRUE; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == UNKNOWN_TRANSACTION) &#123; </span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    signalExceptionForError(env, obj, err, <span class="literal">true</span> <span class="comment">/*canThrowRemoteException*/</span>,  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> data-&gt;dataSize()); </span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先是获得native层对应的Parcel并执行判断，Parcel实际上功能是在native中实现的，java中的Parcel类使用mNativePtr成员变量保存了其对应native中的Parcel的指针，然后调用getBPNativeData函数获得BinderProxy在native中对应的BinderProxyNativeData，再通过里面的mObject域成员变量得到其对应的BpBinder。</p>
<p>getBPNativeData(env, obj)-&gt;mObject.get();是上面代码的核心之一，调用getBPNativeData函数获得BinderProxy在native中对应的BinderProxyNativeData，target 事实上是BpBinder。</p>
<p>第三步，BpBinder 的transact函数<br>此时就顺理成章的调用到了BpBinder的transact函数了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BpBinder::transact</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life. </span></span><br><span class="line">    <span class="comment">//判断binder服务是否存活 </span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123; </span><br><span class="line">        ... </span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact( </span><br><span class="line">            mHandle, code, data, reply, flags); </span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> status; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个Alive判断，可以避免对一个已经死亡的binder服务再发起事务，浪费资源，除此之外便是调用IPCThreadState的transact函数了。</p>
<p>第四步：IPCThreadState的transact函数调用<br>路径：frameworks/native/libs/binder/IPCThreadState.cpp<br>ProcessState负责打开binder驱动并进行mmap映射，而IPCThreadState则是负责与binder驱动进行具体的交互<br>IPCThreadState也有一个self函数，与ProcessState的self不同的是，ProcessState是进程单例，而IPCThreadState是线程单例。<br>我们接着看它的ProcessState的transact函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="keyword">int32_t</span> handle, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">status_t</span> err; </span><br><span class="line">    flags |= TF_ACCEPT_FDS; </span><br><span class="line">    <span class="comment">//log </span></span><br><span class="line">    ...     </span><br><span class="line">    err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">nullptr</span>); </span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123; </span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err); </span><br><span class="line">        <span class="keyword">return</span> (mLastError = err); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;    <span class="comment">//binder事务不为TF_ONE_WAY </span></span><br><span class="line">        <span class="comment">//当线程限制binder事务不为TF_ONE_WAY时 </span></span><br><span class="line">        <span class="keyword">if</span> (UNLIKELY(mCallRestriction != ProcessState::CallRestriction::NONE)) &#123; </span><br><span class="line">            <span class="keyword">if</span> (mCallRestriction == ProcessState::CallRestriction::ERROR_IF_NOT_ONEWAY) &#123; </span><br><span class="line">                <span class="comment">//这个限制只是log记录 </span></span><br><span class="line">                ALOGE(<span class="string">"Process making non-oneway call (code: %u) but is restricted."</span>, code); </span><br><span class="line">                CallStack::logStack(<span class="string">"non-oneway call"</span>, CallStack::getCurrent(<span class="number">10</span>).<span class="built_in">get</span>(), </span><br><span class="line">                    ANDROID_LOG_ERROR); </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">/* FATAL_IF_NOT_ONEWAY */</span> &#123; </span><br><span class="line">                <span class="comment">//这个限制会终止线程 </span></span><br><span class="line">                LOG_ALWAYS_FATAL(<span class="string">"Process may not make non-oneway calls (code: %u)."</span>, code); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (reply) &#123; </span><br><span class="line">            err = waitForResponse(reply); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            Parcel fakeReply; </span><br><span class="line">            err = waitForResponse(&amp;fakeReply); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//log </span></span><br><span class="line">        ... </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">//binder事务为TF_ONE_WAY </span></span><br><span class="line">        err = waitForResponse(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> err; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的重点在于writeTransactionData和waitForResponse，我们依次分析:<br>首先看writeTransactionData:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    binder_transaction_data tr; </span><br><span class="line"> </span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don't pass uninitialized stack data to a remote process */</span> </span><br><span class="line">    <span class="comment">//目标binder句柄值，ServiceManager为0 </span></span><br><span class="line">    tr.target.handle = handle; </span><br><span class="line">    tr.code = code; </span><br><span class="line">    tr.flags = binderFlags; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    tr.cookie = <span class="number">0</span>; </span><br><span class="line">    tr.sender_pid = <span class="number">0</span>; </span><br><span class="line">    tr.sender_euid = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck(); </span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123; </span><br><span class="line">        <span class="comment">//数据大小 </span></span><br><span class="line">        tr.data_size = data.ipcDataSize(); </span><br><span class="line">        <span class="comment">//数据区起始地址 </span></span><br><span class="line">        tr.data.ptr.<span class="built_in">buffer</span> = data.ipcData(); </span><br><span class="line">        <span class="comment">//传递的偏移数组大小 </span></span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>); </span><br><span class="line">        <span class="comment">//偏移数组的起始地址 </span></span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects(); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123; </span><br><span class="line">        tr.flags |= TF_STATUS_CODE; </span><br><span class="line">        *statusBuffer = err; </span><br><span class="line">        tr.data_size = <span class="keyword">sizeof</span>(<span class="keyword">status_t</span>); </span><br><span class="line">        tr.data.ptr.<span class="built_in">buffer</span> = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(statusBuffer); </span><br><span class="line">        tr.offsets_size = <span class="number">0</span>; </span><br><span class="line">        tr.data.ptr.offsets = <span class="number">0</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> (mLastError = err); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//核心代码所在 </span></span><br><span class="line">    <span class="comment">//这里为BC_TRANSACTION </span></span><br><span class="line">    mOut.writeInt32(cmd); </span><br><span class="line">    mOut.<span class="built_in">write</span>(&amp;tr, <span class="keyword">sizeof</span>(tr)); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> NO_ERROR; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>binder_transaction_data结构体(tr结构体）是向Binder驱动通信的数据结构，上面函数中，我们将binder请求码（这里为BC_TRANSACTION）和binder_transaction_data结构体依次写入到mOut中，为之后binder_tansaction做准备。<br>再看waitForResponse函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">uint32_t</span> cmd; </span><br><span class="line">    <span class="keyword">int32_t</span> err; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>; </span><br><span class="line">        err = mIn.errorCheck(); </span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>; </span><br><span class="line">        cmd = (<span class="keyword">uint32_t</span>)mIn.readInt32(); </span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123; </span><br><span class="line">        <span class="keyword">case</span> BR_ONEWAY_SPAM_SUSPECT: </span><br><span class="line">            ... </span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE: </span><br><span class="line">            <span class="comment">//当TF_ONE_WAY模式下收到BR_TRANSACTION_COMPLETE直接返回，本次binder通信结束 </span></span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> BR_DEAD_REPLY: </span><br><span class="line">            ... </span><br><span class="line">        <span class="keyword">case</span> BR_FAILED_REPLY: </span><br><span class="line">            ... </span><br><span class="line">        <span class="keyword">case</span> BR_FROZEN_REPLY: </span><br><span class="line">            ... </span><br><span class="line">        <span class="keyword">case</span> BR_ACQUIRE_RESULT: </span><br><span class="line">            ... </span><br><span class="line">        <span class="keyword">case</span> BR_REPLY: </span><br><span class="line">            &#123; </span><br><span class="line">                binder_transaction_data tr; </span><br><span class="line">                err = mIn.<span class="built_in">read</span>(&amp;tr, <span class="keyword">sizeof</span>(tr)); </span><br><span class="line">                ALOG_ASSERT(err == NO_ERROR, <span class="string">"Not enough command data for brREPLY"</span>); </span><br><span class="line">                <span class="comment">//失败直接返回 </span></span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish; </span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (reply) &#123;    <span class="comment">//客户端需要接收replay </span></span><br><span class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;    <span class="comment">//正常reply内容 </span></span><br><span class="line">                        reply-&gt;ipcSetDataReference( </span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.<span class="built_in">buffer</span>), </span><br><span class="line">                            tr.data_size, </span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets), </span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>), </span><br><span class="line">                            freeBuffer <span class="comment">/*释放缓冲区*/</span>); </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//内容只是一个32位的状态码 </span></span><br><span class="line">                        <span class="comment">//接收状态码 </span></span><br><span class="line">                        err = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">status_t</span>*&gt;(tr.data.ptr.<span class="built_in">buffer</span>); </span><br><span class="line">                        <span class="comment">//释放缓冲区 </span></span><br><span class="line">                        freeBuffer(<span class="literal">nullptr</span>, </span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.<span class="built_in">buffer</span>), </span><br><span class="line">                            tr.data_size, </span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets), </span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>)); </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">//客户端不需要接收replay </span></span><br><span class="line">                    <span class="comment">//释放缓冲区 </span></span><br><span class="line">                    freeBuffer(<span class="literal">nullptr</span>, </span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.<span class="built_in">buffer</span>), </span><br><span class="line">                        tr.data_size, </span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets), </span><br><span class="line">                        tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>)); </span><br><span class="line">                    <span class="keyword">continue</span>; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">goto</span> finish; </span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            <span class="comment">//这里是binder服务端部分的处理，现在不需要关注 </span></span><br><span class="line">            err = executeCommand(cmd); </span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">finish: </span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123; </span><br><span class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err; </span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err); </span><br><span class="line">        mLastError = err; </span><br><span class="line">        logExtendedError(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> err; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个循环，正如函数名所描述，会一直等待到一整条binder事务链结束返回后才会退出这个循环，在这个循环的开头，便是talkWithDriver方法，在talkWithDriver 函数里面主要是调用Binder驱动的ioctl方法完成数据的传输。</p>
<p>上面整理了Client端通过ServiceManager的getService函数去获取对应服务的对象的过程，分析到了将getService请求发送给Binder驱动。下面继续开始分析服务端收到getService的请求后如何处理的总流程。</p>
<h4 id="ServiceManager进程-死循环"><a href="#ServiceManager进程-死循环" class="headerlink" title="ServiceManager进程 死循环"></a>ServiceManager进程 死循环</h4><p>servicemanager进程的入口函数在frameworks\native\cmds\servicemanager\main.cpp中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123; </span><br><span class="line"> <span class="comment">//根据上面的rc文件，argc == 1, argv[0] == "/system/bin/servicemanager" </span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">2</span>) &#123; </span><br><span class="line">        LOG(FATAL) &lt;&lt; <span class="string">"usage: "</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">" [binder driver]"</span>; </span><br><span class="line">    &#125; </span><br><span class="line"> <span class="comment">//此时，要使用的binder驱动为/dev/binder </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* driver = argc == <span class="number">2</span> ? argv[<span class="number">1</span>] : <span class="string">"/dev/binder"</span>; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//初始化binder驱动 </span></span><br><span class="line">    sp&lt;ProcessState&gt; ps = ProcessState::initWithDriver(driver); </span><br><span class="line">    ps-&gt;setThreadPoolMaxThreadCount(<span class="number">0</span>); </span><br><span class="line">    ps-&gt;setCallRestriction(ProcessState::CallRestriction::FATAL_IF_NOT_ONEWAY); </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//实例化ServiceManager，传入Access类用于鉴权 </span></span><br><span class="line">    sp&lt;ServiceManager&gt; manager = <span class="keyword">new</span> ServiceManager(<span class="built_in">std</span>::make_unique&lt;Access&gt;()); </span><br><span class="line">    <span class="comment">//将自身作为服务添加 </span></span><br><span class="line"> <span class="keyword">if</span> (!manager-&gt;addService(<span class="string">"manager"</span>, manager, <span class="literal">false</span> <span class="comment">/*allowIsolated*/</span>, </span><br><span class="line">IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).isOk()) &#123; </span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Could not self register servicemanager"</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//设置服务端Bbinder对象 </span></span><br><span class="line">    IPCThreadState::self()-&gt;setTheContextObject(manager); </span><br><span class="line"> <span class="comment">//设置成为binder驱动的context manager,成为上下文的管理者 </span></span><br><span class="line">    ps-&gt;becomeContextManager(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>); </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//通过Looper epoll机制处理binder事务 </span></span><br><span class="line">    sp&lt;Looper&gt; looper = Looper::<span class="built_in">prepare</span>(<span class="literal">false</span> <span class="comment">/*allowNonCallbacks*/</span>); </span><br><span class="line">    <span class="comment">//通知驱动BC_ENTER_LOOPER，监听驱动fd，有消息时回调到handleEvent处理binder调用 </span></span><br><span class="line">    BinderCallback::setupTo(looper); </span><br><span class="line">    <span class="comment">//服务的注册监听相关 </span></span><br><span class="line">    ClientCallbackCallback::setupTo(looper, manager); </span><br><span class="line">    <span class="comment">//无限循环等消息 </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line">        looper-&gt;pollAll(<span class="number">-1</span>);  </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// should not be reached </span></span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的Looper和我们平常应用开发所说的Looper是一个东西，可以通过Looper::addFd函数监听文件描述符，通过Looper::pollAll或Looper::pollOnce函数接收消息，消息抵达后会回调LooperCallback::handleEvent函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinderCallback</span> :</span> <span class="keyword">public</span> LooperCallback &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">static</span> sp&lt;BinderCallback&gt; <span class="title">setupTo</span><span class="params">(<span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper)</span> </span>&#123; </span><br><span class="line">        sp&lt;BinderCallback&gt; cb = <span class="keyword">new</span> BinderCallback; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> binder_fd = <span class="number">-1</span>; </span><br><span class="line">        <span class="comment">//向binder驱动发送BC_ENTER_LOOPER事务请求，并获得binder设备的文件描述符 </span></span><br><span class="line">        IPCThreadState::self()-&gt;setupPolling(&amp;binder_fd); </span><br><span class="line">        LOG_ALWAYS_FATAL_IF(binder_fd &lt; <span class="number">0</span>, <span class="string">"Failed to setupPolling: %d"</span>, binder_fd); </span><br><span class="line">        <span class="comment">// Flush after setupPolling(), to make sure the binder driver </span></span><br><span class="line">        <span class="comment">// knows about this thread handling commands. </span></span><br><span class="line">        IPCThreadState::self()-&gt;flushCommands(); </span><br><span class="line">         <span class="comment">//监听binder文件描述符 </span></span><br><span class="line">        <span class="keyword">int</span> ret = looper-&gt;addFd(binder_fd, </span><br><span class="line">                                Looper::POLL_CALLBACK, </span><br><span class="line">                                Looper::EVENT_INPUT, </span><br><span class="line">                                cb, </span><br><span class="line">                                <span class="literal">nullptr</span> <span class="comment">/*data*/</span>); </span><br><span class="line">        LOG_ALWAYS_FATAL_IF(ret != <span class="number">1</span>, <span class="string">"Failed to add binder FD to Looper"</span>); </span><br><span class="line">        <span class="keyword">return</span> cb; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">handleEvent</span><span class="params">(<span class="keyword">int</span> <span class="comment">/* fd */</span>, <span class="keyword">int</span> <span class="comment">/* events */</span>, <span class="keyword">void</span>* <span class="comment">/* data */</span>)</span> <span class="keyword">override</span> </span>&#123; </span><br><span class="line">        <span class="comment">//从binder驱动接收到消息并处理 </span></span><br><span class="line">        IPCThreadState::self()-&gt;handlePolledCommands(); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// Continue receiving callbacks. </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在servicemanager进程启动的过程中调用了BinderCallback::setupTo函数，这个函数首先向binder驱动发起了一个BC_ENTER_LOOPER事务请求，获得binder设备的文件描述符，然后调用Looper::addFd函数监听binder设备文件描述符，这样当binder驱动发来消息后，就可以通过Looper::handleEvent函数接收并处理了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::setupPolling</span><span class="params">(<span class="keyword">int</span>* fd)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> -EBADF; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//设置binder请求码 </span></span><br><span class="line">    mOut.writeInt32(BC_ENTER_LOOPER); </span><br><span class="line">    <span class="comment">//检查写缓存是否有可写数据，有的话发送给binder驱动 </span></span><br><span class="line">    flushCommands(); </span><br><span class="line">    <span class="comment">//赋值binder驱动的文件描述符 </span></span><br><span class="line">    *fd = mProcess-&gt;mDriverFD; </span><br><span class="line">    pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock); </span><br><span class="line">    mProcess-&gt;mCurrentThreads++; </span><br><span class="line">    pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于以上的分析，一旦Client端发送IPC请求，就会通过Binder驱动发送消息给服务端，而服务端则通过BinderCallback来接收消息，并做下一步的处理。</p>
<h4 id="Binder驱动事务处理"><a href="#Binder驱动事务处理" class="headerlink" title="Binder驱动事务处理"></a>Binder驱动事务处理</h4><p>BinderCallback类重写了handleEvent函数，里面调用了IPCThreadState::handlePolledCommands函数来接收处理binder事务</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::handlePolledCommands</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">status_t</span> result; </span><br><span class="line">    <span class="comment">//当读缓存中数据未消费完时，持续循环 </span></span><br><span class="line">    <span class="keyword">do</span> &#123; </span><br><span class="line">        result = getAndExecuteCommand(); </span><br><span class="line">    &#125; <span class="keyword">while</span> (mIn.dataPosition() &lt; mIn.dataSize()); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//当我们清空执行完所有的命令后，最后处理BR_DECREFS和BR_RELEASE </span></span><br><span class="line">    processPendingDerefs(); </span><br><span class="line">    flushCommands(); </span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的重点在getAndExecuteCommand，首先无论如何从binder驱动那里读取并处理一次响应，如果处理完后发现读缓存中还有数据尚未消费完，继续循环这个处理过程（理论来说此时不会再从binder驱动那里读写数据，只会处理剩余读缓存）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::getAndExecuteCommand</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">status_t</span> result; </span><br><span class="line">    <span class="keyword">int32_t</span> cmd; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//从binder驱动中读写数据（理论来说此时写缓存dataSize为0，也就是只读数据） </span></span><br><span class="line">    result = talkWithDriver(<span class="comment">/* true */</span>); </span><br><span class="line">    <span class="keyword">if</span> (result &gt;= NO_ERROR) &#123; </span><br><span class="line">        <span class="keyword">size_t</span> IN = mIn.dataAvail(); </span><br><span class="line">        <span class="keyword">if</span> (IN &lt; <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>)) <span class="keyword">return</span> result; </span><br><span class="line">        <span class="comment">//读取BR响应码 </span></span><br><span class="line">        cmd = mIn.readInt32(); </span><br><span class="line">        ... </span><br><span class="line">        result = executeCommand(cmd); </span><br><span class="line">        ... </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从binder驱动中读取数据，然后从数据中读取出BR响应码，接着调用executeCommand函数继续往下处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::executeCommand</span><span class="params">(<span class="keyword">int32_t</span> cmd)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    BBinder* obj; </span><br><span class="line">    RefBase::weakref_type* refs; </span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR; </span><br><span class="line">    <span class="keyword">switch</span> ((<span class="keyword">uint32_t</span>)cmd) &#123; </span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">case</span> BR_TRANSACTION_SEC_CTX: </span><br><span class="line">    <span class="keyword">case</span> BR_TRANSACTION: </span><br><span class="line">        &#123; </span><br><span class="line">            binder_transaction_data_secctx tr_secctx; </span><br><span class="line">            binder_transaction_data&amp; tr = tr_secctx.transaction_data; </span><br><span class="line">            <span class="keyword">if</span> (cmd == (<span class="keyword">int</span>) BR_TRANSACTION_SEC_CTX) &#123; </span><br><span class="line">                result = mIn.<span class="built_in">read</span>(&amp;tr_secctx, <span class="keyword">sizeof</span>(tr_secctx)); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                result = mIn.<span class="built_in">read</span>(&amp;tr, <span class="keyword">sizeof</span>(tr)); </span><br><span class="line">                tr_secctx.secctx = <span class="number">0</span>; </span><br><span class="line">            &#125; </span><br><span class="line">            ALOG_ASSERT(result == NO_ERROR, </span><br><span class="line">                <span class="string">"Not enough command data for brTRANSACTION"</span>); </span><br><span class="line">            <span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">break</span>; </span><br><span class="line">            <span class="comment">//读取数据到缓冲区 </span></span><br><span class="line">            Parcel <span class="built_in">buffer</span>; </span><br><span class="line">            <span class="built_in">buffer</span>.ipcSetDataReference( </span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.<span class="built_in">buffer</span>), </span><br><span class="line">                tr.data_size, </span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets), </span><br><span class="line">                tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>), freeBuffer, <span class="keyword">this</span>); </span><br><span class="line">            ... </span><br><span class="line">            Parcel reply; </span><br><span class="line">            <span class="keyword">status_t</span> error; </span><br><span class="line">            <span class="comment">//对于ServiceManager的binder节点来说，是没有ptr的 </span></span><br><span class="line">            <span class="keyword">if</span> (tr.target.ptr) &#123; </span><br><span class="line">                <span class="comment">// We only have a weak reference on the target object, so we must first try to </span></span><br><span class="line">                <span class="comment">// safely acquire a strong reference before doing anything else with it. </span></span><br><span class="line">                <span class="comment">//对于其他binder服务端来说，tr.cookie为本地BBinder对象指针 </span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">reinterpret_cast</span>&lt;RefBase::weakref_type*&gt;( </span><br><span class="line">                        tr.target.ptr)-&gt;attemptIncStrong(<span class="keyword">this</span>)) &#123; </span><br><span class="line">                    error = <span class="keyword">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, <span class="built_in">buffer</span>, </span><br><span class="line">                            &amp;reply, tr.flags); </span><br><span class="line">                    <span class="keyword">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;decStrong(<span class="keyword">this</span>); </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                    error = UNKNOWN_TRANSACTION; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">//对于ServiceManager来说，使用the_context_object这个BBinder对象 </span></span><br><span class="line">                error = the_context_object-&gt;transact(tr.code, <span class="built_in">buffer</span>, &amp;reply, tr.flags); </span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> ((tr.flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123; </span><br><span class="line">                LOG_ONEWAY(<span class="string">"Sending reply to %d!"</span>, mCallingPid); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error); </span><br><span class="line">                <span class="comment">//非TF_ONE_WAY模式下需要Reply </span></span><br><span class="line">                sendReply(reply, <span class="number">0</span>); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                ... <span class="comment">//TF_ONE_WAY模式下不需要Reply，这里只打了些日志 </span></span><br><span class="line">            &#125; </span><br><span class="line">            ... </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">        ... </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123; </span><br><span class="line">        mLastError = result; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点分析这个函数在BR_TRANSACTION下的case，首先，这个函数从读缓存中读取了binder_transaction_data，我们知道这个结构体记录了实际数据的地址、大小等信息，然后实例化了一个Parcel对象作为缓冲区，从binder_transaction_data中将实际数据读取出来。<br>接着找到本地BBinder对象，对于ServiceManager来说就是之前在main函数中setTheContextObject的ServiceManager对象，而对于其他binder服务端来说，则是通过tr.cookie获取，然后调用BBinder的transact函数。</p>
<p>理论上来说，the_context_object-&gt;transact(tr.code, buﬀer, &amp;reply, tr.ﬂags)，应该是执行ServiceManager中的transact函数，但是在ServiceManager中没有实现该函数，因此只能去父类BnServiceManager中去找transact函数，但是很不巧BnServiceManager中也不存在于是再找父类，只有在BBinder中存在transact函数，因此会执行到BBinder中的transact函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BBinder::transact</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//确保从头开始读取数据 </span></span><br><span class="line">    data.setDataPosition(<span class="number">0</span>); </span><br><span class="line">    <span class="keyword">if</span> (reply != <span class="literal">nullptr</span> &amp;&amp; (flags &amp; FLAG_CLEAR_BUF)) &#123; </span><br><span class="line">        <span class="comment">//标记这个Parcel在释放时需要将内存中数据用0覆盖（涉及安全） </span></span><br><span class="line">        reply-&gt;markSensitive(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">status_t</span> err = NO_ERROR; </span><br><span class="line">    <span class="comment">//这里的code是由binder客户端请求传递过来的 </span></span><br><span class="line">    <span class="comment">//是客户端与服务端的一个约定 </span></span><br><span class="line">    <span class="comment">//它标识了客户端像服务端发起的是哪种请求 </span></span><br><span class="line">    <span class="keyword">switch</span> (code) &#123; </span><br><span class="line">        ... </span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            err = onTransact(code, data, reply, flags); </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// In case this is being transacted on in the same process. </span></span><br><span class="line">    <span class="keyword">if</span> (reply != <span class="literal">nullptr</span>) &#123; </span><br><span class="line">        <span class="comment">//设置数据指针偏移为0，这样后续读取数据便会从头开始 </span></span><br><span class="line">        reply-&gt;setDataPosition(<span class="number">0</span>); </span><br><span class="line">        <span class="keyword">if</span> (reply-&gt;dataSize() &gt; LOG_REPLIES_OVER_SIZE) &#123; </span><br><span class="line">            ALOGW(<span class="string">"Large reply transaction of %zu bytes, interface descriptor %s, code %d"</span>, </span><br><span class="line">                  reply-&gt;dataSize(), String8(getInterfaceDescriptor()).c_str(), code); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> err; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析下继承关系后，会执行到BnServiceManager中的onTransact中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">android::<span class="keyword">status_t</span> <span class="title">BnServiceManager::onTransact</span><span class="params">(<span class="keyword">uint32_t</span> _aidl_code, <span class="keyword">const</span> ::android::Parcel&amp; </span></span></span><br><span class="line"><span class="function"><span class="params">_aidl_data, ::android::Parcel* _aidl_reply, <span class="keyword">uint32_t</span> _aidl_flags)</span> </span>&#123; </span><br><span class="line">  ::android::<span class="keyword">status_t</span> _aidl_ret_status = ::android::OK; </span><br><span class="line">  <span class="keyword">switch</span> (_aidl_code) &#123; </span><br><span class="line">  <span class="comment">// 省略代码 </span></span><br><span class="line">  <span class="keyword">case</span> ::android::IBinder::FIRST_CALL_TRANSACTION + <span class="number">2</span> <span class="comment">/* addService */</span>: </span><br><span class="line">  &#123; </span><br><span class="line">       ::android::binder::Status _aidl_status(addService(in_name, in_service,  in_allowIsolated, in_dumpPriority));  <span class="comment">//addService 是核心 </span></span><br><span class="line">        _aidl_ret_status = _aidl_status.writeToParcel(_aidl_reply); </span><br><span class="line">       <span class="keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123; </span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">    	&#125; </span><br><span class="line">      <span class="keyword">if</span> (!_aidl_status.isOk()) &#123; </span><br><span class="line">      	<span class="keyword">break</span>; </span><br><span class="line">    	&#125; </span><br><span class="line"> 	 &#125;</span><br><span class="line">   <span class="keyword">break</span>; </span><br><span class="line">   <span class="keyword">default</span>: </span><br><span class="line">  &#123; </span><br><span class="line">    _aidl_ret_status = ::android::BBinder::onTransact(_aidl_code, _aidl_data, _aidl_reply, </span><br><span class="line">_aidl_flags); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _aidl_ret_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码的核心是addService，而addService的实现类就是ServiceManager里面的addService函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ServiceManager::addService</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder, <span class="keyword">bool</span> </span></span></span><br><span class="line"><span class="function"><span class="params">allowIsolated, <span class="keyword">int32_t</span> dumpPriority)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">auto</span> ctx = mAccess-&gt;getCallingContext(); </span><br><span class="line">    <span class="comment">// apps cannot add services </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> VENDORSERVICEMANAGER </span></span><br><span class="line">    <span class="keyword">if</span> (!meetsDeclarationRequirements(binder, name)) &#123; </span><br><span class="line">        <span class="comment">// already logged </span></span><br><span class="line">        <span class="keyword">return</span> Status::fromExceptionCode(Status::EX_ILLEGAL_ARGUMENT); </span><br><span class="line">    &#125; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// !VENDORSERVICEMANAGER </span></span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// implicitly unlinked when the binder is removed </span></span><br><span class="line">    <span class="keyword">if</span> (binder-&gt;remoteBinder() != <span class="literal">nullptr</span> &amp;&amp; binder-&gt;linkToDeath(<span class="keyword">this</span>) != OK) &#123; </span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Could not linkToDeath when adding "</span> &lt;&lt; name; </span><br><span class="line">        <span class="keyword">return</span> Status::fromExceptionCode(Status::EX_ILLEGAL_STATE); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Overwrite the old service if it exists </span></span><br><span class="line">    mNameToService[name] = Service &#123; </span><br><span class="line">        .binder = binder, </span><br><span class="line">        .allowIsolated = allowIsolated, </span><br><span class="line">        .dumpPriority = dumpPriority, </span><br><span class="line">        .debugPid = ctx.debugPid, </span><br><span class="line">    &#125;; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> it = mNameToRegistrationCallback.<span class="built_in">find</span>(name); </span><br><span class="line">    <span class="keyword">if</span> (it != mNameToRegistrationCallback.<span class="built_in">end</span>()) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> sp&lt;IServiceCallback&gt;&amp; cb : it-&gt;second) &#123; </span><br><span class="line">            mNameToService[name].guaranteeClient = <span class="literal">true</span>; </span><br><span class="line">            <span class="comment">// permission checked in registerForNotifications </span></span><br><span class="line">            cb-&gt;onRegistration(name, binder); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> Status::ok(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，服务的binder被封装成为了一个Service，并复制给了mNameToService数组进行存储。</p>
<h4 id="IPCThreadState-解析"><a href="#IPCThreadState-解析" class="headerlink" title="IPCThreadState 解析"></a>IPCThreadState 解析</h4><p>在Android中，每个参与Binder通信的线程都会有一个IPCThreadState实例与之关联。我最开始接触到这个类是在BpBinder::transact方法中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">tatus_t</span> <span class="title">BpBinder::transact</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life. </span></span><br><span class="line">    <span class="comment">//判断binder服务是否存活 </span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123; </span><br><span class="line">       <span class="comment">//非核心代码 </span></span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact( </span><br><span class="line">            mHandle, code, data, reply, flags); </span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> status; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其就是调用的IPCThreadState::transact来完成的数据传输工作，其工作可以分为两步：</p>
<p>1、发送数据 </p>
<p>实际上，writeTransactionData只是将数据转换成binder_transaction_data结构并重新写入到IPCThreadState::mOut中。<br>并没有真正的将数据发送出去。实际的发送操作是在waitForResponse中完成的。</p>
<p>2、接收数据 </p>
<p>F_ONE_WAY表示的是单向通信，不需要对端回复。所以这里接收数据就多了几个判断分支。区别就是参数不一样。<br>该函数必定需要被执行的，因为数据要发出去</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="keyword">int32_t</span> handle, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">status_t</span> err; </span><br><span class="line">    flags |= TF_ACCEPT_FDS; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//writeTransactionData函数用于传输数据，其中第一个参数BC_TRANSACTION </span></span><br><span class="line"> <span class="comment">//代表向Binder驱动发送命令协议，向Binder设备发送的命令协议都以BC_开头， </span></span><br><span class="line"> <span class="comment">//而Binder驱动返回的命令协议以BR_开头 </span></span><br><span class="line">    err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">nullptr</span>); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123; </span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err); </span><br><span class="line">        <span class="keyword">return</span> (mLastError = err); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;  <span class="comment">//binder事务不为TF_ONE_WAY </span></span><br><span class="line">        <span class="comment">//省略代码 </span></span><br><span class="line">        <span class="keyword">if</span> (reply) &#123; </span><br><span class="line">            err = waitForResponse(reply); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            Parcel fakeReply; </span><br><span class="line">            err = waitForResponse(&amp;fakeReply); </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        err = waitForResponse(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> err; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">uint32_t</span> cmd; </span><br><span class="line">    <span class="keyword">int32_t</span> err; </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>; </span><br><span class="line">        err = mIn.errorCheck(); </span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>; </span><br><span class="line">        cmd = (<span class="keyword">uint32_t</span>)mIn.readInt32(); </span><br><span class="line"> </span><br><span class="line">        IF_LOG_COMMANDS() &#123; </span><br><span class="line">            alog &lt;&lt; <span class="string">"Processing waitForResponse Command: "</span> </span><br><span class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123; </span><br><span class="line">        <span class="comment">//处理命令 </span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line"> 			<span class="comment">//这里是binder服务端部分的处理</span></span><br><span class="line">            err = executeCommand(cmd); </span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">finish: </span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123; </span><br><span class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err; </span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err); </span><br><span class="line">        mLastError = err; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> err; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要处理如下这些cmd</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *kReturnStrings[] = &#123; </span><br><span class="line">    <span class="string">"BR_ERROR"</span>, </span><br><span class="line">    <span class="string">"BR_OK"</span>, </span><br><span class="line">    <span class="string">"BR_TRANSACTION"</span>, </span><br><span class="line">    <span class="string">"BR_REPLY"</span>, </span><br><span class="line">    <span class="string">"BR_ACQUIRE_RESULT"</span>, </span><br><span class="line">    <span class="string">"BR_DEAD_REPLY"</span>, </span><br><span class="line">    <span class="string">"BR_TRANSACTION_COMPLETE"</span>, </span><br><span class="line">    <span class="string">"BR_INCREFS"</span>, </span><br><span class="line">    <span class="string">"BR_ACQUIRE"</span>, </span><br><span class="line">    <span class="string">"BR_RELEASE"</span>, </span><br><span class="line">    <span class="string">"BR_DECREFS"</span>, </span><br><span class="line">    <span class="string">"BR_ATTEMPT_ACQUIRE"</span>, </span><br><span class="line">    <span class="string">"BR_NOOP"</span>, </span><br><span class="line">    <span class="string">"BR_SPAWN_LOOPER"</span>, </span><br><span class="line">    <span class="string">"BR_FINISHED"</span>, </span><br><span class="line">    <span class="string">"BR_DEAD_BINDER"</span>, </span><br><span class="line">    <span class="string">"BR_CLEAR_DEATH_NOTIFICATION_DONE"</span>, </span><br><span class="line">    <span class="string">"BR_FAILED_REPLY"</span>, </span><br><span class="line">    <span class="string">"BR_TRANSACTION_SEC_CTX"</span>, </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>处理CMD的函数就是waitForResponse和executeCommand。</p>
<p>前面通过writeTransactionData,已经把数据写入到了binder_transaction_data中。<br>talkWithDriver就是调用ioctl(BINDER_WRITE_READ)完成真正的数据接发</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="keyword">bool</span> doReceive)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> 	<span class="comment">//检查打开的binder设备的fd </span></span><br><span class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> -EBADF; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    binder_write_read bwr; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Is the read buffer empty? </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize(); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//需要写的数据大小，这里的doReceive默认为true，如果上一次的数据还没读完，则不会写入任何内容 </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    bwr.write_size = outAvail; </span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>)mOut.data(); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// This is what we'll read. </span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123; </span><br><span class="line"> 		<span class="comment">//将read_size设置为读缓存可用容量 </span></span><br><span class="line">        bwr.read_size = mIn.dataCapacity(); </span><br><span class="line"> 		<span class="comment">//设置读缓存起始地址 </span></span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>)mIn.data(); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        bwr.read_size = <span class="number">0</span>; </span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// Return immediately if there is nothing to do. </span></span><br><span class="line">     <span class="comment">//没有要读写的数据就直接返回 </span></span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR; </span><br><span class="line"> </span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>; </span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">status_t</span> err; </span><br><span class="line">    <span class="comment">//省略异常处理log </span></span><br><span class="line">    <span class="keyword">if</span> (err &gt;= NO_ERROR) &#123; </span><br><span class="line"> 		<span class="comment">//写数据被消费了 </span></span><br><span class="line">        <span class="keyword">if</span> (bwr.write_consumed &gt; <span class="number">0</span>) &#123; </span><br><span class="line">			 <span class="comment">//写数据没有被消费完 </span></span><br><span class="line">            <span class="keyword">if</span> (bwr.write_consumed &lt; mOut.dataSize()) </span><br><span class="line">                LOG_ALWAYS_FATAL(<span class="string">"Driver did not consume write buffer. "</span> </span><br><span class="line">                                 <span class="string">"err: %s consumed: %zu of %zu"</span>, </span><br><span class="line">                                 statusToString(err).c_str(), </span><br><span class="line">                                 (<span class="keyword">size_t</span>)bwr.write_consumed, </span><br><span class="line">                                 mOut.dataSize()); </span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line"> 				<span class="comment">//写数据消费完了，将数据大小设置为0，这样下次就不会再写数据了 </span></span><br><span class="line">                mOut.setDataSize(<span class="number">0</span>); </span><br><span class="line">                processPostWriteDerefs(); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line"> 		<span class="comment">//读到了数据 </span></span><br><span class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123; </span><br><span class="line">			 <span class="comment">//设置数据大小及数据指针偏移，这样后面就可以从中读取出来数据了 </span></span><br><span class="line">            mIn.setDataSize(bwr.read_consumed); </span><br><span class="line">            mIn.setDataPosition(<span class="number">0</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> NO_ERROR; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> err; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
        <category>系统源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统源码</tag>
      </tags>
  </entry>
  <entry>
    <title>MSM8953 7.1预装可卸载第三方应用</title>
    <url>/2021/08/16/MSM8953%207.1%E9%A2%84%E8%A3%85%E5%8F%AF%E5%8D%B8%E8%BD%BD%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h4 id="1、vendor-qcom-proprietary-qrdplus-Extension-config-copy-apps-sh"><a href="#1、vendor-qcom-proprietary-qrdplus-Extension-config-copy-apps-sh" class="headerlink" title="1、vendor/qcom/proprietary/qrdplus/Extension/config/copy_apps.sh"></a>1、vendor/qcom/proprietary/qrdplus/Extension/config/copy_apps.sh</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;system&#x2F;bin&#x2F;sh</span><br><span class="line">if [ ! -f &#x2F;data&#x2F;app&#x2F;did ]; then</span><br><span class="line">	path_pre_install&#x3D;&#x2F;system&#x2F;pre_install</span><br><span class="line">	flist&#x3D;&#96;ls $&#123;path_pre_install&#125;&#96;</span><br><span class="line">	for file in $flist</span><br><span class="line">	do</span><br><span class="line">		echo $&#123;path_pre_install&#125;&#x2F;$file</span><br><span class="line">		pm install -r $&#123;path_pre_install&#125;&#x2F;$file</span><br><span class="line">	done</span><br><span class="line">	echo 1 &gt; &#x2F;data&#x2F;app&#x2F;did</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h4 id="2、同目录下的Android-mk实现把脚本复制到system-bin"><a href="#2、同目录下的Android-mk实现把脚本复制到system-bin" class="headerlink" title="2、同目录下的Android.mk实现把脚本复制到system/bin"></a>2、同目录下的Android.mk实现把脚本复制到system/bin</h4><p>出现的问题，编译不通过，原因分析：<br>system/bin这个目录可能还不存在，先创建，然后cp的时候加个/</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## add by ben for third app</span><br><span class="line">#################################################</span><br><span class="line">COPY_APPS_SH :&#x3D; copy_apps.sh</span><br><span class="line">$(shell mkdir -p $(TARGET_OUT)&#x2F;bin&#x2F;)</span><br><span class="line">$(shell cp -r $(LOCAL_PATH)&#x2F;$(COPY_APPS_SH)  $(TARGET_OUT)&#x2F;bin&#x2F;)</span><br><span class="line">$(shell chmod 755 $(TARGET_OUT)&#x2F;bin&#x2F;$(COPY_APPS_SH))</span><br></pre></td></tr></table></figure>

<h4 id="3、在init-target-rc添加以下服务-路径device-qcom-msm8953-64-init-target-rc"><a href="#3、在init-target-rc添加以下服务-路径device-qcom-msm8953-64-init-target-rc" class="headerlink" title="3、在init.target.rc添加以下服务,路径device/qcom/msm8953_64/init.target.rc"></a>3、在init.target.rc添加以下服务,路径device/qcom/msm8953_64/init.target.rc</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service copy_apps &#x2F;system&#x2F;bin&#x2F;sh &#x2F;system&#x2F;bin&#x2F;copy_apps.sh</span><br><span class="line">    class core</span><br><span class="line">    user root</span><br><span class="line">    group root</span><br><span class="line">    disable #创建但先不执行</span><br><span class="line">    oneshot  #运行一次</span><br><span class="line">    seclabel u:r:copy_apps:s0 #这句是为加selinux权限添加的，android5.1以后不加则无法启动该服务</span><br><span class="line">    </span><br><span class="line">	#必须在开机完成后再启动</span><br><span class="line">on property:sys.boot_completed&#x3D;1</span><br><span class="line">    start copy_apps</span><br></pre></td></tr></table></figure>
<h4 id="4-device-qcom-sepolicy-common-file-contexts-添加如下语句"><a href="#4-device-qcom-sepolicy-common-file-contexts-添加如下语句" class="headerlink" title="4.device/qcom/sepolicy/common/file_contexts 添加如下语句"></a>4.device/qcom/sepolicy/common/file_contexts 添加如下语句</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;system&#x2F;bin&#x2F;copy_apps.sh                      u:object_r:copy_apps_exec:s0</span><br></pre></td></tr></table></figure>
<h4 id="5、添加SELinux规则，device-qcom-sepolicy-common-copy-apps-te"><a href="#5、添加SELinux规则，device-qcom-sepolicy-common-copy-apps-te" class="headerlink" title="5、添加SELinux规则，device/qcom/sepolicy/common/copy_apps.te"></a>5、添加SELinux规则，device/qcom/sepolicy/common/copy_apps.te</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#需要为新增的进程增加域、执行权限</span><br><span class="line">type copy_apps, domain;</span><br><span class="line">type copy_apps_exec, exec_type, file_type;</span><br><span class="line"></span><br><span class="line">#仅用于调试；本进程所需权限均许可，跨进程的要到其他文件设定</span><br><span class="line">#permissive copy_apps; </span><br><span class="line"></span><br><span class="line">#然后启用这个域</span><br><span class="line">init_daemon_domain(copy_apps)</span><br><span class="line"></span><br><span class="line">allow copy_apps rootfs:lnk_file &#123;getattr write open read&#125;;</span><br><span class="line">allow copy_apps apk_data_file:dir &#123;search getattr read write setattr add_name open&#125;;</span><br><span class="line">allow copy_apps apk_data_file:file &#123;getattr open read write create setattr&#125;;</span><br><span class="line">allow copy_apps system_file:dir &#123;read getattr open&#125;;</span><br><span class="line">allow copy_apps system_file:file&#123;read getattr open execute_no_trans &#125;;</span><br><span class="line">allow copy_apps system_data_file:dir &#123;read getattr open write add_name&#125;;</span><br><span class="line">allow copy_apps toolbox_exec:file &#123;getattr execute read open execute_no_trans&#125;;</span><br><span class="line">allow copy_apps copy_apps:capability &#123;dac_override dac_read_search fowner fsetid&#125;;</span><br><span class="line">allow copy_apps copy_apps:file &#123;getattr write open&#125;;</span><br><span class="line">allow copy_apps copy_apps:dir &#123;search&#125;;</span><br><span class="line">allow copy_apps copy_apps:process &#123;execmem&#125;;</span><br><span class="line">allow copy_apps shell_exec:file &#123;entrypoint getattr read execute open execute_no_trans&#125;;</span><br><span class="line">allow copy_apps zygote_exec:file &#123;entrypoint getattr read execute open execute_no_trans&#125;;</span><br><span class="line">allow copy_apps zygote_exec:file &#123;entrypoint getattr read execute open execute_no_trans&#125;;</span><br><span class="line">allow copy_apps servicemanager:binder &#123;call&#125;;</span><br><span class="line">allow copy_apps sysfs:file &#123;read getattr open&#125;;</span><br><span class="line">allow copy_apps dalvikcache_data_file:dir &#123;rw_dir_perms&#125;;</span><br><span class="line">allow copy_apps dalvikcache_data_file:file &#123;create_file_perms&#125;; </span><br><span class="line">allow copy_apps dalvikcache_data_file:lnk_file &#123;read getattr&#125;;</span><br><span class="line">allow copy_apps proc_net:file &#123;read open getattr&#125;;</span><br><span class="line">allow copy_apps ashmem_device:chr_file&#123;execute&#125;;</span><br><span class="line">allow copy_apps copy_apps_tmpfs:file&#123;execute&#125;;</span><br><span class="line">allow copy_apps system_server:binder&#123;call transfer&#125;;</span><br><span class="line">allow copy_apps system_server:fd&#123;use&#125;;</span><br><span class="line">allow copy_apps system_server:unix_stream_socket&#123;getopt read write&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="修改sepolicy后编译出现‘Error-while-expanding-policy’"><a href="#修改sepolicy后编译出现‘Error-while-expanding-policy’" class="headerlink" title="修改sepolicy后编译出现‘Error while expanding policy’"></a>修改sepolicy后编译出现‘Error while expanding policy’</h4><p>在系统中添加某个“*.te”后，可能会出现下面的错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">libsepol.report_failure: neverallow on line 263 of system&#x2F;sepolicy&#x2F;domain.te (or line 9133 of policy.conf) violated by allow xx device:chr_file &#123; read write open &#125;;</span><br><span class="line">    libsepol.check_assertions: 1 neverallow failures occurred</span><br><span class="line">    Error while expanding policy</span><br></pre></td></tr></table></figure>


<p>这是因为在“system/sepolicy/domain.te” 添加了一些neverallow rules，导致编译检查的时候出现错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Do not allow any domain other than init or recovery to create unlabeled files.</span><br><span class="line">    neverallow &#123; domain -init -recovery &#125; unlabeled:dir_file_class_set create;</span><br></pre></td></tr></table></figure>


<p>只需要根据错误的提示，在system/sepolicy/domain.te找到对应的neverallow规则修改即可，我编译出现error的是allow xx device:chr_file { read write open };</p>
<p>只需要在下面的规则中，去掉我们添加的xx.te即可,在neverallow后的第一个‘{}’里 利用“-xx”，排除某个，即不应有此规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Don&#39;t allow raw read&#x2F;write&#x2F;open access to generic devices.</span><br><span class="line">    # Rather force a relabel to a more specific type.</span><br><span class="line">    # init is exempt from this as there are character devices that only it uses.</span><br><span class="line">    # ueventd is exempt from this, as it is managing these devices.</span><br><span class="line">    neverallow &#123; domain -init -ueventd -systool_server -xx &#125; device:chr_file &#123; open read write &#125;;</span><br></pre></td></tr></table></figure>

<p>在编译的时候出现3个位置neverallow的错误，在对应的位置上添加 -copy_apps，<br>下面是其中一个添加位置的地方。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">neverallow &#123;</span><br><span class="line">    domain</span><br><span class="line">    -appdomain</span><br><span class="line">    -autoplay_app</span><br><span class="line">    -dumpstate</span><br><span class="line">    -shell</span><br><span class="line">    userdebug_or_eng(&#96;-su&#39;)</span><br><span class="line">    -system_server</span><br><span class="line">    -zygote</span><br><span class="line">    -copy_apps  </span><br><span class="line">&#125; &#123; file_type -system_file -exec_type -postinstall_file &#125;:file execute;</span><br></pre></td></tr></table></figure>


<p>以上方法最终没有通过，应该是可以的，把上面的问题改一下应该就可以。</p>
<h3 id="最终使用的方法"><a href="#最终使用的方法" class="headerlink" title="最终使用的方法"></a>最终使用的方法</h3><p>这种方法最简单，直接在设备上验证也能通过。主要是设备上没有开启SELinux规则，如果开启，应该也需要上面那种方法的配置。暂时不用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;system&#x2F;etc&#x2F;init&#x2F;目录里的.rc文件里</span><br><span class="line">bootanim.rc</span><br></pre></td></tr></table></figure>
<p>文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service bootanim &#x2F;system&#x2F;bin&#x2F;bootanimation</span><br><span class="line">    class core</span><br><span class="line">    user graphics</span><br><span class="line">    group graphics audio</span><br><span class="line">    disabled</span><br><span class="line">    oneshot</span><br><span class="line">    writepid &#x2F;dev&#x2F;stune&#x2F;top-app&#x2F;tasks</span><br><span class="line"></span><br><span class="line">service copy_apps &#x2F;system&#x2F;bin&#x2F;sh &#x2F;system&#x2F;vendor&#x2F;hq&#x2F;etc&#x2F;copy_apps.sh</span><br><span class="line">    oneshot</span><br><span class="line"></span><br><span class="line">on property:service.bootanim.exit&#x3D;1</span><br><span class="line">   start copy_apps</span><br></pre></td></tr></table></figure>
<p>源码目录在：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frameworks&#x2F;base&#x2F;cmds&#x2F;bootanimation&#x2F;bootanim.rc</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Android消息机制</title>
    <url>/2020/10/04/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="Handler-MessageQueue-Runnable和Looper"><a href="#Handler-MessageQueue-Runnable和Looper" class="headerlink" title="Handler,MessageQueue,Runnable和Looper"></a>Handler,MessageQueue,Runnable和Looper</h3><p>描述：Looper不断的从MessageQueue中获取一个Message，然后由Handler来处理。</p>
<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><ul>
<li>每个Thread只对应一个Looper;</li>
<li>每个Looper只对应一个MessageQueue;</li>
<li>每个MessageQueue中有N个Message;</li>
<li>每个Mesaage最多指定一个Handler来处理事件。</li>
</ul>
<p>可以推出Thread和Handler是一对多关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper mLooper; </span><br><span class="line">    <span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line">    <span class="keyword">final</span> Callback mCallback;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> mAsynchronous;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Handle system messages here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Looper从MessageQueue中取出一个Message后，首先会调用Handler.dispatchMessage进行消息派发，由上面方法可以看出有三种处理情况，</p>
<p>1、Message是通过Runnable发送的，这个Runnable会封装成Message赋值给Message的CallBack，分发消息的时候会先执行这个Runnable;</p>
<p>2、如何Handle以Handler(Callback callback，)这种带有 Callback 的参数初始化会执行这个实现里的handleMessage方法；</p>
<p>最后才执行handle里的handleMessage方法。</p>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          delayMillis = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>延迟多长时间发送，内部通过当前时间+延时时长计算出具体的时间点，然后发送到消息队列。</p>
<p>具体发送到消息队列的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">              IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                      msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">              Log.w(TAG, e.getMessage(), e);</span><br><span class="line">              msg.recycle();</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          msg.markInUse();</span><br><span class="line">          msg.when = when;</span><br><span class="line">          Message p = mMessages;</span><br><span class="line">          <span class="keyword">boolean</span> needWake;</span><br><span class="line">          <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">              <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">              msg.next = p;</span><br><span class="line">              mMessages = msg;</span><br><span class="line">              needWake = mBlocked;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">              <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">              <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">              needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">              Message prev;</span><br><span class="line">              <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                  prev = p;</span><br><span class="line">                  p = p.next;</span><br><span class="line">                  <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                      needWake = <span class="keyword">false</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">              prev.next = msg;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">          <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">              nativeWake(mPtr);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>由上面的方法可以看出，消息队列并不是队列，而是单链表结构。</p>
<h3 id="Looper死循环为什么不会导致应用卡死，会耗费大量资源吗？"><a href="#Looper死循环为什么不会导致应用卡死，会耗费大量资源吗？" class="headerlink" title="Looper死循环为什么不会导致应用卡死，会耗费大量资源吗？"></a>Looper死循环为什么不会导致应用卡死，会耗费大量资源吗？</h3><p>从前面的主线程、子线程的分析可以看出，Looper会在线程中不断的检索消息，如果是子线程的Looper死循环，一旦任务完成，用户应该手动退出，而不是让其一直休眠等待。（引用自Gityuan）线程其实就是一段可执行的代码，当可执行的代码执行完成后，线程的生命周期便该终止了，线程退出。而对于主线程，我们是绝不希望会被运行一段时间，自己就退出，那么如何保证能一直存活呢？简单做法就是可执行代码是能一直执行下去的，死循环便能保证不会被退出，例如，binder 线程也是采用死循环的方法，通过循环方式不同与 Binder 驱动进行读写操作，当然并非简单地死循环，无消息时会休眠。<strong>Android是基于消息处理机制的，用户的行为都在这个Looper循环中，我们在休眠时点击屏幕，便唤醒主线程继续进行工作</strong>。</p>
<p>主线程的死循环一直运行是不是特别消耗 CPU 资源呢？ 其实不然，这里就涉及到 Linux  pipe/epoll机制，简单说就是在主线程的 MessageQueue 没有消息时，便阻塞在 loop 的 queue.next() 中的 nativePollOnce() 方法里，此时主线程会释放 CPU 资源进入休眠状态，直到下个消息到达或者有事务发生，通过往 pipe 管道写端写入数据来唤醒主线程工作。这里采用的 epoll 机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。</p>
<h4 id="epoll机制"><a href="#epoll机制" class="headerlink" title="epoll机制"></a>epoll机制</h4><p>epoll机制在Handler中的应用，在主线程的 MessageQueue 没有消息时，便阻塞在 loop 的 queue.next() 中的 nativePollOnce() 方法里，最终调用到epoll_wait()进行阻塞等待。此时主线程会释放 CPU 资源进入休眠状态，直到下个消息到达或者有事务发生，通过往 pipe 管道写端写入数据来唤醒主线程工作。这里采用的 epoll 机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</span><br><span class="line">    <span class="comment">// sThreadLocal.get() will return null unless you've called prepare().</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal可以实现Looper在线程中的存取，Handler在初始化的时候通过Looper回去Looper中的消息队列。如果不使用，那么系统就必须提供一个全局的哈希表供Handlder查询指定线程的Looper。</p>
<h3 id="Handler的同步屏障机制"><a href="#Handler的同步屏障机制" class="headerlink" title="Handler的同步屏障机制"></a>Handler的同步屏障机制</h3><p>如果有一个紧急的Message需要优先处理，该怎么做？这其实涉及到架构方面的设计了，通用场景和特殊场景的设计。你可能会想到<code>sendMessageAtFrontOfQueue()</code>这个方法，实际也远远不只是如此，<strong>Handler中加入了同步屏障这种机制，来实现[异步消息优先]执行的功能</strong>。</p>
<p>postSyncBarrier()发送同步屏障，removeSyncBarrier()移除同步屏障</p>
<p>同步屏障的作用可以理解成拦截同步消息的执行，主线程的 Looper 会一直循环调用 MessageQueue 的 <code>next()</code> 来取出队头的 Message 执行，当 Message 执行完后再去取下一个。当 <code>next()</code> 方法在取 Message 时发现队头是一个同步屏障的消息时，就会去遍历整个队列，只寻找设置了异步标志的消息，如果有找到异步消息，那么就取出这个异步消息来执行，否则就让 <code>next()</code> 方法陷入阻塞状态。如果 <code>next()</code> 方法陷入阻塞状态，那么主线程此时就是处于空闲状态的，也就是没在干任何事。所以，如果队头是一个同步屏障的消息的话，那么在它后面的所有同步消息就都被拦截住了，直到这个同步屏障消息被移除出队列，否则主线程就一直不会去处理同步屏幕后面的同步消息。</p>
<p>而所有消息默认都是同步消息，只有手动设置了异步标志，这个消息才会是异步消息。另外，同步屏障消息只能由内部来发送，这个接口并没有公开给我们使用。</p>
<p>Choreographer 里所有跟 message 有关的代码，你会发现，<strong>都手动设置了异步消息的标志</strong>，所以这些操作是不受到同步屏障影响的。这样做的原因可能就是为了尽可能保证上层 app 在接收到屏幕刷新信号时，可以在第一时间执行遍历绘制 View 树的工作。</p>
<p>Choreographer 过程中的动作也都是异步消息，这样可以确保 Choreographer 的顺利运转，也确保了第一时间执行 doTraversal（doTraversal → performTraversals 就是执行 view 的 layout、measure、draw），这个过程中如果有其他同步消息，也无法得到处理，都要等到 doTraversal 之后。</p>
<p>因为主线程中如果有太多消息要执行，而这些消息又是根据时间戳进行排序，如果不加一个同步屏障的话，那么遍历绘制 View 树的工作就可能被迫延迟执行，因为它也需要排队，那么就有可能出现当一帧都快结束的时候才开始计算屏幕数据，那即使这次的计算少于 16.6ms，也同样会造成丢帧现象。</p>
<p>那么，<strong>有了同步屏障消息的控制就能保证每次一接收到屏幕刷新信号就第一时间处理遍历绘制 View 树的工作么？</strong></p>
<p>只能说，同步屏障是尽可能去做到，但并不能保证一定可以第一时间处理。因为，同步屏障是在 <code>scheduleTraversals()</code> 被调用时才发送到消息队列里的，也就是说，只有当某个 View 发起了刷新请求时，在这个时刻后面的同步消息才会被拦截掉。如果在 <code>scheduleTraversals()</code> 之前就发送到消息队列里的工作仍然会按顺序依次被取出来执行。</p>
<p><a href="https://juejin.cn/post/6893791473121280013" target="_blank" rel="noopener">https://juejin.cn/post/6893791473121280013</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统源码</tag>
      </tags>
  </entry>
  <entry>
    <title>android应用程序访问I2C接口</title>
    <url>/2020/09/11/android%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BF%E9%97%AEI2C%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>I2C总线是一种简单、双向二线制同步串行总线。它只需要两根线即可在连接于总线上的器件之间传送信息。<br>主器件用于启动总线传送数据，并产生时钟以开放传送的器件，此时任何被寻址的器件均被认为是从器件．在总线上主和从、发和收的关系不是恒定的，而取决于此时数据传送方向。如果主机要发送数据给从器件，则主机首先寻址从器件，然后主动发送数据至从器件，最后由主机终止数据传送；如果主机要接收从器件的数据，首先由主器件寻址从器件．然后主机接收从器件发送的数据，最后由主机终止接收过程。在这种情况下．主机负责产生定时时钟和终止数据传送。</p>
<p>Java code</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> xxxxxxx.xx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">I2cRadioTest</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"I2cRadioTest"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Called when the activity is first created. */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">int</span>[] buf = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">int</span> slaveAddr = <span class="number">0</span>xXX;</span><br><span class="line">        <span class="keyword">int</span> fileHander;</span><br><span class="line">        <span class="keyword">int</span> mode = <span class="number">0</span>xXX | <span class="number">0</span>xXX;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        I2c i2c = <span class="keyword">new</span> I2c();</span><br><span class="line">        fileHander = i2c.open(<span class="string">"/dev/i2c-1"</span>);</span><br><span class="line"></span><br><span class="line">        i2c.read(fileHander, slaveAddr, buf, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        Log.w(TAG,</span><br><span class="line">                <span class="string">"buf0= "</span> + Integer.toHexString(buf[<span class="number">0</span>]) + <span class="string">" buf1= "</span></span><br><span class="line">                        + Integer.toHexString(buf[<span class="number">1</span>]) + <span class="string">" buf2= "</span></span><br><span class="line">                        + Integer.toHexString(buf[<span class="number">2</span>]) + <span class="string">" buf=3 "</span></span><br><span class="line">                        + Integer.toHexString(buf[<span class="number">3</span>]));</span><br><span class="line"></span><br><span class="line">        buf[<span class="number">0</span>] = <span class="number">0x01</span>;</span><br><span class="line">        i = <span class="number">0</span>;<span class="comment">// i2c.write(fileHander, slaveAddr, mode, buf, 1);</span></span><br><span class="line">        Log.w(TAG, <span class="string">"write length "</span> + i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            buf[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i2c.read(fileHander, slaveAddr, buf, <span class="number">4</span>);</span><br><span class="line">        Log.w(TAG,</span><br><span class="line">                <span class="string">"buf0= "</span> + Integer.toHexString(buf[<span class="number">0</span>]) + <span class="string">" buf1= "</span></span><br><span class="line">                        + Integer.toHexString(buf[<span class="number">1</span>]) + <span class="string">" buf2= "</span></span><br><span class="line">                        + Integer.toHexString(buf[<span class="number">2</span>]) + <span class="string">" buf=3 "</span></span><br><span class="line">                        + Integer.toHexString(buf[<span class="number">3</span>]));</span><br><span class="line"></span><br><span class="line">        i2c.close(fileHander);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((buf[<span class="number">0</span>] &amp; <span class="number">0x10</span>) == <span class="number">0x01</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"------success-----"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"----fail-------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setContentView(R.layout.main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> xxxxxx.xxx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is a I2C operation class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">I2c</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nodeName</span></span><br><span class="line"><span class="comment">     *            node path name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> return file hander else return &lt;0 on fail</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">open</span><span class="params">(String nodeName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileHander</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i2c_adr</span></span><br><span class="line"><span class="comment">     *            slave addr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Lenth</span></span><br><span class="line"><span class="comment">     *            of buf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> read length</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fileHander, <span class="keyword">int</span> i2c_adr, <span class="keyword">int</span> buf[], <span class="keyword">int</span> Length)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileHander</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i2c_adr</span></span><br><span class="line"><span class="comment">     *            slave addr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sub_adr</span></span><br><span class="line"><span class="comment">     *            sub addr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Lenth</span></span><br><span class="line"><span class="comment">     *            of buf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> write length</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fileHander, <span class="keyword">int</span> i2c_adr, <span class="keyword">int</span> sub_adr,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> buf[], <span class="keyword">int</span> Length)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fileHander)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"test-i2c"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C/C++ code</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class xxxxxx_xxx_I2c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_xxxxxx_xxx_I2c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_xxxxxx_xxx_I2c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     xxxxxx_xxx_I2c</span></span><br><span class="line"><span class="comment"> * Method:    open</span></span><br><span class="line"><span class="comment"> * Signature: (Ljava/lang/String;)I</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jint JNICALL Java_xxxxxx_xxx_I2c_open</span><br><span class="line">  (JNIEnv *, jobject, jstring);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     xxxxxx_xxx_I2c</span></span><br><span class="line"><span class="comment"> * Method:    read</span></span><br><span class="line"><span class="comment"> * Signature: (II[II)I</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jint JNICALL Java_xxxxxx_xxx_I2c_read</span><br><span class="line">  (JNIEnv *, jobject, jint, jint, jintArray, jint);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     xxxxxx_xxx_I2c</span></span><br><span class="line"><span class="comment"> * Method:    write</span></span><br><span class="line"><span class="comment"> * Signature: (III[II)I</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jint JNICALL Java_xxxxxx_xxx_I2c_write</span><br><span class="line">  (JNIEnv *, jobject, jint, jint, jint, jintArray, jint);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     xxxxxx_xxx_I2c</span></span><br><span class="line"><span class="comment"> * Method:    close</span></span><br><span class="line"><span class="comment"> * Signature: (I)V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_xxxxxx_xxx_I2c_close</span><br><span class="line">  (JNIEnv *, jobject, jint);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test-i2c.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LOG_TAG    <span class="meta-string">"i2c"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LOGI(...)  __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LOGE(...)  __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL Java_xxxxxx_xxx_I2c_open</span><br><span class="line">  (JNIEnv *env, jobject obj, jstring file)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">char</span> fileName[<span class="number">64</span>];</span><br><span class="line">      <span class="keyword">const</span> jbyte *str;</span><br><span class="line">      </span><br><span class="line">      str = (*env)-&gt;GetStringUTFChars(env, file, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">if</span> (str == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          LOGI(<span class="string">"Can't get file name!"</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">sprintf</span>(fileName, <span class="string">"%s"</span>, str);</span><br><span class="line">    LOGI(<span class="string">"will open i2c device node %s"</span>, fileName);</span><br><span class="line">      (*env)-&gt;ReleaseStringUTFChars(env, file, str);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">open</span>(fileName, O_RDWR);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">JNIEXPORT jint JNICALL Java_xxxxxx_xxx_I2c_read</span><br><span class="line">  (JNIEnv * env, jobject obj, jint fileHander, jint slaveAddr, jintArray bufArr, jint len)</span><br><span class="line">  &#123;</span><br><span class="line">      jint *bufInt;</span><br><span class="line">      <span class="keyword">char</span> *bufByte;</span><br><span class="line">      <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          LOGE(<span class="string">"I2C: buf len &lt;=0"</span>);</span><br><span class="line">          <span class="keyword">goto</span> err0;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      bufInt = (jint *) <span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">      <span class="keyword">if</span> (bufInt == <span class="number">0</span>) &#123;</span><br><span class="line">          LOGE(<span class="string">"I2C: nomem"</span>);</span><br><span class="line">          <span class="keyword">goto</span> err0;</span><br><span class="line">      &#125;</span><br><span class="line">      bufByte = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(len);</span><br><span class="line">      <span class="keyword">if</span> (bufByte == <span class="number">0</span>) &#123;</span><br><span class="line">          LOGE(<span class="string">"I2C: nomem"</span>);</span><br><span class="line">          <span class="keyword">goto</span> err1;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      (*env)-&gt;GetIntArrayRegion(env, bufArr, <span class="number">0</span>, len, bufInt);</span><br><span class="line">      </span><br><span class="line">      res = ioctl(fileHander, I2C_SLAVE, slaveAddr);</span><br><span class="line">      <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">          LOGE(<span class="string">"I2C: Can't set slave address"</span>);</span><br><span class="line">          <span class="keyword">goto</span> err2;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">memset</span>(bufByte, <span class="string">'\0'</span>, len);</span><br><span class="line">      <span class="keyword">if</span> ((j = <span class="built_in">read</span>(fileHander, bufByte, len)) != len) &#123;</span><br><span class="line">        LOGE(<span class="string">"read fail in i2c read jni i = %d buf 4"</span>, i);</span><br><span class="line">        <span class="keyword">goto</span> err2;        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; j ; i++)</span><br><span class="line">            bufInt[i] = bufByte[i];</span><br><span class="line">        LOGI(<span class="string">"return %d %d %d %d in i2c read jni"</span>, bufByte[<span class="number">0</span>], bufByte[<span class="number">1</span>], bufByte[<span class="number">2</span>], bufByte[<span class="number">3</span>]);</span><br><span class="line">        (*env)-&gt;SetIntArrayRegion(env, bufArr, <span class="number">0</span>, len, bufInt);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(bufByte);</span><br><span class="line">    <span class="built_in">free</span>(bufInt);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line"></span><br><span class="line">err2:</span><br><span class="line">    <span class="built_in">free</span>(bufByte);</span><br><span class="line">err1:</span><br><span class="line">    <span class="built_in">free</span>(bufInt);</span><br><span class="line">err0:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;                                          </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">JNIEXPORT jint JNICALL Java_xxxxxx_xxx_I2c_write</span><br><span class="line">  (JNIEnv *env, jobject obj, jint fileHander, jint slaveAddr, jint mode,</span><br><span class="line">   jintArray bufArr, jint len)</span><br><span class="line">  &#123;</span><br><span class="line">      jint *bufInt;</span><br><span class="line">      <span class="keyword">char</span> *bufByte;</span><br><span class="line">      <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          LOGE(<span class="string">"I2C: buf len &lt;=0"</span>);</span><br><span class="line">          <span class="keyword">goto</span> err0;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      bufInt = (jint *) <span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">      <span class="keyword">if</span> (bufInt == <span class="number">0</span>) &#123;</span><br><span class="line">          LOGE(<span class="string">"I2C: nomem"</span>);</span><br><span class="line">          <span class="keyword">goto</span> err0;</span><br><span class="line">      &#125;</span><br><span class="line">      bufByte = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(len + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (bufByte == <span class="number">0</span>) &#123;</span><br><span class="line">          LOGE(<span class="string">"I2C: nomem"</span>);</span><br><span class="line">          <span class="keyword">goto</span> err1;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      (*env)-&gt;GetIntArrayRegion(env, bufArr, <span class="number">0</span>, len, bufInt);</span><br><span class="line">      bufByte[<span class="number">0</span>] = mode;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">          bufByte[i + <span class="number">1</span>] = bufInt[i];      </span><br><span class="line">      </span><br><span class="line">      res = ioctl(fileHander, I2C_SLAVE, slaveAddr);</span><br><span class="line">      <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">          LOGE(<span class="string">"I2C: Can't set slave address"</span>);</span><br><span class="line">          <span class="keyword">goto</span> err2;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> ((j = <span class="built_in">write</span>(fileHander, bufByte, len + <span class="number">1</span>)) != len + <span class="number">1</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"write fail in i2c"</span>);</span><br><span class="line">        <span class="keyword">goto</span> err2;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LOGI(<span class="string">"I2C: write %d byte"</span>, j);</span><br><span class="line">    <span class="built_in">free</span>(bufByte);</span><br><span class="line">    <span class="built_in">free</span>(bufInt);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> j - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">err2:</span><br><span class="line">    <span class="built_in">free</span>(bufByte);</span><br><span class="line">err1:</span><br><span class="line">    <span class="built_in">free</span>(bufInt);</span><br><span class="line">err0:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;     </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_xxxxxx_xxx_I2c_close</span><br><span class="line">  (JNIEnv *env, jobject obj, jint fileHander)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">close</span>(fileHander);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.jianshu.com/p/02dc4bb83c95" target="_blank" rel="noopener">https://www.jianshu.com/p/02dc4bb83c95</a> </p>
]]></content>
      <categories>
        <category>Android</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>jni无法访问so提示not accessible</title>
    <url>/2020/09/04/JNI%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AEso%E6%8F%90%E7%A4%BAnot%20accessible/</url>
    <content><![CDATA[<p>问题：app需要引用系统的so库，当install形式的时候安装时，打开app需要使用/system/lib64目录下的so库时，提示不能访问。<br>原因分析：放到system/app下的app是可以找到的，但是普通的安装形式的app是没有权限访问的，所以需要需要声明公有so库才能使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">library &quot;&#x2F;system&#x2F;lib64&#x2F;libserialport.so&quot; (&quot;&#x2F;system&#x2F;lib64&#x2F;libhqbindcs.so&quot;) needed or</span><br><span class="line">dlopened by&quot;&#x2F;system&#x2F;lib64&#x2F;libhqbindcs.so&quot; is not accessible for the namespace</span><br><span class="line">&quot;classloader-namespace&quot;</span><br></pre></td></tr></table></figure>
<p>解决方法：<br>修改system/core/rootdir/etc/public.libraries.txt<br>添加你要使用的的so到此问题件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat public.libraries.txt </span><br><span class="line">....</span><br><span class="line">libz.so</span><br><span class="line">libhqbindcs.so</span><br></pre></td></tr></table></figure>

<p>也可以直接不编译在板子上修改，对应目录/system/etc  </p>
<p>参考：<br>Framework基础：Android N 公共so库怎么定义呢？<br><a href="https://www.jianshu.com/p/4be3d1dafbec" target="_blank" rel="noopener">https://www.jianshu.com/p/4be3d1dafbec</a></p>
<p>[Google]原生库的命名空间<br><a href="https://source.android.com/devices/tech/config/namespaces_libraries" target="_blank" rel="noopener">https://source.android.com/devices/tech/config/namespaces_libraries</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统源码</tag>
      </tags>
  </entry>
  <entry>
    <title>system.img打包出错设备上没有空间</title>
    <url>/2020/06/14/system-img%E6%89%93%E5%8C%85%E5%87%BA%E9%94%99%E8%AE%BE%E5%A4%87%E4%B8%8A%E6%B2%A1%E6%9C%89%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<p>在打system.img的时候提示出错: 设备上没有空间</p>
<p>在现有android系统时，用adb工具把程序放入系统中</p>
<p>cmd </p>
<p>cd 到adb的目录下</p>
<p>adb push xxx.xml etc/</p>
<p>当我们要制作系统镜像时，可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir system</span><br><span class="line"></span><br><span class="line">sudo mount -o loop system.img system</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cp -rf xxx.xml system&#x2F;etc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo umount system</span><br></pre></td></tr></table></figure>




<p>执行cp时候，提示设备上没有空间，这时候，可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install e2fsprogs</span><br><span class="line"></span><br><span class="line">e2fsck -f system.img</span><br><span class="line">resize2fs system.img 1000M</span><br><span class="line">sudo mount -o loop system.img system</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cp xxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo umount system</span><br><span class="line">e2fsck -f system.img</span><br><span class="line">resize2fs -M system.img</span><br></pre></td></tr></table></figure>
<p>最后需要修改内存分配配置。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统源码</tag>
      </tags>
  </entry>
  <entry>
    <title>System.img的查看-处理</title>
    <url>/2020/06/04/System-img%E7%9A%84%E6%9F%A5%E7%9C%8B-%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>在服务器上编译完源码之后，有时候需要想要查看打出img的内容是不是自己想要的，比如说添加了一个新的apk文件，如果重新烧写到手机会浪费很多时间，想在服务器上直接查看，可以参考如下方法。<br><a href="https://blog.csdn.net/sir_zeng/article/details/51983432" target="_blank" rel="noopener">System.img的查看/处理</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file out&#x2F;target&#x2F;product&#x2F;px3&#x2F;system.img</span><br><span class="line"></span><br><span class="line">out&#x2F;host&#x2F;linux-x86&#x2F;bin&#x2F;simg2img out&#x2F;target&#x2F;product&#x2F;px3&#x2F;system.img system.img</span><br><span class="line">file system.img</span><br><span class="line">sudo mount -o loop system.img &#x2F;mnt</span><br><span class="line">ls -lh &#x2F;mnt&#x2F;</span><br></pre></td></tr></table></figure>
<p>解包system.img<br>simg2img<br>simg2img用于把压缩过/hash过的img文件还原为raw的img文件<br>它通常在编译输出的out/host/linux-x86/bin/simg2img中<br>查询原始system.img文件类型,可以看到是data  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file out&#x2F;target&#x2F;product&#x2F;msm8909&#x2F;system.img</span><br><span class="line">out&#x2F;target&#x2F;product&#x2F;msm8909&#x2F;system.img: data</span><br><span class="line">转换命令如下</span><br><span class="line"></span><br><span class="line">Usage: simg2img &lt;sparse_image_files&gt; &lt;raw_image_file&gt;</span><br><span class="line">out&#x2F;host&#x2F;linux-x86&#x2F;bin&#x2F;simg2img out&#x2F;target&#x2F;product&#x2F;msm8909&#x2F;system.img out&#x2F;target&#x2F;product&#x2F;msm8909&#x2F;systemraw.img</span><br></pre></td></tr></table></figure>

<p>查询下转换后的systemraw.img文件类型  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file out&#x2F;target&#x2F;product&#x2F;msm8909&#x2F;systemraw.img</span><br><span class="line">out&#x2F;target&#x2F;product&#x2F;msm8909&#x2F;systemraw.img: Linux rev 1.0 ext4 filesystem data, UUID&#x3D;57f8f4bc-abf4-655f-bf67-946fc0f9f25b (extents) (large files)</span><br></pre></td></tr></table></figure>

<p>[编辑] mount systemraw.img<br>这个systemraw.img就可以任意我们处理了,最好的处理方法是直接mount它,然后进去看/处理内容,如果直接解开,很容易丢失了软链接,甚至会到是selinux的权限错乱</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir aaa</span><br><span class="line">sudo mount -t ext4 -o loop out&#x2F;target&#x2F;product&#x2F;msm8909&#x2F;systemraw.img aaa</span><br></pre></td></tr></table></figure>

<p>[编辑] 处理mount的img<br>[编辑] 查看占用的空间<br>df -h<br>输出类似  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">&#x2F;dev&#x2F;loop0      2.0G  450M  1.5G  23% &#x2F;media&#x2F;work_r&#x2F;szgit&#x2F;8909&#x2F;LINUX&#x2F;android&#x2F;aaa</span><br></pre></td></tr></table></figure>

<p>[编辑] 其他处理<br>其他的诸如 chmod rm cp mv   chown想怎样就可以怎样了,随便修改  </p>
<p>[编辑] 保存处理mount的img<br>umount就ok,自动保存了  </p>
<p>sudo umount aaa<br>[编辑] 打包为system.img<br>[编辑] img2simg<br>img2simg用于把img文件打包<br>它通常在编译输出的out/host/linux-x86/bin/img2simg中<br>转换命令如下  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: img2simg &lt;raw_image_file&gt; &lt;sparse_image_file&gt; [&lt;block_size&gt;]</span><br><span class="line">out&#x2F;host&#x2F;linux-x86&#x2F;bin&#x2F;img2simg out&#x2F;target&#x2F;product&#x2F;msm8909&#x2F;systemraw.img out&#x2F;target&#x2F;product&#x2F;msm8909&#x2F;system.img</span><br></pre></td></tr></table></figure>

<p>转换出来 system.img和之前编译的没有啥区别,直接用fastboot就可以刷机  </p>
<p>[编辑] 其他<br>如果你找不到img2simg/simg2img,自己编译下,或者从其他项目中copy过来  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mmma system&#x2F;core&#x2F;libsparse&#x2F;   </span><br><span class="line">或者  </span><br><span class="line">mmm system&#x2F;core&#x2F;libsparse&#x2F;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统源码</tag>
      </tags>
  </entry>
  <entry>
    <title>编译插桩操纵字节码</title>
    <url>/2020/04/13/%E7%BC%96%E8%AF%91%E6%8F%92%E6%A1%A9%E6%93%8D%E7%BA%B5%E5%AD%97%E8%8A%82%E7%A0%81/</url>
    <content><![CDATA[<h4 id="编译插桩是什么"><a href="#编译插桩是什么" class="headerlink" title="编译插桩是什么"></a>编译插桩是什么</h4><p>编译插桩就是在代码编译期间修改已有的代码或者生成新代码。Dagger、ButterKnife甚至是Kotlin语言，它们都用到了编译插桩的技术。</p>
<p>具体实现有如下两种方式：</p>
<ol>
<li>在.java文件编译成.class文件时，APT、AndroidAnnotation等就是在此处触发代码生成。</li>
<li>在 .class 文件进一步优化成 .dex 文件时，也就是直接操作字节码文件，这种方式功能更加强大，应用场景也更多。但是门槛比较高，需要对字节码有一定的理解。具体处理如下图：</li>
</ol>
<p><img src="https://s0.lgstatic.com/i/image3/M01/81/65/Cgq2xl6FrD2ABAAgAACZzFsVdz4155.png" alt=""></p>
<p>一般情况下，我们经常会使用编译插桩实现如下几种功能：</p>
<ul>
<li><p>日志埋点；</p>
</li>
<li><p>性能监控；</p>
</li>
<li><p>动态权限控制；</p>
</li>
<li><p>业务逻辑跳转时，校验是否已经登录；</p>
</li>
<li><p>甚至是代码调试等。</p>
</li>
</ul>
<h4 id="插桩工具介绍"><a href="#插桩工具介绍" class="headerlink" title="插桩工具介绍"></a>插桩工具介绍</h4><p>目前市面上主要流行两种实现编译插桩的方式：</p>
<h5 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h5><p>AspectJ是老牌AOP（Aspect-OrientedProgramming）框架，，如果你做过 J2EE 开发可能对这个框架更加熟悉，经常会拿这个框架跟 Spring AOP 进行比较。其主要优势是成熟稳定，使用者也不需要对字节码文件有深入的理解。</p>
<h5 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h5><p>目前另一种编译插桩的方式ASM越来越受到广大工程师的喜爱。通过ASM可以修改现有的字节码文件，也可以动态生成字节码文件，并且它是一款完全以字节码层面来操纵字节码并分析字节码的框架。</p>
<hr>
<p>下面介绍使用 ASM 来实现简单的编译插桩效果，通过插桩实现课时开始讲的需求，在每一个 Activity 打开时输出相应的 log 日志。</p>
<h4 id="使用-ASM"><a href="#使用-ASM" class="headerlink" title="使用 ASM"></a>使用 ASM</h4><h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h5><p>过程主要包含两步：</p>
<ol>
<li><strong>找到项目中编译生成的所有.class文件</strong></li>
</ol>
<p>AndroidStudio使用Gradle编译项目中的.java文件，并且从Gradle1.5.0之后，我们可以自己定义Transform，来获取所有.class文件引用。</p>
<p>但是Transform的使用需要依赖GradlePlugin。因此我们第一步需要创建一个单独的GradlePlugin，并在 Gradle Plugin 中使用自定义 Transform 找出所有的 .class 文件。遍历到目标.class文件（Activity）之后，</p>
<p>2.<strong>通过ASM动态注入需要被插入的字节码</strong></p>
<p>如果第一步进行顺利，我们可以找出所有的.class文件。接下来就需要过滤出目标 Activity 文件，并在目标 Activity 文件的 onCreate 方法中，通过 ASM 插入相应的 log 日志字节码。</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>1、<strong>创建 ASMLifeCycleDemo 项目</strong></p>
<p>创建主项目 ASMLifeCycleDemo，当前项目中只有一个 MainActivity；</p>
<p>2、<strong>创建自定义Gradle插件</strong></p>
<p>2.1、首先在ASMLifeCycleDemo项目中创建一个新的module，并选择AndroidLibrary类型，命名为asm_lifecycle_plugin。将asm_lifecycle_pluginmodule中除了build.gradle和main文件夹之外的所有内容都删除。然后在 main 目录下分别创建 groovy 和 java 目录；</p>
<p>因为Gradle插件是使用groovy语言编写的，所以需要新建一个groovy目录，用来存放插件相关的.groovy类。但ASM是java层面的框架，所以在 java 目录里存放 ASM 相关的类。</p>
<p>2.2、然后，在groovy中创建目录danny.jiang.plugin，并在此目录中创建类LifeCyclePlugin.groovy文件。在LifeCyclePlugin中重写 apply 方法，实现插件逻辑，因为是 demo 演示，所以我只是简单的打印 log 日志。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hopechart.plugin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.android.build.gradle.external.cmake.server.Project</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Plugin</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeCyclePlugin</span>  <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">        System.out.println(<span class="string">"==LifeCyclePlugin gradle plugin=="</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看出LifeCyclePlugin实现了gradleapi中的Plugin接口。当我们在appmodule的build.gradle文件中使用此插件时，其LifeCyclePlugin的apply方法将会被自动调用。</p>
<p>2.3、接下来，将asm_lifecycle_pluginmodule的build.gradle中的内容全部删掉，改为如下内容：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'groovy'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'maven'</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(<span class="string">dir:</span> <span class="string">'libs'</span>, <span class="string">include:</span> [<span class="string">'*.jar'</span>])</span><br><span class="line"></span><br><span class="line">    compile  gradleApi()</span><br><span class="line">    compile  localGroovy()</span><br><span class="line"></span><br><span class="line">    compile  <span class="string">'com.android.tools.build:gradle:3.6.2'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ASM相关依赖</span></span><br><span class="line">    implementation <span class="string">'org.ow2.asm:asm:7.1'</span></span><br><span class="line">    implementation <span class="string">'org.ow2.asm:asm-commons:7.1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group=<span class="string">'com.hopechart.plugin'</span></span><br><span class="line">version=<span class="string">'1.0.0'</span></span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            <span class="comment">//本地的Maven地址设置</span></span><br><span class="line">            repository(<span class="string">url:</span> uri(<span class="string">'../asm_lifecycle_repo'</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>group和version都需要在appmodule引用此插件时使用。所有的插件都需要被部署到maven库中，我们可以选择部署到远程或者本地。这里只是演示，所以只是将插件部署到本地目录中。具体地址通过 repository 属性配置，如图所示我将其配置在项目根目录下的 asm_lifecycle_repo 目录下。</p>
<p>2.4、最后一步，创建properties文件。在plugin/src/main目录下新建目录resources/META-INF/gradle-plguins，然后在此目录下新建一个文件：danny.asm.lifecycle.properties，其中文件名 danny.asm.lifecycle 就是我们自定义插件的名称，稍后我们在 app module 中会使用到此名称。配置文件内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation-class&#x3D;com.hopechart.plugin.LifeCyclePlugin</span><br></pre></td></tr></table></figure>

<p>在 .properties 文件中，需要指定我们自定义的插件类名 LifeCyclePlugin，</p>
<p>2.5、至此，自定义 Gradle 插件就已经写完，现在可以在 Android Studio 的右边栏找到 Gradle 中点击 uploadArchives，执行 plugin 的部署任务;</p>
<p>2.6、构建成功之后，在 Project 的根目录下将会出现一个 asm_lifecycle_repo目录，里面存放的就是我们的插件目标文件。</p>
<h4 id="测试-asm-lifecycle-plugin"><a href="#测试-asm-lifecycle-plugin" class="headerlink" title="测试 asm_lifecycle_plugin"></a>测试 asm_lifecycle_plugin</h4><p>为了测试自定义的 Gradle 插件是否可用，可以在 app module 中的 build.gradle 中引用此插件。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></span><br><span class="line"><span class="comment">// add start</span></span><br><span class="line"><span class="comment">//自定义 Gradle 插件中 properties 的文件名</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'danny.asm.lifecycle'</span></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        <span class="comment">//自定义插件maven地址</span></span><br><span class="line">        maven &#123; url <span class="string">'../asm_lifecycle_repo'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        <span class="comment">//加载自定义插件 group + module + version</span></span><br><span class="line">        classpath <span class="string">'com.hopechart.plugin:asm_lifecycle_plugin:1.0.0'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// add end</span></span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在命令行中使用 gradlew 执行构建命令，如果打印出我们自定义插件里的 log，则说明自定义 Gradle 插件可以使用</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>GC回收机制与分代回收策略</title>
    <url>/2020/04/04/GC%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>堆和方法区考虑回收的问题，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的就是这部分内存。</p>
<h4 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h4><p>所谓垃圾就是内存中已经没有用的对象。 既然是”垃圾回收”，那就必须知道哪些对象是垃圾。Java 虚拟机中使用一种叫作”<strong>可达性分析</strong>”的算法来决定对象是否可以被回收。<strong>可达性分析</strong>通过一组名为”GC Root”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，最后通过判断对象的引用链是否可达来决定对象是否可以被回收。</p>
<h4 id="GCRoot对象"><a href="#GCRoot对象" class="headerlink" title="GCRoot对象"></a>GCRoot对象</h4><p>在Java中，有以下几种对象可以作为GCRoot：</p>
<ol>
<li>Java虚拟机栈（局部变量表）中的引用的对象;</li>
<li>方法区中静态引用指向的对象;</li>
<li>仍处于存活状态中的线程对象;</li>
<li>Native 方法中 JNI 引用的对象。</li>
</ol>
<h4 id="什么时候回收"><a href="#什么时候回收" class="headerlink" title="什么时候回收"></a>什么时候回收</h4><p>不同的虚拟机实现有着不同的GC实现机制，但是一般情况下每一种GC实现都会在以下两种情况下触发垃圾回收。</p>
<ol>
<li><p>AllocationFailure：在堆内存中分配时，如果因为可用剩余空间不足导致对象内存分配失败，这时系统会触发一次GC。</p>
</li>
<li><p>System.gc()：在应用层，Java 开发工程师可以主动调用此 API 来请求一次 GC。</p>
<h4 id="JVM分代回收策略"><a href="#JVM分代回收策略" class="headerlink" title="JVM分代回收策略"></a>JVM分代回收策略</h4><p>Java虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为<strong>新生代、老年代</strong>，这就是JVM的内存分代策略。<strong>注意:在HotSpot中除了新生代和老年代，还有永久代</strong>。</p>
<p>分代回收的中心思想就是：对于新创建的对象会在新生代中分配内存，此区域的对象生命周期一般较短。如果经过多次回收仍然存活下来，则将它们转移到老年代中。</p>
<h5 id="年轻代（YoungGeneration）"><a href="#年轻代（YoungGeneration）" class="headerlink" title="年轻代（YoungGeneration）"></a>年轻代（YoungGeneration）</h5><p>新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低，在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，回收效率很高。新生代中因为要进行一些复制操作，所以一般采用的 GC 回收算法是复制算法。</p>
<p>新生代又可以继续细分为 3 部分：Eden、Survivor0（简称 S0）、Survivor1（简称S1）。这 3 部分按照 8:1:1 的比例来划分新生代。这 3 块区域的内存分配过程如下:</p>
<ol>
<li><p>绝大多数刚刚被创建的对象会存放在 Eden区。当 Eden 区第一次满的时候，会进行垃圾回收。首先将 Eden 区的垃圾对象回收清除，并将存活的对象复制到 S0，此时 S1 是空的。</p>
</li>
<li><p>下一次 Eden 区满时，再执行一次垃圾回收。此次会将 Eden 和 S0 区中所有垃圾对象清除，并将存活对象复制到 S1，此时 S0 变为空。</p>
</li>
<li><p>如此反复在 S0 和 S1之间切换几次（默认 15 次）之后，如果还有存活对象。说明这些对象的生命周期较长，则将它们转移到老年代中。</p>
<h4 id="年老代（OldGeneration）"><a href="#年老代（OldGeneration）" class="headerlink" title="年老代（OldGeneration）"></a>年老代（OldGeneration）</h4><p>一个对象如果在新生代存活了足够长的时间而没有被清理掉，则会被复制到老年代。老年代的内存大小一般比新生代大，能存放更多的对象。如果对象比较大（比如长字符串或者大数组），并且新生代的剩余空间不足，则这个大对象会直接被分配到老年代上。</p>
<p>注意：对于老年代可能存在这么一种情况，老年代中的对象有时候会引用到新生代对象。这时如果要执行新生代GC，则可能需要查询整个老年代上可能存在引用新生代的情况，这显然是低效的。所以，老年代中维护了一个 512 byte 的 card table，所有老年代对象引用新生代对象的信息都记录在这里。每当新生代发生 GC 时，只需要检查这个 card table 即可，大大提高了性能。 </p>
<h4 id="GCLog分析"><a href="#GCLog分析" class="headerlink" title="GCLog分析"></a>GCLog分析</h4><p>为了让上层应用开发人员更加方便的调试Java程序，JVM提供了相应的GC日志。在GC执行垃圾回收事件的过程中，会有各种相应的log被打印出来。其中新生代和老年代所打印的日志是有区别的。</p>
<p>新生代GC：这一区域的GC叫作MinorGC。因为Java对象大多都具备朝生夕灭的特性，所以MinorGC非常频繁，一般回收速度也比较快。</p>
<p>老年代 GC：发生在这一区域的 GC 也叫作 Major GC 或者 Full GC。当出现了 Major GC，经常会伴随至少一次的 Minor GC。</p>
<p>注意：在有些虚拟机实现中，Major GC 和 Full GC 还是有一些区别的。Major GC 只是代表回收老年代的内存，而 Full GC 则代表回收整个堆中的内存，也就是新生代 + 老年代。 </p>
<h4 id="Java-命令的参数"><a href="#Java-命令的参数" class="headerlink" title="Java 命令的参数"></a>Java 命令的参数</h4><p><img src="https://s0.lgstatic.com/i/image3/M01/7C/9B/Cgq2xl58lmeAAsp5AABwifdCuEw841.png" alt=""></p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>判断对象是否存活我们是通过GCRoots的引用可达性来判断的。但是JVM中的引用关系并不止一种，而是有四种，根据引用强度的由强到弱，他们分别是:<strong>强引用(StrongReference)、软引用(SoftReference)、弱引用(Weak Reference)、虚引用(Phantom Reference)</strong>。</p>
<p>四种引用做简单对比</p>
<p><img src="https://s0.lgstatic.com/i/image3/M01/03/85/Ciqah158ltqAHyEHAACoLz2II_g092.png" alt=""></p>
</li>
</ol>
</li>
</ol>
<p>平时项目中，尤其是Android项目，因为有大量的图像(Bitmap)对象，使用软引用的场景较多。所以重点看下软引用SoftReference的使用，不当的使用软引用有时也会导致系统异常。</p>
<h5 id="软引用隐藏问题"><a href="#软引用隐藏问题" class="headerlink" title="软引用隐藏问题"></a>软引用隐藏问题</h5><p>“<strong>GC overhead</strong>“,之所以会抛出这个错误，是由于虚拟机一直在不断回收软引用，回收进行的速度过快，占用的cpu过大(超过98%)，并且每次回收掉的内存过小(小于2%)，导致最终抛出了这个错误。</p>
<p><strong>优化方法，</strong>合适的处理方式是注册一个引用队列，每次循环之后将引用队列中出现的软引用对象从cache中移除。</p>
<p>参考链接：<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67" target="_blank" rel="noopener">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>23 种设计模式的分类和功能</title>
    <url>/2020/04/03/23%20%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>设计模式有两种分类方法，即根据模式的<strong>目的和作用的范围</strong>划分</p>
<h3 id="1、根据目的来划分"><a href="#1、根据目的来划分" class="headerlink" title="1、根据目的来划分"></a>1、根据目的来划分</h3><p>根据模式是用来完成什么工作来划分，这种方式可分为<font color="#FF0000"> 创建型模式</font>、<font color="#FF0000">结构型模式</font>和<font color="#FF0000">行为型模式</font>3 种。</p>
<ol>
<li><strong>创建型模式：</strong>用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。其中单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</li>
<li><strong>结构型模式：</strong>用于描述如何将类或对象按某种布局组成更大的结构，其中代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</li>
<li><strong>行为型模式：</strong>用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。其中模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</li>
</ol>
<h3 id="2-根据作用范围来划分"><a href="#2-根据作用范围来划分" class="headerlink" title="2. 根据作用范围来划分"></a>2. 根据作用范围来划分</h3><p>根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。</p>
<ol>
<li><p><strong>类模式：</strong>用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。工厂方法、（类）适配器、模板方法、解释器属于该模式。</p>
</li>
<li><p><strong>对象模式：</strong>用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。除了以上 4 种，其他的都是对象模式。</p>
<h4 id="23-种设计模式的分类表"><a href="#23-种设计模式的分类表" class="headerlink" title="23 种设计模式的分类表"></a>23 种设计模式的分类表</h4></li>
</ol>
<table>
<thead>
<tr>
<th>范围\目的</th>
<th>创建型模式</th>
<th>结构型模式</th>
<th>行为型模式</th>
</tr>
</thead>
<tbody><tr>
<td>类模式</td>
<td>工厂方法</td>
<td>(类）适配器</td>
<td>模板方法、解释器</td>
</tr>
<tr>
<td>对象模式</td>
<td>单例<br/>原型<br/>抽象工厂<br/>建造者</td>
<td>代理<br/>(对象）适配器<br/>桥接<br/>装饰<br/>外观<br/>享元<br/>组合</td>
<td>策略<br/>命令<br/>职责链<br/>状态<br/>观察者<br/>中介者<br/>迭代器<br/>访问者<br/>备忘录</td>
</tr>
</tbody></table>
<h3 id="3-23种设计模式的功能"><a href="#3-23种设计模式的功能" class="headerlink" title="3. 23种设计模式的功能"></a>3. 23种设计模式的功能</h3><p>前面说明了 23 种设计模式的分类，现在对各个模式的功能进行介绍。</p>
<h4 id="1-单例（Singleton）模式"><a href="#1-单例（Singleton）模式" class="headerlink" title="1.  单例（Singleton）模式"></a>1.  <strong>单例（Singleton）模式</strong></h4><p>   某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</p>
<h4 id="2-原型（Prototype）模式"><a href="#2-原型（Prototype）模式" class="headerlink" title="2. 原型（Prototype）模式"></a>2. <strong>原型（Prototype）模式</strong></h4><p>   将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</p>
<h4 id="3-工厂方法（Factory-Method）模式"><a href="#3-工厂方法（Factory-Method）模式" class="headerlink" title="3. 工厂方法（Factory Method）模式"></a>3. <strong>工厂方法（Factory Method）模式</strong></h4><p>   定义一个用于创建产品的接口，由子类决定生产什么产品。</p>
<h4 id="4-抽象工厂（AbstractFactory）模式"><a href="#4-抽象工厂（AbstractFactory）模式" class="headerlink" title="4. 抽象工厂（AbstractFactory）模式"></a>4. <strong>抽象工厂（AbstractFactory）模式</strong></h4><p>   提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</p>
<h4 id="5-建造者（Builder）模式"><a href="#5-建造者（Builder）模式" class="headerlink" title="5. 建造者（Builder）模式"></a>5. <strong>建造者（Builder）模式</strong></h4><p>   将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</p>
<h4 id="6-代理（Proxy）模式"><a href="#6-代理（Proxy）模式" class="headerlink" title="6. 代理（Proxy）模式"></a>6. <strong>代理（Proxy）模式</strong></h4><p>   为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</p>
<h4 id="7-适配器（Adapter）模式"><a href="#7-适配器（Adapter）模式" class="headerlink" title="7. 适配器（Adapter）模式"></a>7. <strong>适配器（Adapter）模式</strong></h4><p>   将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>
<h4 id="8-桥接（Bridge）模式"><a href="#8-桥接（Bridge）模式" class="headerlink" title="8. 桥接（Bridge）模式"></a>8. <strong>桥接（Bridge）模式</strong></h4><p>   将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<h4 id="9-装饰（Decorator）模式"><a href="#9-装饰（Decorator）模式" class="headerlink" title="9. 装饰（Decorator）模式"></a>9. <strong>装饰（Decorator）模式</strong></h4><p>动态的给对象增加一些职责，即增加其额外的功能。</p>
<h4 id="10-外观（Facade）模式"><a href="#10-外观（Facade）模式" class="headerlink" title="10. 外观（Facade）模式"></a>10. <strong>外观（Facade）模式</strong></h4><p>为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</p>
<h4 id="11-享元（Flyweight）模式"><a href="#11-享元（Flyweight）模式" class="headerlink" title="11. 享元（Flyweight）模式"></a>11. <strong>享元（Flyweight）模式</strong></h4><p>运用共享技术来有效地支持大量细粒度对象的复用。</p>
<h4 id="12-组合（Composite）模式"><a href="#12-组合（Composite）模式" class="headerlink" title="12. 组合（Composite）模式"></a>12. <strong>组合（Composite）模式</strong></h4><p>将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</p>
<h4 id="13-模板方法（TemplateMethod）模式"><a href="#13-模板方法（TemplateMethod）模式" class="headerlink" title="13. 模板方法（TemplateMethod）模式"></a>13. <strong>模板方法（TemplateMethod）模式</strong></h4><p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p>
<h4 id="14-策略（Strategy）模式"><a href="#14-策略（Strategy）模式" class="headerlink" title="14. 策略（Strategy）模式"></a>14. <strong>策略（Strategy）模式</strong></h4><p>定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</p>
<h4 id="15-命令（Command）模式"><a href="#15-命令（Command）模式" class="headerlink" title="15. 命令（Command）模式"></a>15. <strong>命令（Command）模式</strong></h4><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</p>
<h4 id="16-职责链（Chain-of-Responsibility）模式"><a href="#16-职责链（Chain-of-Responsibility）模式" class="headerlink" title="16. 职责链（Chain of Responsibility）模式"></a>16. <strong>职责链（Chain of Responsibility）模式</strong></h4><p>把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</p>
<h4 id="17-状态（State）模式"><a href="#17-状态（State）模式" class="headerlink" title="17. 状态（State）模式"></a>17. <strong>状态（State）模式</strong></h4><p>允许一个对象在其内部状态发生改变时改变其行为能力。</p>
<h4 id="18-观察者（Observer）模式"><a href="#18-观察者（Observer）模式" class="headerlink" title="18. 观察者（Observer）模式"></a>18. <strong>观察者（Observer）模式</strong></h4><p>多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</p>
<h4 id="19-中介者（Mediator）模式"><a href="#19-中介者（Mediator）模式" class="headerlink" title="19. 中介者（Mediator）模式"></a>19. <strong>中介者（Mediator）模式</strong></h4><p>定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</p>
<h4 id="20-迭代器（Iterator）模式"><a href="#20-迭代器（Iterator）模式" class="headerlink" title="20. 迭代器（Iterator）模式"></a>20. <strong>迭代器（Iterator）模式</strong></h4><p>提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p>
<h4 id="21-访问者（Visitor）模式"><a href="#21-访问者（Visitor）模式" class="headerlink" title="21. 访问者（Visitor）模式"></a>21. <strong>访问者（Visitor）模式</strong></h4><p>在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</p>
<h4 id="22-备忘录（Memento）模式"><a href="#22-备忘录（Memento）模式" class="headerlink" title="22. 备忘录（Memento）模式"></a>22. <strong>备忘录（Memento）模式</strong></h4><p>在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</p>
<h4 id="23-解释器（Interpreter）模式"><a href="#23-解释器（Interpreter）模式" class="headerlink" title="23. 解释器（Interpreter）模式"></a>23. <strong>解释器（Interpreter）模式</strong></h4><p>提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器共享文件夹Samba</title>
    <url>/2020/03/21/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9Samba/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/Utotao/article/details/100848930" target="_blank" rel="noopener">Windows访问Linux服务器共享文件夹–Samba</a></p>
<h4 id="1、Linux安装Samba及配置"><a href="#1、Linux安装Samba及配置" class="headerlink" title="1、Linux安装Samba及配置"></a>1、Linux安装Samba及配置</h4><h5 id="安装Samba："><a href="#安装Samba：" class="headerlink" title="安装Samba："></a>安装Samba：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install samba</span><br></pre></td></tr></table></figure>
<h5 id="配置Samba："><a href="#配置Samba：" class="headerlink" title="配置Samba："></a>配置Samba：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;samba&#x2F;smb.conf</span><br></pre></td></tr></table></figure>
<h5 id="配置内容："><a href="#配置内容：" class="headerlink" title="配置内容："></a>配置内容：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[share]</span><br><span class="line">    #comment &#x3D; Ubuntu File Server Share</span><br><span class="line">    path &#x3D; &#x2F;home&#x2F;ubuntu</span><br><span class="line">    valid users &#x3D; root</span><br><span class="line">    available &#x3D; yes</span><br><span class="line">    browsable &#x3D; yes</span><br><span class="line">    writable &#x3D; yes</span><br></pre></td></tr></table></figure>
<p>配置用户名密码：（windows访问share文件夹时候使用）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo smbpasswd -a root -&gt; 注意此处的用户名要和上面的valid users保持一致</span><br></pre></td></tr></table></figure>

<p>回车后会让你输入密码<br>设置共享文件夹权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chmod 777 &#x2F;home&#x2F;ubuntu</span><br></pre></td></tr></table></figure>

<p>重启：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;samb restart</span><br></pre></td></tr></table></figure>
<h3 id="2、windows访问共享文件夹"><a href="#2、windows访问共享文件夹" class="headerlink" title="2、windows访问共享文件夹"></a>2、windows访问共享文件夹</h3><p>网络—&gt;右键选择映射网络驱动器，填写IP+Samba配置文件中的[share]之[]里面的字样</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ROOM</title>
    <url>/2020/03/20/ROOM/</url>
    <content><![CDATA[<p>不使用AndroidX的依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def room_version &#x3D; &quot;1.1.1&quot;</span><br><span class="line"></span><br><span class="line">    implementation &quot;android.arch.persistence.room:runtime:$room_version&quot;</span><br><span class="line">    kapt &quot;android.arch.persistence.room:compiler:$room_version&quot; &#x2F;&#x2F; use kapt for Kotlin</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">data class User(</span><br><span class="line">        @PrimaryKey val uid: Int,</span><br><span class="line">        @ColumnInfo(name &#x3D; &quot;first_name&quot;) val firstName: String?,</span><br><span class="line">        @ColumnInfo(name &#x3D; &quot;last_name&quot;) val lastName: String?)</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Database(entities &#x3D; [User::class], version &#x3D; 1)</span><br><span class="line">abstract class AppDatabase : RoomDatabase() &#123;</span><br><span class="line">    abstract fun userDao(): UserDao</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Dao</span><br><span class="line">interface UserDao &#123;</span><br><span class="line">    @Query(&quot;SELECT * FROM user&quot;)</span><br><span class="line">    fun getAll(): List&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM user WHERE uid IN (:userIds)&quot;)</span><br><span class="line">    fun loadAllByIds(userIds: IntArray): List&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM user WHERE first_name LIKE :first AND &quot; +</span><br><span class="line">            &quot;last_name LIKE :last LIMIT 1&quot;)</span><br><span class="line">    fun findByName(first: String, last: String): User</span><br><span class="line"></span><br><span class="line">    @Insert</span><br><span class="line">    fun insertAll(vararg users: User)</span><br><span class="line"></span><br><span class="line">    @Delete</span><br><span class="line">    fun delete(user: User)</span><br><span class="line"></span><br><span class="line">    @Query(&quot;select max(uid) from user &quot;)</span><br><span class="line">    fun queryMaxId(): Int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val userDao: UserDao by lazy &#123;</span><br><span class="line">           Room.databaseBuilder(</span><br><span class="line">                   appContext,</span><br><span class="line">                   AppDatabase::class.java, &quot;database-name&quot;</span><br><span class="line">           ).build().userDao()</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h4 id="监控数据变化"><a href="#监控数据变化" class="headerlink" title="监控数据变化"></a>监控数据变化</h4><p>使用RoomDatabase.getInvalidationTracker获取InvalidationTracker对象来监听表数据的改变。一般推荐直接在DAO方法中返回LiveData或者Observable对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Query(&quot;SELECT * FROM ConsumeInfo where timeStr LIKE :month ORDER BY time ASC&quot;)</span><br><span class="line">  fun getDataWithMonth(month: String): LiveData&lt;List&lt;ConsumeInfo&gt;&gt;</span><br><span class="line">  </span><br><span class="line">  ViewModel中监听，也可以放在界面上监听，下面的代码只能在Model中监听</span><br><span class="line">  </span><br><span class="line">   val liveLists &#x3D; DaoUtil.instance.getConsumeInfoList(month)</span><br><span class="line">          &#x2F;&#x2F; 添加数据监听，当数据变化时自动更新数据</span><br><span class="line">          liveLists.observe(owner, Observer&lt;List&lt;ConsumeInfo&gt;&gt; &#123;</span><br><span class="line">              Logger.e(&quot;getHistoryConsume observe change&quot;)</span><br><span class="line">              getAverageConsume(it)</span><br><span class="line">          &#125;)</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private val users: MutableLiveData&lt;List&lt;User&gt;&gt; by lazy &#123;</span><br><span class="line">       MutableLiveData&lt;List&lt;User&gt;&gt;().also &#123;</span><br><span class="line">           uiScope.launch &#123;</span><br><span class="line">               val rst &#x3D; async(Dispatchers.IO) &#123; App.userDao.getAll() &#125;</span><br><span class="line">               it.value &#x3D; rst.await()</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fun getUsers(): LiveData&lt;List&lt;User&gt;&gt; &#123;</span><br><span class="line">       uiScope.launch &#123;</span><br><span class="line">           val rst &#x3D; async(Dispatchers.IO) &#123; App.userDao.getAll() &#125;</span><br><span class="line">           users.value &#x3D; rst.await()</span><br><span class="line">       &#125;</span><br><span class="line">       return users</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fun setUsers() &#123;</span><br><span class="line">       uiScope.launch &#123;</span><br><span class="line">           val rst &#x3D; async(Dispatchers.IO) &#123;</span><br><span class="line">               var count &#x3D; App.userDao.queryMaxId()</span><br><span class="line">               App.userDao.insertAll(User(++count, &quot;f$count&quot;, &quot;l$count&quot;))</span><br><span class="line">               App.userDao.getAll()</span><br><span class="line">           &#125;</span><br><span class="line">           users.value &#x3D; rst.await()</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
        <category>JetPack</category>
      </categories>
      <tags>
        <tag>JetPack</tag>
      </tags>
  </entry>
  <entry>
    <title>Android下拉状态栏快捷开关的添加</title>
    <url>/2020/03/18/Android%E4%B8%8B%E6%8B%89%E7%8A%B6%E6%80%81%E6%A0%8F%E5%BF%AB%E6%8D%B7%E5%BC%80%E5%85%B3%E7%9A%84%E6%B7%BB%E5%8A%A0/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/lyjit/article/details/51579067" target="_blank" rel="noopener">下拉通知栏快捷开关的添加</a>  </p>
<h3 id="一：快捷开关功能以及开关状态的实现"><a href="#一：快捷开关功能以及开关状态的实现" class="headerlink" title="一：快捷开关功能以及开关状态的实现"></a>一：快捷开关功能以及开关状态的实现</h3><h4 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h4><p>首先看一下原生的下拉菜单按键的布局在哪里。打开这个路径的文件：frameworks/base/packages/SystemUI/res/values/config.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;string name&#x3D;&quot;quick_settings_tiles_default&quot; translatable&#x3D;&quot;false&quot;&gt;</span><br><span class="line">   wifi,bt,inversion,cell,airplane,rotation,flashlight,settings,dataconnection,location,screenshot,cast,hotspot,hotknot,audioprofile</span><br><span class="line">&lt;&#x2F;string&gt;</span><br></pre></td></tr></table></figure>

<p>对！自适应的布局，这些快捷按键的定义都在这里。要是想换成自己定义的按键开关，只要在这里替换就行，但这只是第一步。<br>我这里暂且换成自己定义的布局：wifi,蓝牙,无线麦克,FM</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;string name&#x3D;&quot;quick_settings_tiles_default&quot; translatable&#x3D;&quot;false&quot;&gt;</span><br><span class="line">        wifi,bluetooth,wirelessmic,fm</span><br><span class="line">&lt;&#x2F;string&gt;</span><br></pre></td></tr></table></figure>

<h4 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h4><p>在config.xml文件中定义我们想要的开关名称之后，还需要打开如下路径来添加相关的内容：<br>frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/QSTileHost.java<br>在如下方法里面添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 获取到预定义好的各快捷图标的QSTile</span><br><span class="line">     * *&#x2F;</span><br><span class="line">    private QSTile&lt;?&gt; createTile(String tileSpec) &#123;</span><br><span class="line">        IQuickSettingsPlugin quickSettingsPlugin &#x3D; PluginFactory</span><br><span class="line">                .getQuickSettingsPlugin(mContext);</span><br><span class="line">        if (tileSpec.equals(&quot;wifi&quot;)) return new WifiTile(this);</span><br><span class="line">        &#x2F;&#x2F;add by lyj</span><br><span class="line">        else if (tileSpec.equals(&quot;bluetooth&quot;)) return new CallBluetoothTile(this);</span><br><span class="line">        else if (tileSpec.equals(&quot;wirelessmic&quot;)) return new WirelessMicTile(this);</span><br><span class="line">        else if (tileSpec.equals(&quot;fm&quot;)) return new FMTile(this); &#x2F;&#x2F;要添加的FM</span><br><span class="line"> </span><br><span class="line">        ......</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是获取到预定义好的各个快捷图标的QSTile。其中FMTile文件是什么的，接着往下看</p>
<h4 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h4><p>这一步很重要，首先看一下这个路径：frameworks/base/packages/SystemUI/src/com/android/systemui/qs/tiles<br>这个路径下面就是你定义的开关实现功能的地方，这里新添加的FM在原有的快捷开关里面是没有的，所以要在这里新添加一个文件，咱们这里暂且起名为FMTile.java，也就是之前所说的FMTile文件。<br>新建好类之后要继承 QSTile&lt;QSTile.BooleanState&gt;<br>这样会生成一些方法，下面就来看一下这个文件各个方法的作用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FMTile extends QSTile&lt;QSTile.BooleanState&gt;&#123;</span><br><span class="line">	</span><br><span class="line">	public FMTile(com.android.systemui.qs.QSTile.Host host) &#123;</span><br><span class="line">		super(host);</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated constructor stub</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	@Override</span><br><span class="line">	public void setListening(boolean listening) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	@Override</span><br><span class="line">	protected com.android.systemui.qs.QSTile.BooleanState newTileState() &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">		return new BooleanState();</span><br><span class="line">	&#125;</span><br><span class="line">	public void setFmModeUpdate()&#123;</span><br><span class="line">		handleRefreshState(null);</span><br><span class="line">        &#125;</span><br><span class="line">	@Override</span><br><span class="line">       protected String getQSTileViewMarkBit()&#123;</span><br><span class="line">	 	return &quot;fm&quot; ;</span><br><span class="line">	 &#125;</span><br><span class="line"> </span><br><span class="line">	 @Override</span><br><span class="line">	protected void handleClick() &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">                &#x2F;&#x2F;开关默认关闭</span><br><span class="line">                int mState &#x3D; Settings.System.getInt(mContext.getContentResolver(), Settings.System.FM_SYSTEMUI, 1);</span><br><span class="line">		boolean mCloseState &#x3D; (mState &#x3D;&#x3D; 0);</span><br><span class="line">		Settings.System.putInt(mContext.getContentResolver(),Settings.System.FM_SYSTEMUI, mCloseState ? 1 : 0);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	@Override</span><br><span class="line">	protected void handleUpdateState(</span><br><span class="line">			com.android.systemui.qs.QSTile.BooleanState state, Object arg) &#123;</span><br><span class="line">		</span><br><span class="line">		int mState &#x3D; Settings.System.getInt(mContext.getContentResolver(), Settings.System.FM_SYSTEMUI, 1);</span><br><span class="line">		boolean mCloseState &#x3D; (mState &#x3D;&#x3D; 0);</span><br><span class="line">		state.visible &#x3D; true ;</span><br><span class="line">		state.label &#x3D; mContext.getString(R.string.quick_settings_fm_title);</span><br><span class="line">		state.icon &#x3D; ResourceIcon.get(mCloseState ? R.drawable.ic_settings_fm_on : R.drawable.ic_settings_fm_off);&#x2F;&#x2F;图片状态</span><br><span class="line">		if(mCloseState)&#123;&#x2F;&#x2F;open</span><br><span class="line">			&#x2F;&#x2F;开关打开相关功能的操作</span><br><span class="line">			</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			&#x2F;&#x2F;开关关闭相关功能的操作</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中Settings.System.FM_SYSTEMUI 是我们在settingProvader中定义的值，主要是控制与外界开关同步的问题，这个我们后面会有详细的介绍，这些方法中最重要的是handleClick()和handleUpdateState(…),每次点击开关会先走handleclick()方法，然后去刷新页面，刷新页面的处理就是在handleUpdateState(..)中处理。<br>这个方法里面有图片状态的改变，以及功能的实现。这个时候开关默认的是关闭，要是默认打开的话只要在两个方法中把mstate = Settings.System.getInt(*, *, 1);  把1改为0即可。<br>这里还要注意的方法首先是FMTile(..)这个方法是初始化用的，也就是开机之后只走一次，也就相当我Activity里面的Oncreate()方法,如果你有什么要初始化的东西可以在这里面定义。还有特别注意的两个方法setFmModeUpdate()和getQSTileViewMarkBit()。这两个方法不是文件自动生成的，需要你手动添加，那么这两个方法有什么作用呢，其实这两个方法也很重要，要是没有这两个方法的话点击开关是没有作用的，也就是没有起到刷新页面的作用，那这两个方法在那实现的呢，来接着看下面的解释：</p>
<h4 id="第四步："><a href="#第四步：" class="headerlink" title="第四步："></a>第四步：</h4><p>结合第三步最后的疑问我们来看一下这个文件：frameworks/base/packages/SystemUI/src/com/android/systemui/qs/QSTile.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected QSTile(Host host) &#123;</span><br><span class="line">        mHost &#x3D; host;</span><br><span class="line">        mContext &#x3D; host.getContext();</span><br><span class="line">        mHandler &#x3D; new H(host.getLooper());</span><br><span class="line">        setChangeObserver();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setChangeObserver()&#123; &#x2F;&#x2F;实时监听状态的变化</span><br><span class="line">    	mContext.getContentResolver().registerContentObserver(</span><br><span class="line">                Settings.System.getUriFor(Settings.System.FM_SYSTEMUI),</span><br><span class="line">                true, mFmModeChangeObserver);</span><br><span class="line">	.....</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">    private ContentObserver mFmModeChangeObserver &#x3D; new ContentObserver(new Handler()) &#123;</span><br><span class="line">		@Override</span><br><span class="line">		public void onChange(boolean selfChange) &#123;</span><br><span class="line">			setFmModeUpdate();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">    public void setFmModeUpdate()&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<pre><code>这些添加之后你的开关状态就能其作用了，但到这里如果你编译工程的时候会发现编译报错，如下图：</code></pre><p>这是怎么回事呢，这是因为你添加的FMTile.java文件里面的方法是从一个超类型实现的。</p>
<p>这个时候你还需有在QSTile.java文件中添加getQSTileViewMarkBit()方法，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;</span><br><span class="line">    protected QSTileView mQSTileView ;</span><br><span class="line">    public QSTileView createTileView(Context context) &#123;</span><br><span class="line">    	</span><br><span class="line">    	mQSTileView &#x3D; new QSTileView(context) ;</span><br><span class="line">    	mQSTileView.setMarkBit(getQSTileViewMarkBit());&#x2F;&#x2F;add </span><br><span class="line">    	Log.i(&quot;lyj_create&quot;, &quot;mQSTileView &#x3D; &quot;+mQSTileView);</span><br><span class="line">        return mQSTileView;</span><br><span class="line">    &#125;</span><br><span class="line">    protected String getQSTileViewMarkBit()&#123;</span><br><span class="line">		return null ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>到这里FM开关的添加就结束了。同样的方法添加其它快捷按键开关原理都是一样的。</p>
<h3 id="二：下拉FM开关与外界开关同步"><a href="#二：下拉FM开关与外界开关同步" class="headerlink" title="二：下拉FM开关与外界开关同步"></a>二：下拉FM开关与外界开关同步</h3><p>   其实刚才我们已经有所了解了，主要就是Settings值的作用，但这里面还涉及到一个重要的知识点，先不着急，我们先打开FM的应用代码，看怎么实现同步更新：</p>
<p>   首先在你应用里面控制开关的地方加上Settings.System.putInt(MainActivity.this.getContentResolver(), Settings.System.FM_SYSTEMUI, 0);  //0代表打开 关闭的时候调用Settings.System.putInt(MainActivity.this.getContentResolver(), Settings.System.FM_SYSTEMUI, 1);  //1代表关闭</p>
<p>   关键的代码来了：也就是我们之前说的实现同步更新的 ContentObserver 内容观察者</p>
<p>首先看一下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void registerContentObserver() &#123;</span><br><span class="line">		this.getContentResolver().registerContentObserver(</span><br><span class="line">				Settings.System.getUriFor(Settings.System.FM_SYSTEMU), true, mFmcContentObserver);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	private void unregisterContentObserver() &#123;</span><br><span class="line">		this.getContentResolver().unregisterContentObserver(mFmcContentObserver);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	private ContentObserver mFmcContentObserver&#x3D;new ContentObserver(new Handler()) &#123;</span><br><span class="line"> </span><br><span class="line">		@Override</span><br><span class="line">		public void onChange(boolean selfChange) &#123;</span><br><span class="line">			int mState &#x3D; Settings.System.getInt(getActivity().getContentResolver(), Settings.System.FM_SYSTEMU, 0);</span><br><span class="line">			boolean mCloseState &#x3D; (mState &#x3D;&#x3D; 0);</span><br><span class="line">			if(mCloseState)&#123;&#x2F;&#x2F;打开的相关操作</span><br><span class="line">				mSwitchPreference.setChecked(true);</span><br><span class="line">				Log.i(&quot;lyj_wire&quot;,&quot;mikeState: &#x3D; &quot;+mikeState);</span><br><span class="line">			&#125;else&#123;&#x2F;&#x2F;关闭的相关操作</span><br><span class="line">				mSwitchPreference.setChecked(false);</span><br><span class="line">				Log.i(&quot;lyj_wire&quot;,&quot;11mikeState:&quot;+mikeState);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p>在onChange方法里面主要是观察Settings值的变化，然后根据值的变化控制你应用的开关。我们定义的这个值在状态栏快捷开关里面也有所控制，这个刚才已经介绍。那么这个时候你会问，我们在应用里面添加观察者可是没有在下拉状态栏里添加，这样能同步吗？其实SystemUi里面已经添加过了,你只需要在你的应用里添加内容观察者即可。注意在初始化的地方要注册registerContentObserver() ，在退出的时候调用unregisterContentObserver()方法即可。这样以来就能实现应用开关和状态栏下拉快捷开关的同步。<br>这里还涉及到一个知识点：就是打开开关，不管是在你的应用里还是在状态栏快捷开关里，打开FM后在状态栏顶部需要有一个图标显示你打开了FM，关闭时图片消失。这个功能的实现我会在后续的文章中介绍。这里就不做说明了。</p>
<p>  相信看到这里你会对SystemUi状态栏的开发有新的帮助。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Android.mk打包apk</title>
    <url>/2020/03/18/Android.mk%E6%89%93%E5%8C%85apk/</url>
    <content><![CDATA[<p>一、新建Android.mk文件 放在app/src/main 目录下</p>
<p>二、代码中引用的第三方库通过aar包存放在最外层libs目录下，所有app共享这些库文件。</p>
<p>如何有自己用的第三方开源库，<a href="https://www.jianshu.com/p/59efa895589e" target="_blank" rel="noopener">查找aar的方法</a> </p>
<p>电脑上rxandroid aar的目录：<br>C:\Users\Lenovo.gradle\caches\modules-2\files-2.1\io.reactivex\rxandroid（各个电脑目录不同）</p>
<p>Android.mk编写规则<br>（系统设置例子）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#代表mk当前文档路径</span><br><span class="line">LOCAL_PATH :&#x3D; $(call my-dir) </span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_PACKAGE_NAME :&#x3D; HQ_DevSet</span><br><span class="line"></span><br><span class="line">#指该模块在所有版本下都编译</span><br><span class="line">LOCAL_MODULE_TAGS :&#x3D; optional</span><br><span class="line"></span><br><span class="line">#混淆配置</span><br><span class="line">LOCAL_PROGUARD_ENABLED :&#x3D; full obfuscation</span><br><span class="line">LOCAL_PROGUARD_FLAG_FILES :&#x3D; ..&#x2F;..&#x2F;proguard-rules.pro</span><br><span class="line"></span><br><span class="line">#设置不打odex包</span><br><span class="line">LOCAL_DEX_PREOPT :&#x3D; false</span><br><span class="line">DONT_DEXPREOPT_PREBUILTS :&#x3D; true  </span><br><span class="line"></span><br><span class="line">#apk路径</span><br><span class="line">LOCAL_MODULE_PATH :&#x3D; $(TARGET_OUT)&#x2F;app</span><br><span class="line"></span><br><span class="line">#签名配置</span><br><span class="line">LOCAL_CERTIFICATE :&#x3D; platform</span><br><span class="line"></span><br><span class="line">LOCAL_MULTILIB :&#x3D; 32</span><br><span class="line"></span><br><span class="line">#源码文件</span><br><span class="line">#引用当前app的资源</span><br><span class="line">LOCAL_RESOURCE_DIR +&#x3D; $(LOCAL_PATH)&#x2F;res</span><br><span class="line"></span><br><span class="line">#声明当前app的代码目录</span><br><span class="line">src_dirs :&#x3D; java&#x2F;</span><br><span class="line"></span><br><span class="line">#引用当前app的代码</span><br><span class="line">LOCAL_SRC_FILES :&#x3D; $(call all-java-files-under, $(src_dirs))</span><br><span class="line"></span><br><span class="line">#添加aidl源码文件</span><br><span class="line">LOCAL_SRC_FILES +&#x3D; \</span><br><span class="line">src&#x2F;xx&#x2F;xx&#x2F;xx&#x2F;XxxOne.aidl \</span><br><span class="line">src&#x2F;xx&#x2F;xx&#x2F;xx&#x2F;XxxTwo.aidl</span><br><span class="line"></span><br><span class="line"># jar包</span><br><span class="line">#声明多个 jar 包的位置   ----其中\代表换行，后面不能跟任何字符，后面的一样</span><br><span class="line">LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES :&#x3D; \</span><br><span class="line"> hqlib:..&#x2F;..&#x2F;..&#x2F;libs&#x2F;hqlib.jar \</span><br><span class="line"> hqapi:..&#x2F;..&#x2F;..&#x2F;libs&#x2F;hqapi.jar \</span><br><span class="line"> hqapi_sq:..&#x2F;..&#x2F;..&#x2F;libs&#x2F;hqapi_sq.jar\</span><br><span class="line"> rxjava:..&#x2F;..&#x2F;..&#x2F;libs&#x2F;rxjava-1.3.7.jar</span><br><span class="line">																			</span><br><span class="line">#引用我们声明的多个 jar 包的变量</span><br><span class="line">LOCAL_STATIC_JAVA_LIBRARIES +&#x3D;  hqlib \</span><br><span class="line">                                hqapi \</span><br><span class="line">                                hqapi_sq \</span><br><span class="line">                                rxjava \</span><br><span class="line">                                android-support-v4</span><br><span class="line">#aar包</span><br><span class="line">#声明aar包</span><br><span class="line">LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES +&#x3D; PublicTitle2:..&#x2F;..&#x2F;..&#x2F;libs&#x2F;PublicTitle2.aar\</span><br><span class="line">rxandroid:..&#x2F;..&#x2F;..&#x2F;libs&#x2F;rxandroid-1.2.1.aar</span><br><span class="line"></span><br><span class="line">#引用aar包</span><br><span class="line">LOCAL_STATIC_JAVA_AAR_LIBRARIES +&#x3D; PublicTitle2 \</span><br><span class="line">								 Rxandroid</span><br><span class="line"></span><br><span class="line">#引入使用的资源 添加包名</span><br><span class="line">LOCAL_AAPT_FLAGS +&#x3D; --auto-add-overlay \</span><br><span class="line">					--extra-packages com.hopechart.sq.publictitle \</span><br><span class="line">					--extra-packages rx.android </span><br><span class="line"></span><br><span class="line">#设置version版本</span><br><span class="line">#设置版本号和名字，如果不写会默认使用系统api的版本号25 --7.1.1</span><br><span class="line">version_code &#x3D; 24</span><br><span class="line">version_name :&#x3D; 4.0.0.1</span><br><span class="line">						</span><br><span class="line">LOCAL_AAPT_FLAGS +&#x3D; --version-code $(version_code)</span><br><span class="line">LOCAL_AAPT_FLAGS +&#x3D; --version-name $(version_name)    </span><br><span class="line"></span><br><span class="line">#打出来的minSDK和targetSDK version都是19 </span><br><span class="line">LOCAL_SDK_VERSION :&#x3D; 19  </span><br><span class="line">#如果有特殊情况可在清单文件中添加</span><br><span class="line"># 【</span><br><span class="line">#  AndroidManifest.xml清单文件添加sdk版本，优先使用清单文件中</span><br><span class="line"># 的版本号</span><br><span class="line">#  &lt;uses-sdk android:minSdkVersion&#x3D;&quot;19&quot;</span><br><span class="line">#         android:targetSdkVersion&#x3D;&quot;25&quot;&#x2F;&gt;</span><br><span class="line"># 】</span><br><span class="line"></span><br><span class="line">#打apk包</span><br><span class="line">include $(BUILD_PACKAGE)</span><br><span class="line"></span><br><span class="line">#调用子目录的mk文件</span><br><span class="line">include $(call all-makefiles-under,$(LOCAL_PATH))</span><br></pre></td></tr></table></figure>


<p>#Android.mk END</p>
<p>#如果使用的系统的包，需要引入他们使用的资源文件，否则会提示编译资源找不到的错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#RecyclerView例子</span><br><span class="line">LOCAL_RESOURCE_DIR +&#x3D; frameworks&#x2F;support&#x2F;v7&#x2F;recyclerview&#x2F;res</span><br><span class="line">LOCAL_STATIC_JAVA_LIBRARIES +&#x3D; android-support-v7-recyclerview</span><br><span class="line">LOCAL_AAPT_FLAGS +&#x3D; --auto-add-overlay \</span><br><span class="line">--extra-packages android.support.v7.recyclerview</span><br></pre></td></tr></table></figure>

<p>代码编译<br>1、在源码任意目录下创建一个目录，把改好的代码上传到该目录；<br>2、切换到源码顶层目录，执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source build&#x2F;envsetup.sh;</span><br></pre></td></tr></table></figure>

<p>3、编译单个apk , 执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mmm  [apk mk文件的目录]</span><br></pre></td></tr></table></figure>

<p>需要在全编的情况下才能单独编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make -j32</span><br></pre></td></tr></table></figure>
<p>编译所有的模块编译所有的模块需要在每个模块的父级目录添加Android.mk文件</p>
<p>内容【</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOCAL_PATH :&#x3D; $(call my-dir)</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">include $(call all-makefiles-under,$(LOCAL_PATH))</span><br></pre></td></tr></table></figure>

<p>】<br>这样就可以执行子目录中的Android.mk文件。<br>如下目录执行的命令就是: mmm 代码目录/SQ10Inch,然后就可以在输出目录看到所有打包出来的apk文件。</p>
<p>参考链接：<br><a href="https://blog.csdn.net/jsn_ze/article/details/72790401" target="_blank" rel="noopener">Android源码编译第三方app如何写Android.mk</a><br><a href="https://www.jianshu.com/p/e19e0d3bf13a" target="_blank" rel="noopener">Android.mk引用jar包、so库、aar包系统签名</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>打包编译</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>打包编译</tag>
      </tags>
  </entry>
  <entry>
    <title>vi—终端中的编辑器</title>
    <url>/2020/03/18/vi%E2%80%94%E7%BB%88%E7%AB%AF%E4%B8%AD%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<h1 id="vi-——-终端中的编辑器"><a href="#vi-——-终端中的编辑器" class="headerlink" title="vi —— 终端中的编辑器"></a><code>vi</code> —— 终端中的编辑器</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li><code>vi</code> 简介</li>
<li>打开和新建文件</li>
<li>三种工作模式</li>
<li>常用命令</li>
<li>分屏命令</li>
<li>常用命令速查图</li>
</ul>
<h2 id="01-vi-简介"><a href="#01-vi-简介" class="headerlink" title="01. vi 简介"></a>01. <code>vi</code> 简介</h2><h3 id="1-1-学习-vi-的目的"><a href="#1-1-学习-vi-的目的" class="headerlink" title="1.1 学习 vi 的目的"></a>1.1 学习 <code>vi</code> 的目的</h3><ul>
<li>在工作中，要对 <strong>服务器</strong> 上的文件进行 <strong>简单</strong> 的修改，可以使用 <code>ssh</code> 远程登录到服务器上，并且使用 <code>vi</code> 进行快速的编辑即可</li>
<li>常见需要修改的文件包括：<ul>
<li><strong>源程序</strong></li>
<li><strong>配置文件</strong>，例如 <code>ssh</code> 的配置文件 <code>~/.ssh/config</code></li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>在没有图形界面的环境下，要编辑文件，<code>vi</code> 是最佳选择！</li>
<li>每一个要使用 Linux 的程序员，都应该或多或少的学习一些 <code>vi</code> 的常用命令</li>
</ul>
</blockquote>
<h3 id="1-2-vi-和-vim"><a href="#1-2-vi-和-vim" class="headerlink" title="1.2 vi 和 vim"></a>1.2 vi 和 vim</h3><ul>
<li>在很多 <code>Linux</code> 发行版中，直接把 <code>vi</code> 做成 <code>vim</code> 的软连接</li>
</ul>
<h4 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h4><ul>
<li><code>vi</code> 是 <code>Visual interface</code> 的简称，是 <code>Linux</code> 中 <strong>最经典</strong> 的文本编辑器</li>
<li><code>vi</code> 的核心设计思想 —— <strong>让程序员的手指始终保持在键盘的核心区域，就能完成所有的编辑操作</strong></li>
</ul>
<p><img src="media/14993340485745/001_vi%E9%94%AE%E7%9B%98.png" alt="001_vi键盘-w551"></p>
<ul>
<li><code>vi</code> 的特点：<ul>
<li><strong>没有图形界面</strong> 的 <strong>功能强大</strong> 的编辑器</li>
<li>只能是编辑 <strong>文本内容</strong>，不能对字体、段落进行排版</li>
<li><strong>不支持鼠标操作</strong></li>
<li><strong>没有菜单</strong></li>
<li><strong>只有命令</strong></li>
</ul>
</li>
<li><code>vi</code> 编辑器在 <strong>系统管理</strong>、<strong>服务器管理</strong> 编辑文件时，<strong>其功能永远不是图形界面的编辑器能比拟的</strong></li>
</ul>
<h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a><code>vim</code></h4><p><strong>vim = vi improved</strong></p>
<ul>
<li><code>vim</code> 是从 <code>vi</code> 发展出来的一个文本编辑器，支持 <strong>代码补全</strong>、<strong>编译</strong> 及 <strong>错误跳转</strong> 等方便编程的功能特别丰富，在程序员中被广泛使用，被称为 <strong>编辑器之神</strong></li>
</ul>
<h4 id="查询软连接命令（知道）"><a href="#查询软连接命令（知道）" class="headerlink" title="查询软连接命令（知道）"></a>查询软连接命令（知道）</h4><ul>
<li>在很多 <code>Linux</code> 发行版中直接把 <code>vi</code> 做成 <code>vim</code> 的软连接</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找 vi 的运行文件</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">which</span> vi</span><br><span class="line">$ ls -l /usr/bin/vi</span><br><span class="line">$ ls -l /etc/alternatives/vi</span><br><span class="line">$ ls -l /usr/bin/vim.basic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找 vim 的运行文件</span></span><br><span class="line">$ <span class="built_in">which</span> vim</span><br><span class="line">$ ls -l /usr/bin/vim</span><br><span class="line">$ ls -l /etc/alternatives/vim</span><br><span class="line">$ ls -l /usr/bin/vim.basic</span><br></pre></td></tr></table></figure>

<h2 id="02-打开和新建文件"><a href="#02-打开和新建文件" class="headerlink" title="02. 打开和新建文件"></a>02. 打开和新建文件</h2><ul>
<li>在终端中输入 <code>vi</code> <strong>在后面跟上文件名</strong> 即可</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi 文件名</span><br></pre></td></tr></table></figure>

<ul>
<li>如果文件已经存在，会直接打开该文件</li>
<li>如果文件不存在，会新建一个文件</li>
</ul>
<h3 id="2-1-打开文件并且定位行"><a href="#2-1-打开文件并且定位行" class="headerlink" title="2.1 打开文件并且定位行"></a>2.1 打开文件并且定位行</h3><ul>
<li><p>在日常工作中，有可能会遇到 <strong>打开一个文件，并定位到指定行</strong> 的情况</p>
</li>
<li><p>例如：在开发时，<strong>知道某一行代码有错误</strong>，可以 <strong>快速定位</strong> 到出错代码的位置</p>
</li>
<li><p>这个时候，可以使用以下命令打开文件</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi 文件名 +行数</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：如果只带上 <code>+</code> 而不指定行号，会直接定位到文件末尾</p>
</blockquote>
<h3 id="2-2-异常处理"><a href="#2-2-异常处理" class="headerlink" title="2.2 异常处理"></a>2.2 异常处理</h3><ul>
<li>如果 <code>vi</code> 异常退出，在磁盘上可能会保存有 <strong>交换文件</strong></li>
<li>下次再使用 <code>vi</code> 编辑该文件时，会看到以下屏幕信息，按下字母 <code>d</code> 可以 <strong>删除交换文件</strong> 即可</li>
</ul>
<blockquote>
<p>提示：按下键盘时，注意关闭输入法</p>
</blockquote>
<p><img src="media/14993340485745/002_%E5%88%A0%E9%99%A4%E4%BA%A4%E6%8D%A2%E6%96%87%E4%BB%B6.png" alt="002_删除交换文件-w1048"></p>
<h2 id="03-三种工作模式"><a href="#03-三种工作模式" class="headerlink" title="03. 三种工作模式"></a>03. 三种工作模式</h2><ul>
<li><p><code>vi</code> 有三种基本工作模式：</p>
<ol>
<li><strong>命令模式</strong><ul>
<li><strong>打开文件首先进入命令模式</strong>，是使用 <code>vi</code> 的 <strong>入口</strong></li>
<li>通过 <strong>命令</strong> 对文件进行常规的编辑操作，例如：<strong>定位</strong>、<strong>翻页</strong>、<strong>复制</strong>、<strong>粘贴</strong>、<strong>删除</strong>……</li>
<li>在其他图形编辑器下，通过 <strong>快捷键</strong> 或者 <strong>鼠标</strong> 实现的操作，都在 <strong>命令模式</strong> 下实现</li>
</ul>
</li>
<li><strong>末行模式</strong> —— 执行 <strong>保存</strong>、<strong>退出</strong> 等操作 <ul>
<li>要退出 <code>vi</code> 返回到控制台，需要在末行模式下输入命令</li>
<li><strong>末行模式</strong> 是 <code>vi</code> 的 <strong>出口</strong></li>
</ul>
</li>
<li><strong>编辑模式</strong> —— 正常的编辑文字</li>
</ol>
</li>
</ul>
<p><img src="media/14993340485745/003_vi%E7%9A%84%E6%A8%A1%E5%BC%8F.png" alt="003_vi的模式-w500"></p>
<blockquote>
<p>提示：在 <code>Touch Bar</code> 的 Mac 电脑上 ，按 <code>ESC</code> 不方便，可以使用 <code>CTRL + [</code> 替代</p>
</blockquote>
<h3 id="末行模式命令"><a href="#末行模式命令" class="headerlink" title="末行模式命令"></a>末行模式命令</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">w</td>
<td align="center">write</td>
<td>保存</td>
</tr>
<tr>
<td align="center">q</td>
<td align="center">quit</td>
<td>退出，如果没有保存，不允许退出</td>
</tr>
<tr>
<td align="center">q!</td>
<td align="center">quit</td>
<td>强行退出，不保存退出</td>
</tr>
<tr>
<td align="center">wq</td>
<td align="center">write &amp; quit</td>
<td>保存并退出</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center"></td>
<td>保存并退出</td>
</tr>
</tbody></table>
<h2 id="04-常用命令"><a href="#04-常用命令" class="headerlink" title="04. 常用命令"></a>04. 常用命令</h2><h3 id="命令线路图"><a href="#命令线路图" class="headerlink" title="命令线路图"></a>命令线路图</h3><ol start="0">
<li>重复次数<ul>
<li>在命令模式下，<strong>先输入一个数字</strong>，<strong>再跟上一个命令</strong>，可以让该命令 <strong>重复执行指定次数</strong> </li>
</ul>
</li>
<li>移动和选择（<strong>多练</strong>）<ul>
<li><code>vi</code> 之所以快，关键在于 <strong>能够快速定位到要编辑的代码行</strong></li>
<li><strong>移动命令</strong> 能够 和 <strong>编辑操作</strong> 命令 <strong>组合使用</strong></li>
</ul>
</li>
<li>编辑操作<ul>
<li><strong>删除</strong>、<strong>复制</strong>、<strong>粘贴</strong>、<strong>替换</strong>、<strong>缩排</strong></li>
</ul>
</li>
<li>撤销和重复</li>
<li>查找替换</li>
<li>编辑</li>
</ol>
<h4 id="学习提示"><a href="#学习提示" class="headerlink" title="学习提示"></a>学习提示</h4><ol>
<li><code>vi</code> 的命令较多，<strong>不要期望一下子全部记住</strong>，个别命令忘记了，只是会影响编辑速度而已</li>
<li>在使用 <code>vi</code> 命令时，注意 <strong>关闭中文输入法</strong></li>
</ol>
<h3 id="4-1-移动（基本）"><a href="#4-1-移动（基本）" class="headerlink" title="4.1 移动（基本）"></a>4.1 移动（基本）</h3><ul>
<li>要熟练使用 <code>vi</code>，首先应该学会怎么在 <strong>命令模式</strong> 下样快速移动光标</li>
<li><strong>编辑操作命令</strong>，能够和 <strong>移动命令</strong> 结合在一起使用</li>
</ul>
<h4 id="1-上、下、左、右"><a href="#1-上、下、左、右" class="headerlink" title="1) 上、下、左、右"></a>1) 上、下、左、右</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th>功能</th>
<th align="center">手指</th>
</tr>
</thead>
<tbody><tr>
<td align="center">h</td>
<td>向左</td>
<td align="center">食指</td>
</tr>
<tr>
<td align="center">j</td>
<td>向下</td>
<td align="center">食指</td>
</tr>
<tr>
<td align="center">k</td>
<td>向上</td>
<td align="center">中指</td>
</tr>
<tr>
<td align="center">l</td>
<td>向右</td>
<td align="center">无名指</td>
</tr>
</tbody></table>
<p><img src="media/14993340485745/005_%E7%A7%BB%E5%8A%A8%E5%85%89%E6%A0%87.png" alt="005_移动光标-w551"></p>
<h4 id="2-行内移动"><a href="#2-行内移动" class="headerlink" title="2) 行内移动"></a>2) 行内移动</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">w</td>
<td align="center">word</td>
<td>向后移动一个单词</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">back</td>
<td>向前移动一个单词</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center"></td>
<td>行首</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center"></td>
<td>行首，第一个不是空白字符的位置</td>
</tr>
<tr>
<td align="center">$</td>
<td align="center"></td>
<td>行尾</td>
</tr>
</tbody></table>
<h4 id="3-行数移动"><a href="#3-行数移动" class="headerlink" title="3) 行数移动"></a>3) 行数移动</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">gg</td>
<td align="center">go</td>
<td>文件顶部</td>
</tr>
<tr>
<td align="center">G</td>
<td align="center">go</td>
<td>文件末尾</td>
</tr>
<tr>
<td align="center">数字gg</td>
<td align="center">go</td>
<td>移动到 数字 对应行数</td>
</tr>
<tr>
<td align="center">数字G</td>
<td align="center">go</td>
<td>移动到 数字 对应行数</td>
</tr>
<tr>
<td align="center">:数字</td>
<td align="center"></td>
<td>移动到 数字 对应行数</td>
</tr>
</tbody></table>
<h4 id="4-屏幕移动"><a href="#4-屏幕移动" class="headerlink" title="4) 屏幕移动"></a>4) 屏幕移动</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ctrl + b</td>
<td align="center">back</td>
<td>向上翻页</td>
</tr>
<tr>
<td align="center">Ctrl + f</td>
<td align="center">forward</td>
<td>向下翻页</td>
</tr>
<tr>
<td align="center">H</td>
<td align="center">Head</td>
<td>屏幕顶部</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">Middle</td>
<td>屏幕中间</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">Low</td>
<td>屏幕底部</td>
</tr>
</tbody></table>
<h3 id="4-2-移动（程序）"><a href="#4-2-移动（程序）" class="headerlink" title="4.2 移动（程序）"></a>4.2 移动（程序）</h3><h4 id="1-段落移动"><a href="#1-段落移动" class="headerlink" title="1) 段落移动"></a>1) 段落移动</h4><ul>
<li><code>vi</code> 中使用 空行 来区分段落</li>
<li>在程序开发时，通常 <strong>一段功能相关的代码会写在一起</strong> —— 之间没有空行</li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">{</td>
<td>上一段</td>
</tr>
<tr>
<td align="center">}</td>
<td>下一段</td>
</tr>
</tbody></table>
<h4 id="2-括号切换"><a href="#2-括号切换" class="headerlink" title="2) 括号切换"></a>2) 括号切换</h4><ul>
<li>在程序世界中，<code>()</code>、<code>[]</code>、<code>{}</code> 使用频率很高，而且 <strong>都是成对出现的</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%</td>
<td>括号匹配及切换</td>
</tr>
</tbody></table>
<h4 id="3-标记"><a href="#3-标记" class="headerlink" title="3) 标记"></a>3) 标记</h4><ul>
<li>在开发时，某一块代码可能<strong>需要稍后处理</strong>，例如：编辑、查看</li>
<li>此时先使用 <code>m</code> 增加一个标记，这样可以 <strong>在需要时快速地跳转回来</strong> 或者 <strong>执行其他编辑操作</strong></li>
<li><strong>标记名称</strong> 可以是 <code>a~z</code> 或者 <code>A~Z</code> 之间的任意 <strong>一个</strong> 字母</li>
<li>添加了标记的 <strong>行如果被删除</strong>，<strong>标记同时被删除</strong></li>
<li>如果 <strong>在其他行添加了相同名称的标记</strong>，<strong>之前添加的标记也会被替换掉</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mx</td>
<td align="center">mark</td>
<td>添加标记 x，x 是 a<del>z 或者 A</del>Z 之间的任意一个字母</td>
</tr>
<tr>
<td align="center">‘x</td>
<td align="center"></td>
<td>直接定位到标记 x 所在位置</td>
</tr>
</tbody></table>
<h3 id="4-3-选中文本（可视模式）"><a href="#4-3-选中文本（可视模式）" class="headerlink" title="4.3 选中文本（可视模式）"></a>4.3 选中文本（可视模式）</h3><ul>
<li>学习 <code>复制</code> 命令前，应该先学会 <strong>怎么样选中 要复制的代码</strong></li>
<li>在 <code>vi</code> 中要选择文本，需要先使用 <code>Visual</code> 命令切换到 <strong>可视模式</strong></li>
<li><code>vi</code> 中提供了 <strong>三种</strong> 可视模式，可以方便程序员选择 <strong>选中文本的方式</strong></li>
<li>按 <code>ESC</code> 可以放弃选中，返回到 <strong>命令模式</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th>模式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">v</td>
<td>可视模式</td>
<td>从光标位置开始按照正常模式选择文本</td>
</tr>
<tr>
<td align="center">V</td>
<td>可视行模式</td>
<td>选中光标经过的完整行</td>
</tr>
<tr>
<td align="center">Ctrl + v</td>
<td>可视块模式</td>
<td>垂直方向选中文本</td>
</tr>
</tbody></table>
<ul>
<li><strong>可视模式</strong>下，可以和 <strong>移动命令</strong> 连用，例如：<code>ggVG</code> 能够选中所有内容</li>
</ul>
<h3 id="4-4-撤销和恢复撤销"><a href="#4-4-撤销和恢复撤销" class="headerlink" title="4.4 撤销和恢复撤销"></a>4.4 撤销和恢复撤销</h3><ul>
<li>在学习编辑命令之前，先要知道怎样撤销之前一次 <strong>错误的</strong> 编辑动作！</li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u</td>
<td align="center">undo</td>
<td>撤销上次命令</td>
</tr>
<tr>
<td align="center">CTRL + r</td>
<td align="center">redo</td>
<td>恢复撤销的命令</td>
</tr>
</tbody></table>
<h3 id="4-5-删除文本"><a href="#4-5-删除文本" class="headerlink" title="4.5 删除文本"></a>4.5 删除文本</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x</td>
<td align="center">cut</td>
<td>删除光标所在字符，或者选中文字</td>
</tr>
<tr>
<td align="center">d(移动命令)</td>
<td align="center">delete</td>
<td>删除移动命令对应的内容</td>
</tr>
<tr>
<td align="center">dd</td>
<td align="center">delete</td>
<td>删除光标所在行，可以 ndd 复制多行</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">delete</td>
<td>删除至行尾</td>
</tr>
</tbody></table>
<blockquote>
<p>提示：如果使用 <strong>可视模式</strong> 已经选中了一段文本，那么无论使用 <code>d</code> 还是 <code>x</code>，都可以删除选中文本</p>
</blockquote>
<ul>
<li>删除命令可以和 <strong>移动命令</strong> 连用，以下是常见的组合命令：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* dw        # 从光标位置删除到单词末尾</span><br><span class="line">* d0        # 从光标位置删除到一行的起始位置</span><br><span class="line">* d&#125;        # 从光标位置删除到段落结尾</span><br><span class="line">* ndd       # 从光标位置向下连续删除 n 行</span><br><span class="line">* d代码行G   # 从光标所在行 删除到 指定代码行 之间的所有代码</span><br><span class="line">* d&#39;a       # 从光标所在行 删除到 标记a 之间的所有代码</span><br></pre></td></tr></table></figure>

<h3 id="4-6-复制、粘贴"><a href="#4-6-复制、粘贴" class="headerlink" title="4.6 复制、粘贴"></a>4.6 复制、粘贴</h3><ul>
<li><code>vi</code> 中提供有一个 <strong>被复制文本的缓冲区</strong><ul>
<li><strong>复制</strong> 命令会将选中的文字保存在缓冲区 </li>
<li><strong>删除</strong> 命令删除的文字会被保存在缓冲区</li>
<li>在需要的位置，使用 <strong>粘贴</strong> 命令可以将缓冲区的文字插入到光标所在位置</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">y(移动命令)</td>
<td align="center">copy</td>
<td>复制</td>
</tr>
<tr>
<td align="center">yy</td>
<td align="center">copy</td>
<td>复制一行，可以 nyy 复制多行</td>
</tr>
<tr>
<td align="center">p</td>
<td align="center">paste</td>
<td>粘贴</td>
</tr>
</tbody></table>
<p><strong>提示</strong></p>
<ul>
<li>命令 <code>d</code>、<code>x</code> 类似于图形界面的 <strong>剪切操作</strong> —— <code>CTRL + X</code></li>
<li>命令 <code>y</code> 类似于图形界面的 <strong>复制操作</strong> —— <code>CTRL + C</code></li>
<li>命令 <code>p</code> 类似于图形界面的 <strong>粘贴操作</strong> —— <code>CTRL + V</code></li>
<li><code>vi</code> 中的 <strong>文本缓冲区同样只有一个</strong>，如果后续做过 <strong>复制、剪切</strong> 操作，之前缓冲区中的内容会被替换</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li><code>vi</code> 中的 <strong>文本缓冲区</strong> 和系统的 <strong>剪贴板</strong> 不是同一个</li>
<li>所以在其他软件中使用 <code>CTRL + C</code> 复制的内容，不能在 <code>vi</code> 中通过 <code>P</code> 命令粘贴</li>
<li>可以在 <strong>编辑模式</strong> 下使用 <strong>鼠标右键粘贴</strong></li>
</ul>
<h3 id="4-7-替换"><a href="#4-7-替换" class="headerlink" title="4.7 替换"></a>4.7 替换</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
<th>工作模式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">r</td>
<td align="center">replace</td>
<td>替换当前字符</td>
<td>命令模式</td>
</tr>
<tr>
<td align="center">R</td>
<td align="center">replace</td>
<td>替换当前行光标后的字符</td>
<td>替换模式</td>
</tr>
</tbody></table>
<ul>
<li><code>R</code> 命令可以进入 <strong>替换模式</strong>，替换完成后，按下 <code>ESC</code> 可以回到 <strong>命令模式</strong></li>
<li><strong>替换命令</strong> 的作用就是不用进入 <strong>编辑模式</strong>，对文件进行 <strong>轻量级的修改</strong></li>
</ul>
<h3 id="4-8-缩排和重复执行"><a href="#4-8-缩排和重复执行" class="headerlink" title="4.8 缩排和重复执行"></a>4.8 缩排和重复执行</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&gt;&gt;</td>
<td>向右增加缩进</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td>向左减少缩进</td>
</tr>
<tr>
<td align="center">.</td>
<td>重复上次命令</td>
</tr>
</tbody></table>
<ul>
<li><strong>缩排命令</strong> 在开发程序时，<strong>统一增加代码的缩进</strong> 比较有用！<ul>
<li>一次性 <strong>在选中代码前增加 4 个空格</strong>，就叫做 <strong>增加缩进</strong></li>
<li>一次性 <strong>在选中代码前删除 4 个空格</strong>，就叫做 <strong>减少缩进</strong></li>
</ul>
</li>
<li>在 <strong>可视模式</strong> 下，缩排命令只需要使用 <strong>一个</strong> <code>&gt;</code> 或者 <code>&lt;</code> </li>
</ul>
<blockquote>
<p>在程序中，<strong>缩进</strong> 通常用来表示代码的归属关系</p>
<ul>
<li>前面空格越少，代码的级别越高</li>
<li>前面空格越多，代码的级别越低</li>
</ul>
</blockquote>
<h3 id="4-9-查找"><a href="#4-9-查找" class="headerlink" title="4.9 查找"></a>4.9 查找</h3><h4 id="常规查找"><a href="#常规查找" class="headerlink" title="常规查找"></a>常规查找</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">/str</td>
<td>查找 str</td>
</tr>
</tbody></table>
<ul>
<li>查找到指定内容之后，使用 <code>Next</code> 查找下一个出现的位置：<ul>
<li><code>n</code>: 查找下一个</li>
<li><code>N</code>: 查找上一个</li>
</ul>
</li>
<li>如果不想看到高亮显示，可以随便查找一个文件中不存在的内容即可</li>
</ul>
<h4 id="单词快速匹配"><a href="#单词快速匹配" class="headerlink" title="单词快速匹配"></a>单词快速匹配</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">*</td>
<td>向后查找当前光标所在单词</td>
</tr>
<tr>
<td align="center">#</td>
<td>向前查找当前光标所在单词</td>
</tr>
</tbody></table>
<ul>
<li>在开发中，通过单词快速匹配，可以快速看到这个单词在其他什么位置使用过</li>
</ul>
<h3 id="4-10-查找并替换"><a href="#4-10-查找并替换" class="headerlink" title="4.10 查找并替换"></a>4.10 查找并替换</h3><ul>
<li>在 <code>vi</code> 中查找和替换命令需要在 <strong>末行模式</strong> 下执行</li>
<li>记忆命令格式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:%s&#x2F;&#x2F;&#x2F;g</span><br></pre></td></tr></table></figure>

<h4 id="1-全局替换"><a href="#1-全局替换" class="headerlink" title="1) 全局替换"></a>1) 全局替换</h4><ul>
<li><strong>一次性</strong>替换文件中的 <strong>所有出现的旧文本</strong></li>
<li>命令格式如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:%s&#x2F;旧文本&#x2F;新文本&#x2F;g</span><br></pre></td></tr></table></figure>

<h4 id="2-可视区域替换"><a href="#2-可视区域替换" class="headerlink" title="2) 可视区域替换"></a>2) 可视区域替换</h4><ul>
<li><strong>先选中</strong> 要替换文字的 <strong>范围</strong></li>
<li>命令格式如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:s&#x2F;旧文本&#x2F;新文本&#x2F;g</span><br></pre></td></tr></table></figure>

<h4 id="3-确认替换"><a href="#3-确认替换" class="headerlink" title="3) 确认替换"></a>3) 确认替换</h4><ul>
<li>如果把末尾的 <code>g</code> 改成 <code>gc</code> 在替换的时候，会有提示！<strong>推荐使用！</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:%s&#x2F;旧文本&#x2F;新文本&#x2F;gc</span><br></pre></td></tr></table></figure>

<ol>
<li><code>y</code> - <code>yes</code> 替换</li>
<li><code>n</code> - <code>no</code> 不替换</li>
<li><code>a</code> - <code>all</code> 替换所有</li>
<li><code>q</code> - <code>quit</code> 退出替换</li>
<li><code>l</code> - <code>last</code> 最后一个，并把光标移动到行首</li>
<li><code>^E</code> 向下滚屏</li>
<li><code>^Y</code> 向上滚屏</li>
</ol>
<h3 id="4-11-插入命令"><a href="#4-11-插入命令" class="headerlink" title="4.11 插入命令"></a>4.11 插入命令</h3><ul>
<li>在 <code>vi</code> 中除了常用的 <code>i</code> 进入 <strong>编辑模式</strong> 外，还提供了以下命令同样可以进入编辑模式：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
<th align="center">常用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i</td>
<td align="center">insert</td>
<td>在当前字符前插入文本</td>
<td align="center">常用</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">insert</td>
<td>在行首插入文本</td>
<td align="center">较常用</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">append</td>
<td>在当前字符后添加文本</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">A</td>
<td align="center">append</td>
<td>在行末添加文本</td>
<td align="center">较常用</td>
</tr>
<tr>
<td align="center">o</td>
<td align="center"></td>
<td>在当前行后面插入一空行</td>
<td align="center">常用</td>
</tr>
<tr>
<td align="center">O</td>
<td align="center"></td>
<td>在当前行前面插入一空行</td>
<td align="center">常用</td>
</tr>
</tbody></table>
<p><img src="media/14993340485745/004_%E6%8F%92%E5%85%A5%E5%91%BD%E4%BB%A4.png" alt="004_插入命令-w400"></p>
<h4 id="演练-1-——-编辑命令和数字连用"><a href="#演练-1-——-编辑命令和数字连用" class="headerlink" title="演练 1 —— 编辑命令和数字连用"></a>演练 1 —— 编辑命令和数字连用</h4><ul>
<li>在开发中，可能会遇到连续输入 <code>N</code> 个同样的字符</li>
</ul>
<blockquote>
<p>在 <code>Python</code> 中有简单的方法，但是其他语言中通常需要自己输入</p>
</blockquote>
<ul>
<li>例如：<code>**********</code> 连续 10 个星号</li>
</ul>
<p>要实现这个效果可以在 <strong>命令模式</strong> 下</p>
<ol>
<li>输入 <code>10</code>，表示要重复 10 次</li>
<li>输入 <code>i</code> 进入 <strong>编辑模式</strong></li>
<li>输入 <code>*</code> 也就是重复的文字</li>
<li>按下 <code>ESC</code> 返回到 <strong>命令模式</strong>，返回之后 <code>vi</code> 就会把第 <code>2、3</code> 两步的操作重复 <code>10</code> 次</li>
</ol>
<blockquote>
<p>提示：正常开发时，在 <strong>进入编辑模式之前，不要按数字</strong></p>
</blockquote>
<h4 id="演练-2-——-利用-可视块-给多行代码增加注释"><a href="#演练-2-——-利用-可视块-给多行代码增加注释" class="headerlink" title="演练 2 —— 利用 可视块 给多行代码增加注释"></a>演练 2 —— 利用 可视块 给多行代码增加注释</h4><ul>
<li>在开发中，可能会遇到一次性给多行代码 <strong>增加注释</strong> 的情况</li>
</ul>
<blockquote>
<p>在 <code>Python</code> 中，要给代码增加注释，可以在代码前增加一个 <code>#</code></p>
</blockquote>
<p>要实现这个效果可以在 <strong>命令模式</strong> 下</p>
<ol>
<li>移动到要添加注释的 <strong>第 1 行代码</strong>，按 <code>^</code> 来到行首</li>
<li>按 <code>CTRL + v</code> 进入 <strong>可视块</strong> 模式</li>
<li>使用 <code>j</code> 向下连续选中要添加的代码行</li>
<li>输入 <code>I</code> 进入 <strong>编辑模式</strong>，并在 <strong>行首插入</strong>，注意：一定要使用 <strong>I</strong></li>
<li>输入 <code>#</code> 也就是注释符号</li>
<li>按下 <code>ESC</code> 返回到 <strong>命令模式</strong>，返回之后 <code>vi</code> 会在之前选中的每一行代码 <strong>前</strong> 插入 <code>#</code></li>
</ol>
<h2 id="05-分屏命令"><a href="#05-分屏命令" class="headerlink" title="05. 分屏命令"></a>05. 分屏命令</h2><ul>
<li>属于 <code>vi</code> 的高级命令 —— 可以 <strong>同时编辑和查看多个文件</strong></li>
</ul>
<h3 id="5-1-末行命令扩展"><a href="#5-1-末行命令扩展" class="headerlink" title="5.1 末行命令扩展"></a>5.1 末行命令扩展</h3><p><strong>末行命令</strong> 主要是针对文件进行操作的：<strong>保存</strong>、<strong>退出</strong>、<strong>保存&amp;退出</strong>、<strong>搜索&amp;替换</strong>、<strong>另存</strong>、<strong>新建</strong>、<strong>浏览文件</strong></p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">:e .</td>
<td align="center">edit</td>
<td>会打开内置的文件浏览器，浏览要当前目录下的文件</td>
</tr>
<tr>
<td align="center">:n 文件名</td>
<td align="center">new</td>
<td>新建文件</td>
</tr>
<tr>
<td align="center">:w 文件名</td>
<td align="center">write</td>
<td>另存为，但是仍然编辑当前文件，并不会切换文件</td>
</tr>
</tbody></table>
<blockquote>
<p>提示：切换文件之前，必须保证当前这个文件已经被保存！</p>
</blockquote>
<ul>
<li>已经学习过的 <strong>末行命令</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">:w</td>
<td align="center">write</td>
<td>保存</td>
</tr>
<tr>
<td align="center">:q</td>
<td align="center">quit</td>
<td>退出，如果没有保存，不允许退出</td>
</tr>
<tr>
<td align="center">:q!</td>
<td align="center">quit</td>
<td>强行退出，不保存退出</td>
</tr>
<tr>
<td align="center">:wq</td>
<td align="center">write &amp; quit</td>
<td>保存并退出</td>
</tr>
<tr>
<td align="center">:x</td>
<td align="center"></td>
<td>保存并退出</td>
</tr>
<tr>
<td align="center">:%s///gc</td>
<td align="center"></td>
<td>确认搜索并替换</td>
</tr>
</tbody></table>
<blockquote>
<p>在实际开发中，可以使用 <code>w</code> 命令 <strong>阶段性的备份代码</strong></p>
</blockquote>
<h3 id="5-2-分屏命令"><a href="#5-2-分屏命令" class="headerlink" title="5.2 分屏命令"></a>5.2 分屏命令</h3><ul>
<li>使用 <strong>分屏命令</strong>，可以 <strong>同时编辑和查看多个文件</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">:sp [文件名]</td>
<td align="center">split</td>
<td>横向增加分屏</td>
</tr>
<tr>
<td align="center">:vsp [文件名]</td>
<td align="center">vertical split</td>
<td>纵向增加分屏</td>
</tr>
</tbody></table>
<h4 id="1-切换分屏窗口"><a href="#1-切换分屏窗口" class="headerlink" title="1) 切换分屏窗口"></a>1) 切换分屏窗口</h4><blockquote>
<p>分屏窗口都是基于 <code>CTRL + W</code> 这个快捷键的，<code>w</code> 对应的英文单词是 <code>window</code></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">w</td>
<td align="center">window</td>
<td>切换到下一个窗口</td>
</tr>
<tr>
<td align="center">r</td>
<td align="center">reverse</td>
<td>互换窗口</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">close</td>
<td>关闭当前窗口，但是不能关闭最后一个窗口</td>
</tr>
<tr>
<td align="center">q</td>
<td align="center">quit</td>
<td>退出当前窗口，如果是最后一个窗口，则关闭 vi</td>
</tr>
<tr>
<td align="center">o</td>
<td align="center">other</td>
<td>关闭其他窗口</td>
</tr>
</tbody></table>
<h4 id="2-调整窗口大小"><a href="#2-调整窗口大小" class="headerlink" title="2) 调整窗口大小"></a>2) 调整窗口大小</h4><blockquote>
<p>分屏窗口都是基于 <code>CTRL + W</code> 这个快捷键的，<code>w</code> 对应的英文单词是 <code>window</code></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center"></td>
<td>增加窗口高度</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"></td>
<td>减少窗口高度</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center"></td>
<td>增加窗口宽度</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center"></td>
<td>减少窗口宽度</td>
</tr>
<tr>
<td align="center">=</td>
<td align="center"></td>
<td>等分窗口大小</td>
</tr>
</tbody></table>
<blockquote>
<p>调整窗口宽高的命令可以和数字连用，例如：<code>5 CTRL + W +</code> 连续 5 次增加高度</p>
</blockquote>
<h2 id="06-常用命令速查图"><a href="#06-常用命令速查图" class="headerlink" title="06. 常用命令速查图"></a>06. 常用命令速查图</h2><p><img src="media/14993340485745/vim.png" alt="vi"></p>
<h3 id="vimrc"><a href="#vimrc" class="headerlink" title="vimrc"></a>vimrc</h3><ul>
<li><code>vimrc</code> 是 <code>vim</code> 的配置文件，可以设置 vim 的配置，包括：<strong>热键</strong>、<strong>配色</strong>、<strong>语法高亮</strong>、<strong>插件</strong> 等</li>
<li><code>Linux</code> 中 <code>vimrc</code> 有两个位置，<strong>家目录下的配置文件优先级更高</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;vim&#x2F;vimrc</span><br><span class="line">~&#x2F;.vimrc</span><br></pre></td></tr></table></figure>

<ul>
<li>常用的插件有：<ul>
<li>代码补全</li>
<li>代码折叠</li>
<li>搜索</li>
<li>Git 集成</li>
<li>……</li>
</ul>
</li>
<li>网上有很多高手已经配置好的针对 <code>python</code> 开发的 <code>vimrc</code> 文件，可以下载过来直接使用，或者等大家多 <code>Linux</code> 比较熟悉后，再行学习！</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>时序图语法</title>
    <url>/2020/02/04/%E6%97%B6%E5%BA%8F%E5%9B%BE%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p><a href="http://archive.3zso.com/archives/plantuml-quickstart.html#sec-5-4-1" target="_blank" rel="noopener">使用Emacs敲出UML，PlantUML快速指南</a><br><a href="https://blog.csdn.net/junhuahouse/article/details/80753374" target="_blank" rel="noopener">PlantUML 之时序图</a>  </p>
<h3 id="顺序图（Sequence-Diagram）"><a href="#顺序图（Sequence-Diagram）" class="headerlink" title="顺序图（Sequence Diagram）"></a>顺序图（Sequence Diagram）</h3><p>简单示例<br>顺序图用 -&gt; , –&gt;, &lt;-, &lt;– 来绘制参与者（Participants）之 间的消息（Message）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">hide footbox</span><br><span class="line">title login by token</span><br><span class="line"></span><br><span class="line">  Alice -&gt; Bob: Authentication Request</span><br><span class="line">  Bob --&gt; Alice: Authentication Response</span><br><span class="line"></span><br><span class="line">  Alice -&gt; Bob: Another atuhentication Request</span><br><span class="line">  Alice &lt;-- Bob: Another authentication Response</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p><img src="http://archive.3zso.com/img/plantuml-quickstart-s1.png" alt="image"></p>
<h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><p>分为行注解使用英文符号 ‘+行内容<br>多行注解使用英文符号/‘ + 内容 + ‘/ </p>
<h3 id="申明参与者"><a href="#申明参与者" class="headerlink" title="申明参与者"></a>申明参与者</h3><p>申明参与者，可以使用 participant 关键词，也可以使用下面的参与者   分类关键词来申明参与者：  </p>
<ul>
<li>actor</li>
<li>boundary</li>
<li>control</li>
<li>entity</li>
<li>database  </li>
</ul>
<p><strong>不同的参与者类型，其图标也是不一样的</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">hide footbox</span><br><span class="line">actor actor #red</span><br><span class="line">boundary boundary #yellow</span><br><span class="line">control control #blue</span><br><span class="line">entity entity #green</span><br><span class="line">database database #EE4000</span><br><span class="line">&quot;学术袁&quot; -&gt; Blog :方形</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p><img src="http://archive.3zso.com/img/plantuml-quickstart-s2.png" alt="image"></p>
<p>使用 as 关键词可以为参与者起一个别名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">participant &quot;I have a really\nlong name&quot; as L #99ff99</span><br></pre></td></tr></table></figure>
<h3 id="改变箭头的样式（Change-arrow-style）"><a href="#改变箭头的样式（Change-arrow-style）" class="headerlink" title="改变箭头的样式（Change arrow style）"></a>改变箭头的样式（Change arrow style）</h3><p>在用例图里可以通过以下方式来改变箭头的样式：</p>
<p>使用 \ 或 / 来替换 &lt; 或 &gt; 可以让箭头只显示上半部分或下半 部分。<br>重复输入箭头或斜杠（ &gt;&gt; // ），用来绘制空心箭头。<br>使用双横线 – 替代 - 可以用来绘制点线。<br>在箭头后面加个 o 可以在箭头前绘制一个圆圈。<br>使用 &lt;-&gt; 可用来绘制双向箭头。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bob -&gt; Alice</span><br><span class="line">Bob -&gt;&gt; Alice</span><br><span class="line">Bob -\ Alice</span><br><span class="line">Bob \\- Alice</span><br><span class="line">Bob &#x2F;&#x2F;-- Alice</span><br><span class="line"></span><br><span class="line">Bob -&gt;o Alice</span><br><span class="line">Bob o\\-- Alice</span><br><span class="line"></span><br><span class="line">Bob &lt;-&gt; Alice</span><br><span class="line">Bob &lt;&lt;-\\o Alice</span><br></pre></td></tr></table></figure>
<p><img src="http://archive.3zso.com/img/plantuml-quickstart-s6.png" alt="image"></p>
<h3 id="改变箭头的颜色（Change-arrow-color）"><a href="#改变箭头的颜色（Change-arrow-color）" class="headerlink" title="改变箭头的颜色（Change arrow color）"></a>改变箭头的颜色（Change arrow color）</h3><p>要改变箭头的颜色，可以使用HTML颜色符号，参看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bob -[#red]&gt; Alice : hello</span><br><span class="line"> Alice -[#0000FF]-&gt;Bob : ok</span><br></pre></td></tr></table></figure>
<p><img src="http://archive.3zso.com/img/plantuml-quickstart-s7.png" alt="image"></p>
<h3 id="消息序号（Message-sequence-numbering）"><a href="#消息序号（Message-sequence-numbering）" class="headerlink" title="消息序号（Message sequence numbering）"></a>消息序号（Message sequence numbering）</h3><p>关键词 autonumber 用来给自动的给消息添加上序号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">autonumber</span><br><span class="line"> Bob -&gt; Alice : Authentication Request</span><br><span class="line"> Bob &lt;- Alice : Authentication Response</span><br><span class="line"></span><br><span class="line"> autonumber 15</span><br><span class="line"> Bob -&gt; Alice : Another authentication Request</span><br><span class="line"> Bob &lt;- Alice : Another authentication Response</span><br><span class="line"></span><br><span class="line"> autonumber 40 10</span><br><span class="line"> Bob -&gt; Alice : Yet another authentication Request</span><br><span class="line"> Bob &lt;- Alice : Yet another authentication Response</span><br></pre></td></tr></table></figure>
<p><img src="http://archive.3zso.com/img/plantuml-quickstart-s9.png" alt="image"></p>
<h3 id="标题（Title）"><a href="#标题（Title）" class="headerlink" title="标题（Title）"></a>标题（Title）</h3><p>要给图形加一个标题可以用 title 关键词来设置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title Simple Comunication example</span><br></pre></td></tr></table></figure>
<p><img src="http://archive.3zso.com/img/plantuml-quickstart-s11.png" alt="image"></p>
<h3 id="消息分组（Grouping-message）"><a href="#消息分组（Grouping-message）" class="headerlink" title="消息分组（Grouping message）"></a>消息分组（Grouping message）</h3><p>有时候可能需要对消息进行分组，那么可以使用下面的关键词来实现：</p>
<ul>
<li>alt/else</li>
<li>opt</li>
<li>loop</li>
<li>par</li>
<li>break</li>
<li>critical</li>
<li>group<br>这个关键词后面的文字会作为组名显示在图形上<br>上面的关键词后可以添加一些文本用来显示在头部（注： group 除外，因 为它后面的文本用来显示在组名称的位置）。在组嵌套组的结构里可以用关 键词 end 来关闭组或者说是表示一个组符号的结束符（类似 if/endif ）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alice -&gt; Bob: Authentication Request</span><br><span class="line"></span><br><span class="line"> alt successful case</span><br><span class="line">   Bob -&gt; Alice: Authentication Accepted</span><br><span class="line"> else some kind of failure</span><br><span class="line">   Bob -&gt; Alice: Atuhentication Failue</span><br><span class="line">   group My own label</span><br><span class="line">     Alice -&gt; Log : Log attack start</span><br><span class="line">     loop 1000 times</span><br><span class="line">       Alice -&gt; Bob: DNS Attack</span><br><span class="line">     end</span><br><span class="line">     Alice -&gt; Log : Loag alice end</span><br><span class="line">   end</span><br><span class="line"> else Another type of failue</span><br><span class="line">   Bob -&gt; Alice: Please repeat</span><br><span class="line"> end</span><br></pre></td></tr></table></figure>
<p><img src="http://archive.3zso.com/img/plantuml-quickstart-s14.png" alt="image"></p>
<h3 id="消息注解（Notes-on-messages）"><a href="#消息注解（Notes-on-messages）" class="headerlink" title="消息注解（Notes on messages）"></a>消息注解（Notes on messages）</h3><p>我们可能经常会在消息的左边或右边使用注解，要添加注解，只要使用 note left 或 note right 关键词就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alice -&gt; Bob : hello</span><br><span class="line">  note left: this is a first note</span><br><span class="line"></span><br><span class="line">  Bob -&gt; Alice : ok</span><br><span class="line">  note right: this is anther note</span><br><span class="line"></span><br><span class="line">  Bob -&gt; Bob : I am thinking</span><br><span class="line">  note left</span><br><span class="line">       a note</span><br><span class="line">       can also be defined</span><br><span class="line">       on several lines</span><br><span class="line">  end note</span><br></pre></td></tr></table></figure>
<p><img src="http://archive.3zso.com/img/plantuml-quickstart-s15.png" alt="image"></p>
<h3 id="一些其他的注解方式（Some-other-notes）"><a href="#一些其他的注解方式（Some-other-notes）" class="headerlink" title="一些其他的注解方式（Some other notes）"></a>一些其他的注解方式（Some other notes）</h3><p>通过使用关键词 note left of ， note right of 或 note over ， 我们还可以把注解放置在与之相关的参与者的左边或右边，或下方。</p>
<p>通过改变注解的背景色，我们还可以高亮一个注解文本块。</p>
<p>如果要使用多行注解，可以使用关键词 end note 来表示注解的结束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">participant Alice</span><br><span class="line"> participant Bob</span><br><span class="line"> note left of Alice #aqua</span><br><span class="line">      This is displayed</span><br><span class="line">      left of Alice.</span><br><span class="line"> end note</span><br><span class="line"></span><br><span class="line"> note right of Alice: This is displayed right of Alice.</span><br><span class="line"></span><br><span class="line"> note over Alice: This displayed over Alice.</span><br><span class="line"></span><br><span class="line"> note over Alice, Bob #FFAAAA: This is displayed\n over Bob and Alice.</span><br><span class="line"></span><br><span class="line"> note over Bob, Alice</span><br><span class="line">      This is yet another</span><br><span class="line">      example of</span><br><span class="line">      a long note.</span><br><span class="line"> end note</span><br></pre></td></tr></table></figure>
<p><img src="http://archive.3zso.com/img/plantuml-quickstart-s16.png" alt="image"></p>
<h3 id="使用HTML进行格式化（Formatting-using-HTML）"><a href="#使用HTML进行格式化（Formatting-using-HTML）" class="headerlink" title="使用HTML进行格式化（Formatting using HTML）"></a>使用HTML进行格式化（Formatting using HTML）</h3><p>我们可以使用少量的HTML标签来格式化文本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;b&gt; 加粗文本</span><br><span class="line">&lt;u&gt; 或 &lt;u:#AAAAAA&gt; 或 &lt;u:colorName&gt; 用来加下划线</span><br><span class="line">&lt;i&gt; 斜体</span><br><span class="line">&lt;s&gt; 或 &lt;s:#AAAAAA&gt; 或 &lt;s:colorName&gt; 用来加删除线</span><br><span class="line">&lt;w&gt; 或 &lt;w:#AAAAAA&gt; 或 &lt;w:colorName&gt; 用来加波浪线</span><br><span class="line">&lt;color:#AAAAAA&gt; 或 &lt;color:colorName&gt; 用来设置文本颜色</span><br><span class="line">&lt;back:#AAAAAA&gt; 或 &lt;back:colorName&gt; 用来设置背景色</span><br><span class="line">&lt;size:nn&gt; 设置字体大小</span><br><span class="line">&lt;img src&#x3D;&quot;file&quot;&gt; 或 &lt;img:file&gt; 用来添加图片，图片文件必须 是可以访问得到才行。</span><br><span class="line">&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;url&quot;&gt; 或 &lt;img:http:&#x2F;&#x2F;url&gt; 用来添加一个互 联网图片，同样的图片地址必须是可用的才行。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">participant Alice</span><br><span class="line"> participant &quot;The &lt;b&gt;Famous&lt;&#x2F;b&gt; Bob&quot; as Bob</span><br><span class="line"></span><br><span class="line"> Alice -&gt; Bob : A &lt;i&gt;well formated&lt;&#x2F;i&gt; message</span><br><span class="line"> note right of Alice</span><br><span class="line">   This is &lt;back:cadetblue&gt;&lt;size:18&gt;displayed&lt;&#x2F;size&gt;&lt;&#x2F;back&gt;</span><br><span class="line">   &lt;u&gt;left of&lt;&#x2F;u&gt; Alice.</span><br><span class="line"> end note</span><br><span class="line"> note left of Bob</span><br><span class="line">   &lt;u:red&gt;This&lt;&#x2F;u&gt; is &lt;color #118888&gt;displayed&lt;&#x2F;color&gt;</span><br><span class="line">   &lt;b&gt;&lt;color purple&gt;left of&lt;&#x2F;color&gt; &lt;s:red&gt;Alice&lt;&#x2F;strike&gt; Bob&lt;&#x2F;b&gt;</span><br><span class="line"> end note</span><br><span class="line"> note over Alice, Bob</span><br><span class="line">   &lt;w:#FF33FF&gt;This is hosted&lt;&#x2F;w&gt; by &lt;img ..&#x2F;img&#x2F;code.png&gt;</span><br><span class="line"> end note</span><br></pre></td></tr></table></figure>
<p><img src="http://archive.3zso.com/img/plantuml-quickstart-s17.png" alt="image"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>UML</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>使用wpa_supplicant, wpa_cli连接wifi</title>
    <url>/2020/01/04/%E4%BD%BF%E7%94%A8wpa_supplicant%20wpa_cli%E8%BF%9E%E6%8E%A5wifi/</url>
    <content><![CDATA[<p>WIFI on:</p>
<p>adb shell svc wifi enable</p>
<p>WIFI off:</p>
<p>adb shell svc wifi disable</p>
<p><a href="http://blog.sina.com.cn/s/blog_15e89db360102x7qv.html" target="_blank" rel="noopener">使用wpa_supplicant, wpa_cli连接wifi</a></p>
<p>如果对应的命令没有需要从源码编译后，导入到/system/bin目录下，修改权限755<br>dhcpcd目录 \external\dhcpcd-6.8.2<br>wpa_cli  \external\wpa_supplicant_8 编译后会生成该文件  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpa_supplicant.conf目录  </span><br><span class="line">&#x2F;data&#x2F;misc&#x2F;wifi&#x2F;wpa_supplicant.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#&#x2F;system&#x2F;bin&#x2F;sh</span><br><span class="line">ssid&#x3D;$&#123;1&#125;</span><br><span class="line">psk&#x3D;$&#123;2&#125;</span><br><span class="line">svc wifi enable</span><br><span class="line">sleep 6</span><br><span class="line">wpa_cli scan</span><br><span class="line">wpa_cli scan_result</span><br><span class="line">addID&#x3D;&#96;wpa_cli add_net | sed -n &#39;2p&#39;&#96;</span><br><span class="line"></span><br><span class="line">echo $addID</span><br><span class="line">wpa_cli set_net $&#123;addID&#125; ssid &quot;\&quot;$&#123;ssid&#125;\&quot;&quot;</span><br><span class="line">wpa_cli set_net $&#123;addID&#125; psk &quot;\&quot;$&#123;psk&#125;\&quot;&quot;</span><br><span class="line">wpa_cli select_net $&#123;addID&#125;</span><br><span class="line">wpa_cli enable_net $&#123;addID&#125;</span><br><span class="line"></span><br><span class="line">dhcpcd wlan0</span><br></pre></td></tr></table></figure>

<p>debug WifiStateMachine 程序需要debug system process进程</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统源码</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓系统签名转keystore</title>
    <url>/2019/10/18/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E7%AD%BE%E5%90%8D%E8%BD%ACkeystore/</url>
    <content><![CDATA[<p> 单独签名解决方案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">找到平台签名文件“platform.pk8”和“platform.x509.pem”</span><br><span class="line"></span><br><span class="line">文件位置 android&#x2F;build&#x2F;target&#x2F;product&#x2F;security&#x2F;</span><br></pre></td></tr></table></figure>




<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">签名工具“signapk.jar”</span><br><span class="line"></span><br><span class="line">位置：android&#x2F;prebuilts&#x2F;sdk&#x2F;tools&#x2F;lib</span><br></pre></td></tr></table></figure>




<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">签名证书“platform.pk8 ”“platform.x509.pem ”，签名工具“signapk.jar ”放置在同一个文件夹；</span><br></pre></td></tr></table></figure>

<p> 下载 keytool-importkeypair 工具，使用sdk的security文件生成对应平台的key：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;keytool-importkeypair -k [jks文件名] -p [jks的密码] -pk8 platform.pk8 -cert platform.x509.pem -alias [jks的别名]</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line">.&#x2F;keytool-importkeypair -k .&#x2F;SignDemo.jks -p 123456 -pk8 platform.pk8 -cert platform.x509.pem -alias SignDemo</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统源码</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2019/07/16/%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方 法，而&lt;? super T&gt;不能使用 get 方法，作为接口调用赋值时易出错。<br>说明：扩展说一下 PECS(Producer Extends Consumer Super)原则：第一、频繁往外读取内<br>容的，适合用&lt;? extends T&gt;。第二、经常往里插入的，适合用&lt;? super T&gt;。</p>
<h5 id="泛型类的最基本写法"><a href="#泛型类的最基本写法" class="headerlink" title="泛型类的最基本写法"></a>泛型类的最基本写法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123;</span><br><span class="line">  private 泛型标识 &#x2F;*（成员变量类型）*&#x2F; var; </span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个最普通的泛型类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br><span class="line">&#x2F;&#x2F;在实例化泛型类时，必须指定T的具体类型</span><br><span class="line">public class Generic&lt;T&gt;&#123; </span><br><span class="line">    &#x2F;&#x2F;key这个成员变量的类型为T,T的类型由外部指定  </span><br><span class="line">    private T key;</span><br><span class="line"></span><br><span class="line">    public Generic(T key) &#123; &#x2F;&#x2F;泛型构造方法形参key的类型也为T，T的类型由外部指定</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getKey()&#123; &#x2F;&#x2F;泛型方法getKey的返回值类型为T，T的类型由外部指定</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span><br><span class="line">&#x2F;&#x2F;传入的实参类型需与泛型的类型参数类型相同，即为Integer.</span><br><span class="line">Generic&lt;Integer&gt; genericInteger &#x3D; new Generic&lt;Integer&gt;(123456);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;传入的实参类型需与泛型的类型参数类型相同，即为String.</span><br><span class="line">Generic&lt;String&gt; genericString &#x3D; new Generic&lt;String&gt;(&quot;key_vlaue&quot;);</span><br><span class="line">Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericInteger.getKey());</span><br><span class="line">Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericString.getKey());</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意：</span><br><span class="line"></span><br><span class="line">泛型的类型参数只能是类类型，不能是简单类型。</span><br><span class="line">不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。</span><br><span class="line"></span><br><span class="line">if(ex_num instanceof Generic&lt;Number&gt;)&#123;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个泛型接口</span><br><span class="line">public interface Generator&lt;T&gt; &#123;</span><br><span class="line">    public T next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当实现泛型接口的类，未传入泛型实参时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span><br><span class="line"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span><br><span class="line"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public T next() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当实现泛型接口的类，传入泛型实参时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 传入泛型实参时：</span><br><span class="line"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span><br><span class="line"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span><br><span class="line"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span><br><span class="line"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class FruitGenerator implements Generator&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private String[] fruits &#x3D; new String[]&#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String next() &#123;</span><br><span class="line">        Random rand &#x3D; new Random();</span><br><span class="line">        return fruits[rand.nextInt(3)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T这个T可以出现在这个泛型方法的任意位置.</span><br><span class="line">泛型的数量也可以为任意多个如：</span><br><span class="line">public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span><br><span class="line">             ...</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛型方法与可变参数"><a href="#泛型方法与可变参数" class="headerlink" title="泛型方法与可变参数"></a>泛型方法与可变参数</h4><p>泛型方法和可变参数的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printMsg</span><span class="params">( T... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(T t : args)&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"t is "</span> + t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printMsg(<span class="string">"111"</span>,<span class="number">222</span>,<span class="string">"aaaa"</span>,<span class="string">"2323.4"</span>,<span class="number">55.55</span>);</span><br></pre></td></tr></table></figure>
<h4 id="静态方法与泛型"><a href="#静态方法与泛型" class="headerlink" title="静态方法与泛型"></a>静态方法与泛型</h4><p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：==静态方法无法访问类上定义的泛型==；<br>如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。<br>即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticGenerator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span></span><br><span class="line"><span class="comment">     * 即使静态方法要使用泛型类中已经声明过的泛型也不行。</span></span><br><span class="line"><span class="comment">     * 如：public static void show(T t)&#123;..&#125;,</span></span><br><span class="line"><span class="comment">     *此时编译器会提示错误信息：</span></span><br><span class="line"><span class="comment">     *  "StaticGenerator cannot be refrenced from *static context"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型上下边界"><a href="#泛型上下边界" class="headerlink" title="泛型上下边界"></a>泛型上下边界</h3><h5 id="泛型类的例子"><a href="#泛型类的例子" class="headerlink" title="泛型类的例子"></a>泛型类的例子</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="泛型方法的例子："><a href="#泛型方法的例子：" class="headerlink" title="泛型方法的例子："></a>泛型方法的例子：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加</span></span><br><span class="line"><span class="comment">//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错："Unexpected bound"</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">    T test = container.getKey();</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛型方法的类型推断"><a href="#泛型方法的类型推断" class="headerlink" title="泛型方法的类型推断"></a>泛型方法的类型推断</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**不指定泛型的时候*/</span>  </span><br><span class="line"> <span class="keyword">int</span> i=Test.add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//这两个参数都是Integer，所以T替换为Integer类型  </span></span><br><span class="line">Number f=Test.add(<span class="number">1</span>, <span class="number">1.2</span>);<span class="comment">//这两个参数一个是Integer，另一个是Float，所以取同一父类的最小级，为Number  </span></span><br><span class="line">Object o=Test.add(<span class="number">1</span>, <span class="string">"asd"</span>);<span class="comment">//这两个参数一个是Integer，另一个是String，所以取同一父类的最小级，为Object</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/**指定泛型的时候*/</span>  </span><br><span class="line"><span class="keyword">int</span> a=Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//指定了Integer，所以只能为Integer类型或者其子类  </span></span><br><span class="line"><span class="keyword">int</span> b=Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2.2</span>);<span class="comment">//编译错误，指定了Integer，不能为Float  </span></span><br><span class="line">Number c=Test.&lt;Number&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//指定为Number，所以可以为Integer和Float  </span></span><br><span class="line">      </span><br><span class="line"><span class="comment">//这是一个简单的泛型方法  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">add</span><span class="params">(T x,T y)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> y;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>编译期间，所有的泛型信息都会被擦除,List<Integer>和List<String>类型，在编译后都会变成List类型（原始类型）.  </p>
<h5 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h5><p>原始类型就是泛型类型擦除了泛型信息后，在字节码中真正的类型。无论何时定义一个泛型类型，相应的原始类型都会被自动提供。原始类型的名字就是删去类型参数后的泛型类型的类名。擦除类型变量，并替换为限定类型（T为无限定的类型变量，用Object替换）<br><strong>因为在Pair<T>中，T是一个无限定的类型变量，所以用Object替换。<br>如果是Pair<T extends Number>，擦除后，类型变量用Number类型替换</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; array=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">array.add(<span class="number">1</span>);<span class="comment">//这样调用add方法只能存储整形，因为泛型类型的实例为Integer  </span></span><br><span class="line">array.getClass().getMethod("add", Object.class).invoke(array, "asd");  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.size();i++) &#123;  </span><br><span class="line">    System.out.println(array.get(i));  </span><br><span class="line">    &#125;  </span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span></span><br><span class="line">asd</span><br></pre></td></tr></table></figure>

<h2 id="PECS法则"><a href="#PECS法则" class="headerlink" title="PECS法则"></a>PECS法则</h2><p>PECS法则：生产者（Producer）使用extends，消费者（Consumer）使用super</p>
<h6 id="1、生产者"><a href="#1、生产者" class="headerlink" title="1、生产者"></a>1、生产者</h6><p>如果你需要一个提供E类型元素的集合，使用泛型通配符&lt;? extends E&gt;。它好比一个生产者，可以提供数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Number&gt; list&#x3D;new ArrayList();</span><br><span class="line">list.add(new Integer(1));&#x2F;&#x2F;编译错误</span><br><span class="line">list.add(new Float(1.0));&#x2F;&#x2F;编译错误</span><br><span class="line"></span><br><span class="line">List&lt;? extends Number&gt; list1&#x3D;new ArrayList&lt;Integer&gt;();</span><br><span class="line">List&lt;? extends Number&gt; list2&#x3D;new ArrayList&lt;Float&gt;();</span><br></pre></td></tr></table></figure>

<h5 id="2、消费者"><a href="#2、消费者" class="headerlink" title="2、消费者"></a>2、消费者</h5><p>如果你需要一个只能装入E类型元素的集合，使用泛型通配符&lt;? super E&gt;。它好比一个消费者，可以消费你提供的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;? super Number&gt; list&#x3D;new ArrayList(); </span><br><span class="line">list.add(new Integer(1));</span><br><span class="line">list.add(new Float(1.1));</span><br></pre></td></tr></table></figure>

<h5 id="3、既是生产者也是消费者"><a href="#3、既是生产者也是消费者" class="headerlink" title="3、既是生产者也是消费者"></a>3、既是生产者也是消费者</h5><p>既要存储又要读取，那就别使用泛型通配符。</p>
<h2 id="泛型相关问题"><a href="#泛型相关问题" class="headerlink" title="泛型相关问题"></a>泛型相关问题</h2><h4 id="1、泛型类型引用传递问题"><a href="#1、泛型类型引用传递问题" class="headerlink" title="1、泛型类型引用传递问题"></a>1、泛型类型引用传递问题</h4><p>在Java中，像下面形式的引用传递是不允许的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList1=<span class="keyword">new</span> ArrayList&lt;Object&gt;();<span class="comment">//编译错误  </span></span><br><span class="line">ArrayList&lt;Object&gt; arrayList1=<span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>
<h6 id="第一种情况，将第一种情况拓展成下面的形式："><a href="#第一种情况，将第一种情况拓展成下面的形式：" class="headerlink" title="第一种情况，将第一种情况拓展成下面的形式："></a>第一种情况，将第一种情况拓展成下面的形式：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; arrayList1=<span class="keyword">new</span> ArrayList&lt;Object&gt;();  </span><br><span class="line">          arrayList1.add(<span class="keyword">new</span> Object());  </span><br><span class="line">          arrayList1.add(<span class="keyword">new</span> Object());  </span><br><span class="line">          ArrayList&lt;String&gt; arrayList2=arrayList1;<span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>

<p>在第4行代码处，就会有编译错误。那么，先假设它编译没错。那么当我们使用arrayList2引用用get()方法取值的时候，返回的都是String类型的对象，可是它里面实际上已经存放了Object类型的对象，这样，就会有ClassCastException了。  </p>
<h6 id="在看第二种情况，将第二种情况拓展成下面的形式："><a href="#在看第二种情况，将第二种情况拓展成下面的形式：" class="headerlink" title="在看第二种情况，将第二种情况拓展成下面的形式："></a>在看第二种情况，将第二种情况拓展成下面的形式：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList1=<span class="keyword">new</span> ArrayList&lt;String&gt;();  </span><br><span class="line">          arrayList1.add(<span class="keyword">new</span> String());  </span><br><span class="line">          arrayList1.add(<span class="keyword">new</span> String());  </span><br><span class="line">          ArrayList&lt;Object&gt; arrayList2=arrayList1;<span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>
<p>这样的情况比第一种情况好的多，最起码，用arrayList2取值的时候不会出现ClassCastException，因为是从String转换为Object。可是，这样做有什么意义呢，泛型出现的原因，就是为了解决类型转换的问题。我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以java不允许这么干。再说，如果又用arrayList2往里面add()新的对象，那么到时候取得时候，我怎么知道我取出来的到底是String类型的，还是Object类型的呢？<br>所以，要格外注意泛型中引用传递问题。</p>
<h4 id="2、泛型类型变量不能是基本数据类型"><a href="#2、泛型类型变量不能是基本数据类型" class="headerlink" title="2、泛型类型变量不能是基本数据类型"></a>2、泛型类型变量不能是基本数据类型</h4><p>比如，没有ArrayList<double>，只有ArrayList<Double>。因为当类型擦除后，ArrayList的原始类中的类型变量（T）替换为Object，但Object类型不能存储double值.</p>
<h4 id="3、运行时类型查询"><a href="#3、运行时类型查询" class="headerlink" title="3、运行时类型查询"></a>3、运行时类型查询</h4><p>举个例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<p>因为类型擦除之后，ArrayList<String>只剩下原始类型，泛型信息String不存在了。那么，运行时进行类型查询的时候使用下面的方法是错误的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( arrayList <span class="keyword">instanceof</span> ArrayList&lt;String&gt;)</span><br></pre></td></tr></table></figure>
<p>java限定了这种类型查询的方式，？为通配符，也即非限定符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( arrayList <span class="keyword">instanceof</span> ArrayList&lt;?&gt;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>基础语法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>程序运行时，内存到底是如何进行分配的</title>
    <url>/2019/04/04/%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%8C%E5%86%85%E5%AD%98%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E9%85%8D%E7%9A%84/</url>
    <content><![CDATA[<h3 id="JVM-中的内存划分"><a href="#JVM-中的内存划分" class="headerlink" title="JVM 中的内存划分"></a>JVM 中的内存划分</h3><p>JVM 中的内存可以划分为若干个不同的数据区域，主要分为：程序计数器、虚拟机栈、本地方法栈、堆、方法区。</p>
<p>线程私有数据区：程序计数器、虚拟机栈、本地方法栈；</p>
<p>线程共有数据区：堆、方法区；</p>
<p>下面的图可以概况本章内容</p>
<p><img src="https://s0.lgstatic.com/i/image3/M01/02/8D/Ciqah157GD2AYLFtAADxheNgCA0454.png" alt=""></p>
<h4 id="程序计数器（ProgramCounterRegister）"><a href="#程序计数器（ProgramCounterRegister）" class="headerlink" title="程序计数器（ProgramCounterRegister）"></a>程序计数器（ProgramCounterRegister）</h4><p>Java程序是多线程的，CPU可以在多个线程中分配执行时间片段。当某一个线程被CPU挂起时，需要记录代码已经执行到的位置，方便 CPU 重新执行此线程时，知道从哪行指令开始执行。这就是程序计数器的作用。</p>
<p>程序计数器”是虚拟机中一块较小的内存空间，主要用于记录当前线程执行的位置。</p>
<p>关于程序计数器还有几点<strong>需要格外注意</strong>：</p>
<p>在 Java 虚拟机规范中，对程序计数器这一区域没有规定任何 OutOfMemoryError 情况（或许是感觉没有必要吧）。</p>
<p>程序计数器是线程私有的，每条线程内部都有一个私有程序计数器。它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
<p>当一个线程正在执行一个 Java 方法的时候，这个计数器记录的是正在执行的虚拟机字节码指令的地址。如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。</p>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>虚拟机栈也是线程私有的，与线程的生命周期同步。在 Java 虚拟机规范中，对这个区域规定了两种异常状况：</p>
<ol>
<li>StackOverflowError：当线程请求栈深度超出虚拟机栈所允许的深度时抛出</li>
<li>OutOfMemoryError：当Java虚拟机动态扩展到无法申请足够内存时抛出。</li>
</ol>
<p>JVM 是基于栈的解释器执行的，DVM 是基于寄存器解释器执行的。</p>
<p>上面这句话里的“基于栈”指的就是虚拟机栈。虚拟机栈的初衷是用来描述 Java 方法执行的内存模型，每个方法被执行的时候，JVM 都会在虚拟机栈中创建一个栈帧。</p>
<h5 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h5><p>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，每一个线程在执行某个方法时，都会为这个方法创建一个栈帧。一个线程包含多个栈帧，而每个栈帧内部包含局部变量表、操作数栈、动态连接、返回地址等。</p>
<h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><p>本地方法栈和上面介绍的虚拟栈基本相同，只不过是针对本地（native）方法。在开发中如果涉及JNI可能接触本地方法栈多一些。</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>Java堆（Heap）是JVM所管理的内存中最大的一块，该区域唯一目的就是存放对象实例，几乎所有对象的实例都在堆里面分配，因此它也是Java垃圾收集器（GC）管理的主要区域，有时候也叫作“GC 堆”（关于堆的 GC 回收机制将会在后续课时中做详细介绍）。同时它也是所有线程共享的内存区域，因此被分配在此区域的对象如果被多个线程访问的话，需要考虑线程安全问题。</p>
<p>按照对象存储时间的不同，堆中的内存可以划分为新生代（Young）和老年代（Old），其中新生代又被划分为 Eden 和 Survivor 区。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区（MethodArea）也是JVM规范里规定的一块运行时数据区。方法区主要是存储已经被JVM加载的类信息（版本、字段、方法、接口）、常量、静态变量、即时编译器编译后的代码和数据。该区域同堆一样，也是被各个线程共享的内存区域。</p>
<p><strong>注意：关于方法区，很多开发者会将其跟“永久区”混淆。</strong></p>
<p>所以我在这里对这两个概念进行一下对比：</p>
<ul>
<li><p>方法区是JVM规范中规定的一块区域，但是并不是实际实现，切忌将规范跟实现混为一谈。不同的JVM厂商可以有不同版本的“方法区”的实现。</p>
</li>
<li><p>HotSpot在JDK1.7以前使用“永久区”（或者叫Perm区）来实现方法区，在JDK1.8之后“永久区”就已经被移除了，取而代之的是一个叫作“元空间（metaspace）”的实现方式。</p>
<p><strong>总结一下就是：</strong></p>
<p>方法区是规范层面的东西，规定了这一个区域要存放哪些数据。永久区或者是metaspace是对方法区的不同实现，是实现层面的东西。</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对于JVM运行时内存布局，我们需要始终记住一点：上面介绍的这5块内容都是在Java虚拟机规范中定义的规则，这些规则只是描述了各个区域是负责做什么事情、存储什么样的数据、如何处理异常、是否允许线程间共享等。千万不要将它们理解为虚拟机的“具体实现”，虚拟机的具体实现有很多，比如Sun公司的HotSpot、JRocket、IBMJ9、以及我们非常熟悉的 Android Dalvik 和 ART 等。这些具体实现在符合上面 5 种运行时数据区的前提下，又各自有不同的实现方式。</p>
<p>总结来说，JVM的运行时内存结构中一共有两个“栈”和一个“堆”，分别是：Java虚拟机栈和本地方法栈，以及“GC堆”和方法区。除此之外还有一个程序计数器，但是我们开发者几乎不会用到这一部分，所以并不是重点学习内容。JVM内存中只有堆和方法区是线程共享的数据区域，其它区域都是线程私有的。并且程序计数器是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 </p>
<p>参考链接：<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67" target="_blank" rel="noopener">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2019/03/20/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><p>确保某个类只有一个实例,并且自行实例化并向整个系统提供这个实例。</p>
<h4 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2.介绍"></a>2.介绍</h4><p>单例模式属于创建类模式。<br>单例模式有以下特点：</p>
<ol>
<li>单例类只能有一个实例。</li>
<li>单例类必须自己创建自己的唯一实例。</li>
<li>单例类必须给所有其他对象提供这一实例。</li>
</ol>
<h4 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h4><h5 id="3-4-饿汉式"><a href="#3-4-饿汉式" class="headerlink" title="3.4 饿汉式"></a>3.4 饿汉式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;单例类.   </span><br><span class="line">public class Singleton &#123;</span><br><span class="line">    </span><br><span class="line">    private Singleton() &#123;&#x2F;&#x2F;构造方法为private,防止外部代码直接通过new来构造多个对象</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final Singleton single &#x3D; new Singleton();  &#x2F;&#x2F;在类初始化时，已经自行实例化,所以是线程安全的。</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;  &#x2F;&#x2F;通过getInstance()方法获取实例对象</span><br><span class="line">        return single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：写法简单，线程安全。</li>
<li>缺点：没有懒加载的效果，如果没有使用过的话会造成内存浪费。</li>
</ul>
<h5 id="3-1-懒汉式（线程不安全）"><a href="#3-1-懒汉式（线程不安全）" class="headerlink" title="3.1 懒汉式（线程不安全）"></a>3.1 懒汉式（线程不安全）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;单例类</span><br><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Singleton single &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (single &#x3D;&#x3D; null) &#123;</span><br><span class="line">            single &#x3D; new Singleton();  &#x2F;&#x2F;在第一次调用getInstance()时才实例化，实现懒加载,所以叫懒汉式</span><br><span class="line">        &#125;</span><br><span class="line">        return single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：实现了懒加载的效果。</li>
<li>缺点：线程不安全。</li>
</ul>
<h5 id="3-1-懒汉式（线程安全）"><a href="#3-1-懒汉式（线程安全）" class="headerlink" title="3.1 懒汉式（线程安全）"></a>3.1 懒汉式（线程安全）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;单例类</span><br><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Singleton single &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public static synchronized Singleton getInstance() &#123; &#x2F;&#x2F;加上synchronized同步 </span><br><span class="line">        if (single &#x3D;&#x3D; null) &#123;</span><br><span class="line">            single &#x3D; new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>优点：实现了懒加载的效果，线程安全。</li>
<li>缺点：使用synchronized会造成不必要的同步开销，而且大部分时候我们是用不到同步的。</li>
</ul>
<h5 id="3-3-双重检查锁定（DCL）"><a href="#3-3-双重检查锁定（DCL）" class="headerlink" title="3.3 双重检查锁定（DCL）"></a>3.3 双重检查锁定（DCL）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private volatile static Singleton singleton; &#x2F;&#x2F;volatile 能够防止代码的重排序，保证得到的对象是初始化过</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getSingleton() &#123;</span><br><span class="line">        if (singleton &#x3D;&#x3D; null) &#123;  &#x2F;&#x2F;第一次检查，避免不必要的同步</span><br><span class="line">            synchronized (Singleton.class) &#123;  &#x2F;&#x2F;同步</span><br><span class="line">                if (singleton &#x3D;&#x3D; null) &#123;   &#x2F;&#x2F;第二次检查，为null时才创建实例</span><br><span class="line">                    singleton &#x3D; new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>优点：懒加载，线程安全，效率较高</li>
<li>缺点：volatile影响一点性能，高并发下有一定的缺陷，某些情况下DCL会失效，虽然概率较小。</li>
</ul>
<h5 id="3-5-静态内部类"><a href="#3-5-静态内部类" class="headerlink" title="3.5 静态内部类"></a>3.5 静态内部类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        &#x2F;&#x2F;第一次调用getInstance方法时才加载SingletonHolder并初始化sInstance</span><br><span class="line">        return SingletonHolder.sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;静态内部类</span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final Singleton sInstance &#x3D; new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>优点：懒加载，线程安全，推荐使用</p>
<h5 id="3-6-枚举单例"><a href="#3-6-枚举单例" class="headerlink" title="3.6 枚举单例"></a>3.6 枚举单例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;   &#x2F;&#x2F;定义一个枚举的元素，它就是Singleton的一个实例</span><br><span class="line"></span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优点：线程安全，写法简单，能防止反序列化重新创建新的对象。</li>
<li>缺点：可读性不高，枚举会比静态常量多那么一丁点的内存。</li>
</ul>
<h5 id="3-7-使用容器实现单例模式"><a href="#3-7-使用容器实现单例模式" class="headerlink" title="3.7 使用容器实现单例模式"></a>3.7 使用容器实现单例模式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;单例管理类</span><br><span class="line">public class SingletonManager &#123;</span><br><span class="line">    private static Map&lt;String, Object&gt; objMap &#x3D; new HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    public static void registerService(String key, Object instance) &#123;</span><br><span class="line">        if (!objMap.containsKey(key)) &#123;</span><br><span class="line">            objMap.put(key, instance);&#x2F;&#x2F;添加单例</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object getService(String key) &#123;</span><br><span class="line">        return objMap.get(key);&#x2F;&#x2F;获取单例</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优点：方便管理。</li>
<li>缺点：写法稍复杂。</li>
</ul>
<h4 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a>4.注意事项</h4><p>使用反射能够破坏单例模式，所以应该慎用反射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Constructor con &#x3D; Singleton.class.getDeclaredConstructor();</span><br><span class="line">    con.setAccessible(true);</span><br><span class="line">    &#x2F;&#x2F; 通过反射获取实例</span><br><span class="line">    Singleton singeton1 &#x3D; (Singleton) con.newInstance();</span><br><span class="line">    Singleton singeton2 &#x3D; (Singleton) con.newInstance();</span><br><span class="line">    System.out.println(singeton1&#x3D;&#x3D;singeton2);&#x2F;&#x2F;结果为false,singeton1和singeton2将是两个不同的实例</span><br></pre></td></tr></table></figure>



<p>可以通过当第二次调用构造函数时抛出异常来防止反射破坏单例，以懒汉式为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static boolean flag &#x3D; true;</span><br><span class="line">    private static Singleton single &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            flag &#x3D; !flag;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new RuntimeException(&quot;单例模式被破坏！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (single &#x3D;&#x3D; null) &#123;</span><br><span class="line">            single &#x3D; new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>反序列化时也会破坏单例模式，可以通过重写readResolve方法避免，以饿汉式为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton implements Serializable &#123;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final Singleton single &#x3D; new Singleton();</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return single;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object readResolve() throws ObjectStreamException &#123;&#x2F;&#x2F;重写readResolve()</span><br><span class="line">        return single;&#x2F;&#x2F;直接返回单例对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5.应用场景"></a>5.应用场景</h5><ul>
<li>频繁访问数据库或文件的对象。</li>
<li>工具类对象；</li>
<li>创建对象时耗时过多或耗费资源过多，但又经常用到的对象；</li>
</ul>
<h5 id="6-优点"><a href="#6-优点" class="headerlink" title="6.优点"></a>6.优点</h5><ul>
<li>内存中只存在一个对象，节省了系统资源。</li>
<li>避免对资源的多重占用，例如一个文件操作，由于只有一个实例存在内存中，避免对同一资源文件的同时操作。</li>
</ul>
<h5 id="7-缺点"><a href="#7-缺点" class="headerlink" title="7.缺点"></a>7.缺点</h5><ul>
<li>获取对象时不能用new</li>
<li>单例对象如果持有Context，那么很容易引发内存泄露。</li>
<li>单例模式一般没有接口，扩展很困难，若要扩展，只能修改代码来实现。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>六大原则</title>
    <url>/2019/03/20/%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/bf92927c9d22" target="_blank" rel="noopener">https://www.jianshu.com/p/bf92927c9d22</a></p>
<h4 id="面向对象的六大原则"><a href="#面向对象的六大原则" class="headerlink" title="面向对象的六大原则"></a>面向对象的六大原则</h4><h5 id="1-单一职责原则（Single-Responsibility-Principle-SRP）"><a href="#1-单一职责原则（Single-Responsibility-Principle-SRP）" class="headerlink" title="1.单一职责原则（Single Responsibility Principle, SRP）"></a>1.单一职责原则（Single Responsibility Principle, SRP）</h5><p>定义：一个类应只包含单一的职责。</p>
<ul>
<li>一个类职责过大的话，首先引起的问题就是这个类比较大，显得过于臃肿，同时其复用性是比较差的。</li>
<li>其次就是如果修改某个职责，有可能引起另一个职责发生错误。这是我们极力所避免的，因此设计一个类时我们应当去遵循单一职责原则。</li>
</ul>
<h5 id="2-开放封闭原则-Open-ClosedPrinciple-OCP"><a href="#2-开放封闭原则-Open-ClosedPrinciple-OCP" class="headerlink" title="2.开放封闭原则(Open - ClosedPrinciple ,OCP)"></a>2.开放封闭原则(Open - ClosedPrinciple ,OCP)</h5><p>定义：一个模块、类、函数应当是对修改关闭，扩展开放。</p>
<ul>
<li>修改原有的代码可能会导致原本正常的功能出现问题。</li>
<li>因此，当需求有变化时，最好是通过扩展来实现，增加新的方法满足需求，而不是去修改原有代码。</li>
</ul>
<h5 id="3-里氏代换原则-Liskov-Substitution-Principle-LSP"><a href="#3-里氏代换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="3.里氏代换原则( Liskov Substitution Principle ,LSP )"></a>3.里氏代换原则( Liskov Substitution Principle ,LSP )</h5><p>定义：使用父类的地方能够使用子类来替换，反过来，则不行。</p>
<ul>
<li>使用子类对象去替换父类对象，程序将不会产生错误</li>
<li>因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</li>
<li>需要注意的是：</li>
</ul>
<ol>
<li>子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。如果一个方法只存在子类中，没有在父类中声明，则无法在以父类定义的对象中使用该方法。</li>
<li>父类应当被尽量设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现</li>
</ol>
<h5 id="4-依赖倒置原则-Dependence-Inversion-Principle-DIP"><a href="#4-依赖倒置原则-Dependence-Inversion-Principle-DIP" class="headerlink" title="4.依赖倒置原则( Dependence Inversion Principle ,DIP )"></a>4.依赖倒置原则( Dependence Inversion Principle ,DIP )</h5><p>定义：抽象不应该依赖于细节，细节应当依赖于抽象。</p>
<ul>
<li>即要面向接口编程，而不是面向具体实现去编程。</li>
<li>高层模块不应该依赖低层模块，应该去依赖抽象。</li>
</ul>
<h5 id="5-接口隔离原则-Interface-Segregation-Principle，ISL）"><a href="#5-接口隔离原则-Interface-Segregation-Principle，ISL）" class="headerlink" title="5.接口隔离原则(Interface Segregation Principle，ISL）"></a>5.接口隔离原则(Interface Segregation Principle，ISL）</h5><p>定义：一个类对另一个类的依赖应该建立在最小的接口上。</p>
<ul>
<li>一个类不应该依赖他不需要的接口。</li>
<li>接口的粒度要尽可能小，如果一个接口的方法过多，可以拆成多个接口。</li>
</ul>
<h5 id="6-迪米特原则-Law-of-Demeter-LoD"><a href="#6-迪米特原则-Law-of-Demeter-LoD" class="headerlink" title="6.迪米特原则(Law of  Demeter, LoD)"></a>6.迪米特原则(Law of  Demeter, LoD)</h5><p>定义：一个类尽量不要与其他类发生关系</p>
<ul>
<li>一个类对其他类知道的越少，耦合越小。</li>
<li>当修改一个类时，其他类的影响就越小，发生错误的可能性就越小。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Nexus3.12私服搭建</title>
    <url>/2019/03/18/Nexus3.12%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h5 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h5><p>（1）、<a href="https://www.sonatype.com/download-oss-sonatype" target="_blank" rel="noopener">nexus最新版本下载</a>（Nexus Repository Manager OSS 3.x - Windows）<br>（2）、解压后，安装服务，启动服务  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）左shift打开CMD窗口nexus-3.12.1-01-win64\nexus-3.12.1-01\bin目录    </span><br><span class="line">2）nexus.exe &#x2F;install  安装服务  </span><br><span class="line">3）nexus.exe &#x2F;start    启动服务  </span><br><span class="line">4）nexus.exe &#x2F;stop     停止服务</span><br></pre></td></tr></table></figure>
<p>（3）、使用nexus软件<br>在浏览器中输入<a href="http://localhost:8081/，点击“login" target="_blank" rel="noopener">http://localhost:8081/，点击“login</a> in”，输入admin/admin123即可。<br>（4）、管理目前的仓库<br>将central的远程地址修改如下（即改为aliyun的镜像，主要是速度快一些）：<a href="http://maven.aliyun.com/nexus/content/groups/public/" target="_blank" rel="noopener">http://maven.aliyun.com/nexus/content/groups/public/</a><br>（<a href="https://blog.csdn.net/ytfrdfiw/article/details/78476087" target="_blank" rel="noopener">参考链接</a>）</p>
<h4 id="多平台Nexus私服搭建"><a href="#多平台Nexus私服搭建" class="headerlink" title="多平台Nexus私服搭建"></a>多平台Nexus私服搭建</h4><p><a href="http://www.10tiao.com/html/227/201703/2650238831/1.html" target="_blank" rel="noopener">Android Studio依赖管理与Nexus私服搭建</a>  </p>
<p>创建自己的仓库</p>
<p>创建用户</p>
<p>首先使用管理员密码登陆到 Nexus私服 并添加用户：</p>
<p>。。。。</p>
<p>上传自己的Module到仓库</p>
<p>1、 在项目级别的 build.gradle 中的 allprojects 下 repositories节点 添加 mavenLocal()：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenLocal()</span><br><span class="line">        maven&#123;</span><br><span class="line">            url &quot;http:&#x2F;&#x2F;localhost:8081&#x2F;repository&#x2F;PublicTitle&#x2F;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>2、 在 Lib Module 级别的 build.gradle 中添加 maven 插件 apply plugin: ‘maven’：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: &#39;com.android.library&#39;</span><br><span class="line">apply plugin: &#39;maven&#39;</span><br></pre></td></tr></table></figure>

<p>3、 在 Lib Module 级别的 build.gradle 中 android节点 添加上传行为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories.mavenDeployer &#123;</span><br><span class="line">        repository(url: &quot;http:&#x2F;&#x2F;localhost:8081&#x2F;repository&#x2F;PublicTitle&#x2F;&quot;)&#123;</span><br><span class="line">            authentication(userName: &quot;wz&quot;,password: &quot;123456&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        pom.groupId &#x3D; &#39;com.hopechart&#39;</span><br><span class="line">        pom.artifactId &#x3D; &#39;PublicTitle&#39;</span><br><span class="line">        pom.version &#x3D; &#39;1.0.1&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用Gradle插件上传aar到Maven私服，点击 uploadArchives 自动上传：</p>
<p>5、引用私服中的Module  </p>
<p>在需要依赖 Module 的 build.gradle 中添加如下节点,其中URL就是上文中创建仓库的ur</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;项目级别的 build.gradle</span><br><span class="line"> allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        ......</span><br><span class="line">        maven&#123;</span><br><span class="line">            url &quot;http:&#x2F;&#x2F;localhost:8081&#x2F;repository&#x2F;PublicTitle&#x2F;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;model级别的 build.gradle</span><br><span class="line"></span><br><span class="line"> compile &#39;com.hopechart:PublicTitle:1.0.0&#39;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
        <category>打包编译</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>打包编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity的启动模式</title>
    <url>/2018/05/02/Activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="LaunchMode"><a href="#LaunchMode" class="headerlink" title="LaunchMode"></a>LaunchMode</h4><p>四种启动模式：standard、singleTop、singleTask、singleInstance</p>
<h5 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h5><p>标准模式，系统默认的启动模式。每次启动一个Activity都会重新创建一个新的实例。在这种模式下，谁启动这个Activity,那么这个Activity就运行在启动它的那个Activity所在的栈中。</p>
<h5 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h5><p>栈顶复用模式，在这种模式下，如果新的Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建，同时它的onNewIntent方法会被回调，通过此方法的参数可以取出当前的请求信息。如果新的Activity实例已存在但不是位于栈顶，那么新的Activity仍然会被重新创建。</p>
<h5 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h5><p>栈内复用模式，在这种模式下，只要Activity在一个栈中存在，那么多次启动此Activity都不会重新创建实例，和singleTop一样，系统也会回调onNewIntent。</p>
<h5 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h5><p>单实例模式，这是一种加强的singleTask模式，具备此模式的Activity只能单独位于一个任务栈中。</p>
<h4 id="TaskAffinity"><a href="#TaskAffinity" class="headerlink" title="TaskAffinity"></a>TaskAffinity</h4><p>这个参数标识一个Activity所需要的任务栈的名字，默认情况下所有Activity所需的任务栈的名字是应用的包名。</p>
<p>TaskAffinity主要和singleTask启动模式或者allowTaskReparenting属性配对使用。</p>
<h4 id="给Activity指定启动模式"><a href="#给Activity指定启动模式" class="headerlink" title="给Activity指定启动模式"></a>给Activity指定启动模式</h4><p>1、通过AndroidMenifest为Activity指定启动模式；</p>
<p>2、通过在Intent中设置标志位。</p>
<p>这两种启动模式第二种的优先级高于第一种，当两种同时存在，以第二种为准；另外，两种方式在限定范围上有所不同，第一种无法直接为Activity设定FLAG_ACTIVITY_CLEAR_TOP标识，第二种不能指定singleInstance模式。</p>
<h4 id="Activity的Flags"><a href="#Activity的Flags" class="headerlink" title="Activity的Flags"></a>Activity的Flags</h4><h5 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a>FLAG_ACTIVITY_NEW_TASK</h5><p>为Activity指定singleTask启动模式，效果和XML中指定该启动模式相同。</p>
<h5 id="FLAG-ACTIVITY-SINGLE-TOP"><a href="#FLAG-ACTIVITY-SINGLE-TOP" class="headerlink" title="FLAG_ACTIVITY_SINGLE_TOP"></a>FLAG_ACTIVITY_SINGLE_TOP</h5><p>为Activity指定singleTop模式</p>
<h5 id="FLAG-ACTIVITY-CLEAR-TOP"><a href="#FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="FLAG_ACTIVITY_CLEAR_TOP"></a>FLAG_ACTIVITY_CLEAR_TOP</h5><p>具有此标记的Activity,当它启动时，在同一任务栈中的所以位于它上面的Activity都要出栈，这种模式一般和FLAG_ACTIVITY_NEW_TASK配合使用。</p>
<h4 id="IntentFilter的匹配规则"><a href="#IntentFilter的匹配规则" class="headerlink" title="IntentFilter的匹配规则"></a>IntentFilter的匹配规则</h4><p>IntentFilter的过滤信息有action、category、data，action的匹配规则只要有一个action成功匹配就可以，category每个都要和过滤规则中的相同。</p>
<p>data由两部分最初，mineType和URI,mineType指媒体类型，如image/jpeg、video/*等，</p>
<p>URI结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;scheme&gt;:&#x2F;&#x2F;&lt;host&gt;:&lt;port&gt;&#x2F;[&lt;path&gt;|[pathPrefix]|[pathPattern]]</span><br></pre></td></tr></table></figure>

<p>过滤规则中没有红的URI时默认content和file,也就是说，虽然没有指定URI,但是Intent的URI部分的scheme必须为content或者file才能匹配。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio安装panltUML</title>
    <url>/2017/04/03/Android%20Studio%E5%AE%89%E8%A3%85panltUML/</url>
    <content><![CDATA[<h3 id="安装panltUML插件"><a href="#安装panltUML插件" class="headerlink" title="安装panltUML插件"></a>安装panltUML插件</h3><p>1.File-&gt;Settings-&gt;Plugins-&gt;Browse repositories<br>2.在搜索框输入plantUML<br>3.导入插件Install plugin<br>如果以上步骤正确的完成，重启AndroidStudio 右键-&gt;new 的时候你会发现多了这么一堆东西，如果出现了这些说明plantUML已经正确的安装了。</p>
<h3 id="安装Graphviz"><a href="#安装Graphviz" class="headerlink" title="安装Graphviz"></a>安装Graphviz</h3><p>设置plantUML<br>1.点击右上角的设置按钮或进入File-&gt;Settings-&gt;Other Settings -&gt;PlantUML<br>2.将文件路径填写为刚刚Graphviz的目录下bin目录中dot.exe文件。<br>(我的为：D:/Program/Graphviz/bin/dot.exe)<br>3.点击OK 刷新一下界面就能看到这个了</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>UML</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>UML</tag>
      </tags>
  </entry>
</search>
