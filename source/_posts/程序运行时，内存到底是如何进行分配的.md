---
title: 程序运行时，内存到底是如何进行分配的
date: 2020-04-04 19:10:43
categories: 
- Java
- JVM
tag: 
- Java
- JVM
---

### JVM 中的内存划分

JVM 中的内存可以划分为若干个不同的数据区域，主要分为：程序计数器、虚拟机栈、本地方法栈、堆、方法区。

线程私有数据区：程序计数器、虚拟机栈、本地方法栈；

线程共有数据区：堆、方法区；

下面的图可以概况本章内容

![](https://s0.lgstatic.com/i/image3/M01/02/8D/Ciqah157GD2AYLFtAADxheNgCA0454.png)

#### 程序计数器（ProgramCounterRegister）

Java程序是多线程的，CPU可以在多个线程中分配执行时间片段。当某一个线程被CPU挂起时，需要记录代码已经执行到的位置，方便 CPU 重新执行此线程时，知道从哪行指令开始执行。这就是程序计数器的作用。

程序计数器”是虚拟机中一块较小的内存空间，主要用于记录当前线程执行的位置。

关于程序计数器还有几点**需要格外注意**：

在 Java 虚拟机规范中，对程序计数器这一区域没有规定任何 OutOfMemoryError 情况（或许是感觉没有必要吧）。

程序计数器是线程私有的，每条线程内部都有一个私有程序计数器。它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

当一个线程正在执行一个 Java 方法的时候，这个计数器记录的是正在执行的虚拟机字节码指令的地址。如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。

#### 虚拟机栈

虚拟机栈也是线程私有的，与线程的生命周期同步。在 Java 虚拟机规范中，对这个区域规定了两种异常状况：

1. StackOverflowError：当线程请求栈深度超出虚拟机栈所允许的深度时抛出
2. OutOfMemoryError：当Java虚拟机动态扩展到无法申请足够内存时抛出。

JVM 是基于栈的解释器执行的，DVM 是基于寄存器解释器执行的。

上面这句话里的“基于栈”指的就是虚拟机栈。虚拟机栈的初衷是用来描述 Java 方法执行的内存模型，每个方法被执行的时候，JVM 都会在虚拟机栈中创建一个栈帧。

#####  栈帧  

栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，每一个线程在执行某个方法时，都会为这个方法创建一个栈帧。一个线程包含多个栈帧，而每个栈帧内部包含局部变量表、操作数栈、动态连接、返回地址等。

##### 本地方法栈

本地方法栈和上面介绍的虚拟栈基本相同，只不过是针对本地（native）方法。在开发中如果涉及JNI可能接触本地方法栈多一些。

#### 堆

Java堆（Heap）是JVM所管理的内存中最大的一块，该区域唯一目的就是存放对象实例，几乎所有对象的实例都在堆里面分配，因此它也是Java垃圾收集器（GC）管理的主要区域，有时候也叫作“GC 堆”（关于堆的 GC 回收机制将会在后续课时中做详细介绍）。同时它也是所有线程共享的内存区域，因此被分配在此区域的对象如果被多个线程访问的话，需要考虑线程安全问题。

按照对象存储时间的不同，堆中的内存可以划分为新生代（Young）和老年代（Old），其中新生代又被划分为 Eden 和 Survivor 区。

#### 方法区

方法区（MethodArea）也是JVM规范里规定的一块运行时数据区。方法区主要是存储已经被JVM加载的类信息（版本、字段、方法、接口）、常量、静态变量、即时编译器编译后的代码和数据。该区域同堆一样，也是被各个线程共享的内存区域。

**注意：关于方法区，很多开发者会将其跟“永久区”混淆。**

所以我在这里对这两个概念进行一下对比：

- 方法区是JVM规范中规定的一块区域，但是并不是实际实现，切忌将规范跟实现混为一谈。不同的JVM厂商可以有不同版本的“方法区”的实现。

- HotSpot在JDK1.7以前使用“永久区”（或者叫Perm区）来实现方法区，在JDK1.8之后“永久区”就已经被移除了，取而代之的是一个叫作“元空间（metaspace）”的实现方式。

  **总结一下就是：**

  方法区是规范层面的东西，规定了这一个区域要存放哪些数据。永久区或者是metaspace是对方法区的不同实现，是实现层面的东西。

#### 总结

对于JVM运行时内存布局，我们需要始终记住一点：上面介绍的这5块内容都是在Java虚拟机规范中定义的规则，这些规则只是描述了各个区域是负责做什么事情、存储什么样的数据、如何处理异常、是否允许线程间共享等。千万不要将它们理解为虚拟机的“具体实现”，虚拟机的具体实现有很多，比如Sun公司的HotSpot、JRocket、IBMJ9、以及我们非常熟悉的 Android Dalvik 和 ART 等。这些具体实现在符合上面 5 种运行时数据区的前提下，又各自有不同的实现方式。

总结来说，JVM的运行时内存结构中一共有两个“栈”和一个“堆”，分别是：Java虚拟机栈和本地方法栈，以及“GC堆”和方法区。除此之外还有一个程序计数器，但是我们开发者几乎不会用到这一部分，所以并不是重点学习内容。JVM内存中只有堆和方法区是线程共享的数据区域，其它区域都是线程私有的。并且程序计数器是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 

参考链接：https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67

